

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="朱羽飞">
  <meta name="keywords" content="">
  
    <meta name="description" content="二进制数组（ArrayBuffer对象、TypedArray视图和DataView视图）是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011年2月发布），ES6将它们纳入了ECMAScript规格，并且增加了新的方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6第十二章 二进制数组">
<meta property="og:url" content="http://example.com/2022/06/24/ECAMScript-twelve-chart/index.html">
<meta property="og:site_name" content="micky 朱羽飞的博客">
<meta property="og:description" content="二进制数组（ArrayBuffer对象、TypedArray视图和DataView视图）是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011年2月发布），ES6将它们纳入了ECMAScript规格，并且增加了新的方法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-24T23:14:54.000Z">
<meta property="article:modified_time" content="2023-05-17T07:15:56.546Z">
<meta property="article:author" content="micky">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>ES6第十二章 二进制数组 - micky 朱羽飞的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Micky-朱羽飞</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ES6第十二章 二进制数组"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-24 23:14" pubdate>
          2022年6月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          165 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ES6第十二章 二进制数组</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h1><p>二进制数组（ArrayBuffer对象、TypedArray视图和DataView视图）是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011年2月发布），ES6将它们纳入了ECMAScript规格，并且增加了新的方法。</p>
<p>这个接口的原始设计目的，与WebGL项目有关。所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。</p>
<p>二进制数组就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了JavaScript处理二进制数据的能力，使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信。</p>
<h3 id="二进制数组由三类对象组成"><a href="#二进制数组由三类对象组成" class="headerlink" title="二进制数组由三类对象组成"></a>二进制数组由三类对象组成</h3><ol>
<li><p>ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内<br>存。</p>
</li>
<li><p>TypedArray视图：共包括9种类型的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图,Float32Array（32位浮点数）数组视图等等。</p>
</li>
<li><p>DataView视图：可以自定义复合格式的视图，比如第一个字节是Uint8（无符号8位整数）、第二、三个字节是Int16（16位整数）、第四个字节开始是Float32（32位浮点数）等等，此外还可以自定义字节序。</p>
</li>
</ol>
<h5 id="注意，二进制数组并不是真正的数组，而是类似数组的对象。"><a href="#注意，二进制数组并不是真正的数组，而是类似数组的对象。" class="headerlink" title="注意，二进制数组并不是真正的数组，而是类似数组的对象。"></a><code>注意，二进制数组并不是真正的数组，而是类似数组的对象。</code></h5><p>TypedArray视图支持的数据类型一共有9种（DataView视图支持除Uint8C以外的其他8种）。</p>
<p> 数据类型  字节长度  含义        对应的C语言类型<br> Int8   1    8位带符号整数      signed char<br> Uint8   1    8位不带符号整数      unsigned char<br> Uint8C   1    8位不带符号整数（自动过滤溢出）  unsigned char<br> Int16    2    16位带符号整数      short<br> Uint16   2    16位不带符号整数      unsigned short<br> Int32    4    32位带符号整数      int<br> Uint32   4   32位不带符号的整数     unsigned int<br> Float32   4    32位浮点数       float<br> Float64   8    64位浮点数       double</p>
<h2 id="ArrayBuffer对象"><a href="#ArrayBuffer对象" class="headerlink" title="ArrayBuffer对象"></a>ArrayBuffer对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p>
<p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>
<p> var buf &#x3D; new ArrayBuffer(32);<br>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p>
<p> var buf &#x3D; new ArrayBuffer(32);<br> var dataView &#x3D; new DataView(buf);<br> dataView.getUint8(0) &#x2F;&#x2F; 0</p>
<p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p>
<h4 id="ArrayBufer-prototype-byteLength"><a href="#ArrayBufer-prototype-byteLength" class="headerlink" title="ArrayBufer.prototype.byteLength"></a>ArrayBufer.prototype.byteLength</h4><p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p>
<p> var buffer &#x3D; new ArrayBuffer(32);<br> buffer.byteLength<br> &#x2F;&#x2F;32<br>如果要分配的内存区域很大，有可能分配失败(所以有必要检查是否分配成功)</p>
<p> if(buffer.byteLength &#x3D;&#x3D;&#x3D; n){<br>  &#x2F;&#x2F;成功<br> }else {<br>  &#x2F;&#x2F;失败<br> }</p>
<h4 id="ArrayBuffer-prototype-slice"><a href="#ArrayBuffer-prototype-slice" class="headerlink" title="ArrayBuffer.prototype.slice()"></a>ArrayBuffer.prototype.slice()</h4><p><code>ArrayBuffer</code>实例有一个slice方法，允许将内存区域的一部分，拷贝成一个新的ArrayBuffer对象。</p>
<p> var buffer &#x3D; new ArrayBuffer(8);<br> var newBuffer &#x3D; buffer.slice(0, 3);</p>
<p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p>
<p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p>
<h4 id="ArrayBuffer-isView"><a href="#ArrayBuffer-isView" class="headerlink" title="ArrayBuffer.isView()"></a>ArrayBuffer.isView()</h4><p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p>
<p> var buffer &#x3D; new ArrayBuffer(8);<br> ArrayBuffer.isView(buffer) &#x2F;&#x2F; false<br> var v &#x3D; new Int32Array(buffer);<br> ArrayBuffer.isView(v) &#x2F;&#x2F; true</p>
<h2 id="TypedArray视图"><a href="#TypedArray视图" class="headerlink" title="TypedArray视图"></a>TypedArray视图</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ArrayBuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer有两种视图，一种是TypedArray视图，另一种是DataView视图。</p>
<p>前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。目前，TypedArray视图一共包括9种类型，每一种视图都是一种构造函数。Int8Array：8位有符号整数，长度1个字节。</p>
<ul>
<li>Uint8Array：8位无符号整数，长度1个字节。</li>
<li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li>
<li>Int16Array：16位有符号整数，长度2个字节。</li>
<li>Uint16Array：16位无符号整数，长度2个字节。</li>
<li>Int32Array：32位有符号整数，长度4个字节。</li>
<li>Uint32Array：32位无符号整数，长度4个字节。</li>
<li>Float32Array：32位浮点数，长度4个字节。</li>
<li>Float64Array：64位浮点数，长度8个字节。</li>
</ul>
<p>这9个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的<br>方法，在它们上面都能使用。普通数组与TypedArray数组的差异主要在以下方面。</p>
<ul>
<li>TypedArray数组的所有成员，都是同一种类型。</li>
<li>TypedArray数组的成员是连续的，不会有空位。</li>
<li>TypedArray数组成员的默认值为0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个</li>
<li>TypedArray数组，里面10个成员都是0。</li>
<li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。<br>构造函数有多种用法。</p>
<ol>
<li>TypedArray(buffer, byteOffset&#x3D;0, length?)</li>
</ol>
<p> 同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p>
<p>  &#x2F;&#x2F; 创建一个8字节的ArrayBuffer<br>  var b &#x3D; new ArrayBuffer(8);<br>  &#x2F;&#x2F; 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾<br>  var v1 &#x3D; new Int32Array(b);<br>  &#x2F;&#x2F; 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾<br>  var v2 &#x3D; new Uint8Array(b, 2);<br>  &#x2F;&#x2F; 创建一个指向b的Int16视图，开始于字节2，长度为2<br>  var v3 &#x3D; new Int16Array(b, 2, 2);<br>  上面代码在一段长度为8个字节的内存（b）之上，生成了三个视图：v1、v2和v3。</p>
<p> 视图的构造函数可以接受三个参数：</p>
<p> 第一个参数（必需）：视图对应的底层ArrayBuffer对象。</p>
<p> 第二个参数（可选）：视图开始的字节序号，默认从0开始。</p>
<p> 第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。</p>
<ol start="2">
<li>TypedArray(length)</li>
</ol>
<p> 视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p>
<p>  var f64a &#x3D; new Float64Array(8);<br>  f64a[0] &#x3D; 10;<br>  f64a[1] &#x3D; 20;<br>  f64a[2] &#x3D; f64a[0] + f64a[1];</p>
<p> 上面代码生成一个8个成员的Float64Array数组（共64字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p>
<ol start="3">
<li>TypedArray(typedArray)</li>
</ol>
<p> TypedArray数组的构造函数，可以接受另一个TypedArray实例作为参数。</p>
<p>  var typedArray &#x3D; new Int8Array(new Uint8Array(4));</p>
<p> 上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p>
<p> 注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p>
<p>  var x &#x3D; new Int8Array([1, 1]);<br>  var y &#x3D; new Int8Array(x);<br>  x[0] &#x2F;&#x2F; 1<br>  y[0] &#x2F;&#x2F; 1<br>  x[0] &#x3D; 2;<br>  y[0] &#x2F;&#x2F; 1<br> 上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。<br> 如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p>
<p>  var x &#x3D; new Int8Array([1, 1]);<br>  var y &#x3D; new Int8Array(x.buffer);<br>  x[0] &#x2F;&#x2F; 1<br>  y[0] &#x2F;&#x2F; 1<br>  x[0] &#x3D; 2;<br>  y[0] &#x2F;&#x2F; 2</p>
<ol start="4">
<li>TypedArray(arrayLikeObject)</li>
</ol>
<p> 构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p>
<p>  var typedArray &#x3D; new Uint8Array([1, 2, 3, 4]);<br> 注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p>
<p> 上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。<br> TypedArray数组也可以转换回普通数组。</p>
<p>  var normalArray &#x3D; Array.prototype.slice.call(typedArray);</p>
<h2 id="12-2-3-数组方法"><a href="#12-2-3-数组方法" class="headerlink" title="12.2.3 数组方法"></a>12.2.3 数组方法</h2><p>普通数组的操作方法和属性，对TypedArray数组完全适用。</p>
<ul>
<li>TypedArray.prototype.copyWithin(target, start[, end &#x3D; this.length])</li>
<li>TypedArray.prototype.entries()</li>
<li>TypedArray.prototype.every(callbackfn, thisArg?)</li>
<li>TypedArray.prototype.fill(value, start&#x3D;0, end&#x3D;this.length)</li>
<li>TypedArray.prototype.filter(callbackfn, thisArg?)</li>
<li>TypedArray.prototype.find(predicate, thisArg?)</li>
<li>TypedArray.prototype.findIndex(predicate, thisArg?)</li>
<li>TypedArray.prototype.forEach(callbackfn, thisArg?)</li>
<li>TypedArray.prototype.indexOf(searchElement, fromIndex&#x3D;0)</li>
<li>TypedArray.prototype.join(separator)</li>
<li>TypedArray.prototype.keys()</li>
<li>TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)</li>
<li>TypedArray.prototype.map(callbackfn, thisArg?)</li>
<li>TypedArray.prototype.reduce(callbackfn, initialValue?)</li>
<li>TypedArray.prototype.reduceRight(callbackfn, initialValue?)</li>
<li>TypedArray.prototype.reverse()</li>
<li>TypedArray.prototype.slice(start&#x3D;0, end&#x3D;this.length)</li>
<li>TypedArray.prototype.some(callbackfn, thisArg?)</li>
<li>TypedArray.prototype.sort(comparefn)</li>
<li>TypedArray.prototype.toLocaleString(reserved1?, reserved2?)</li>
<li>TypedArray.prototype.toString()</li>
<li>TypedArray.prototype.values()</li>
<li></li>
</ul>
<p>上面所有方法的用法，请参阅数组方法的介绍，这里不再重复了。</p>
<p>注意，TypedArray数组没有concat方法。如果想要合并多个TypedArray数组，可以用下面这个函数。</p>
<p> function concatenate(resultConstructor, …arrays) {<br>  let totalLength &#x3D; 0;<br>  for (let arr of arrays) {<br>   totalLength +&#x3D; arr.length;<br>  }<br>  let result &#x3D; new resultConstructor(totalLength);<br>  let offset &#x3D; 0;<br>  for (let arr of arrays) {<br>   result.set(arr, offset);<br>   offset +&#x3D; arr.length;<br>  }<br>  return result;<br> }<br> concatenate(Uint8Array, Uint8Array.of(1, 2), Uint8Array.of(3, 4))<br> &#x2F;&#x2F; Uint8Array [1, 2, 3, 4]</p>
<p>另外，TypedArray数组与普通数组一样，部署了Iterator接口，所以可以被遍历。</p>
<p>let ui8 &#x3D; Uint8Array.of(0, 1, 2);<br> for (let byte of ui8) {<br>  console.log(byte);<br> }<br> &#x2F;&#x2F; 0<br> &#x2F;&#x2F; 1<br> &#x2F;&#x2F; 2</p>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序指的是数值在内存中的表示方式。</p>
<p> var buffer &#x3D; new ArrayBuffer(16);<br> var int32View &#x3D; new Int32Array(buffer);<br> for (var i &#x3D; 0; i &lt; int32View.length; i++) {<br>  int32View[i] &#x3D; i * 2;<br> }</p>
<p>上面代码生成一个16字节的ArrayBuffer对象，然后在它的基础上，建立了一个32位整数的视图。由于每个32位整数占据4个字节，所以一共可以写入4个整数，依次为0，2，4，6。</p>
<p>如果在这段数据上接着建立一个16位整数的视图，则可以读出完全不一样的结果。</p>
<p> var int16View &#x3D; new Int16Array(buffer);<br> for (var i &#x3D; 0; i &lt; int16View.length; i++) {<br> console.log(“Entry “ + i + “: “ + int16View[i]);<br> }<br> &#x2F;&#x2F; Entry 0: 0<br> &#x2F;&#x2F; Entry 1: 0<br> &#x2F;&#x2F; Entry 2: 2<br> &#x2F;&#x2F; Entry 3: 0<br> &#x2F;&#x2F; Entry 4: 4<br> &#x2F;&#x2F; Entry 5: 0<br> &#x2F;&#x2F; Entry 6: 6<br> &#x2F;&#x2F; Entry 7: 0</p>
<p>由于每个16位整数占据2个字节，所以整个ArrayBuffer对象现在分成8段。然后，由于x86体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。</p>
<p>比如，一个占据四个字节的16进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以TypedArray数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p>
<p>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，TypedArray数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript引入DataView对象，可以设定字节序。</p>
<p> &#x2F;&#x2F; 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]<br> var buffer &#x3D; new ArrayBuffer(4);<br> var v1 &#x3D; new Uint8Array(buffer);<br> v1[0] &#x3D; 2;<br> v1[1] &#x3D; 1;<br> v1[2] &#x3D; 3;<br> v1[3] &#x3D; 7;<br> var uInt16View &#x3D; new Uint16Array(buffer);<br> &#x2F;&#x2F; 计算机采用小端字节序<br> &#x2F;&#x2F; 所以头两个字节等于258<br> if (uInt16View[0] &#x3D;&#x3D;&#x3D; 258) {<br>  console.log(‘OK’); &#x2F;&#x2F; “OK”<br> }<br> &#x2F;&#x2F; 赋值运算<br> uInt16View[0] &#x3D; 255; &#x2F;&#x2F; 字节变为[0xFF, 0x00, 0x03, 0x07]<br> uInt16View[0] &#x3D; 0xff05; &#x2F;&#x2F; 字节变为[0x05, 0xFF, 0x03, 0x07]<br> uInt16View[1] &#x3D; 0x0210; &#x2F;&#x2F; 字节变为[0x05, 0xFF, 0x10, 0x02]</p>
<p>下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。</p>
<p> const BIG_ENDIAN &#x3D; Symbol(‘BIG_ENDIAN’);<br> const LITTLE_ENDIAN &#x3D; Symbol(‘LITTLE_ENDIAN’);<br> function getPlatformEndianness() {<br>  let arr32 &#x3D; Uint32Array.of(0x12345678);<br>  let arr8 &#x3D; new Uint8Array(arr32.buffer);<br>  switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) {<br>   case 0x12345678:<br>   return BIG_ENDIAN;<br>   case 0x78563412:<br>   return LITTLE_ENDIAN;<br>   default:<br>   throw new Error(‘Unknown endianness’);<br>  }<br> }<br>总之，与普通数组相比，TypedArray数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p>
<h3 id="BYTES-PER-ELEMENT属性"><a href="#BYTES-PER-ELEMENT属性" class="headerlink" title="BYTES_PER_ELEMENT属性"></a>BYTES_PER_ELEMENT属性</h3><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p>
<p> Int8Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 1<br> Uint8Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 1<br> Int16Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 2<br> Uint16Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 2<br> Int32Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 4<br> Uint32Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 4<br> Float32Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 4<br> Float64Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 8</p>
<p>这个属性在TypedArray实例上也能获取，即有TypedArray.prototype.BYTES_PER_ELEMENT。</p>
<h3 id="ArrayBuffer与字符串的互相转换"><a href="#ArrayBuffer与字符串的互相转换" class="headerlink" title="ArrayBuffer与字符串的互相转换"></a>ArrayBuffer与字符串的互相转换</h3><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p>
<p> &#x2F;&#x2F; ArrayBuffer转为字符串，参数为ArrayBuffer对象<br> function ab2str(buf) {<br>  return String.fromCharCode.apply(null, new Uint16Array(buf));<br> }<br> &#x2F;&#x2F; 字符串转为ArrayBuffer对象，参数为字符串<br> function str2ab(str) {<br>  var buf &#x3D; new ArrayBuffer(str.length * 2); &#x2F;&#x2F; 每个字符占用2个字节<br>  var bufView &#x3D; new Uint16Array(buf);<br>  for (var i &#x3D; 0, strLen &#x3D; str.length; i &lt; strLen; i++) {<br>   bufView[i] &#x3D; str.charCodeAt(i);<br>  }<br>  return buf;<br> }</p>
<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如，8位视图只能容纳一个8位的二进制值，如果放入一个9位的值，就会溢出。</p>
<p>TypedArray数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。</p>
<p> var uint8 &#x3D; new Uint8Array(1);<br> uint8[0] &#x3D; 256;<br> uint8[0] &#x2F;&#x2F; 0<br> uint8[0] &#x3D; -1;<br> uint8[0] &#x2F;&#x2F; 255<br>上面代码中，uint8是一个8位视图，而256的二进制形式是一个9位的值100000000，这时就会发生溢出。根据规则，只会保留后8位，即00000000。uint8视图的解释规则是无符号的8位整数，所以00000000就是0。<br>负数在计算机内部采用“2的补码”表示，也就是说，将对应的正数值进行否运算，然后加1。比如，-1对应的正值是1，进行否运算以后，得到11111110，再加上1就是补码形式11111111。uint8按照无符号的8位整数解释11111111，返回结果就是255。</p>
<p>一个简单转换规则，可以这样表示。</p>
<p>正向溢出（overflow）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去1。</p>
<p>负向溢出（underflow）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值，再加上1。</p>
<p>请看下面的例子。</p>
<p> var int8 &#x3D; new Int8Array(1);<br> int8[0] &#x3D; 128;<br> int8[0] &#x2F;&#x2F; -128<br> int8[0] &#x3D; -129;<br> int8[0] &#x2F;&#x2F; 127</p>
<p>上面例子中，int8是一个带符号的8位整数视图，它的最大值是127，最小值是-128。输入值为128时，相当于正向溢出1，根据“最小值加上余值，再减去1”的规则，就会返回-128；输入值为-129时，相当于负向溢出1，根据“最大值减去余值，再加上1”的规则，就会返回127。</p>
<p>Uint8ClampedArray视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即0。</p>
<p> var uint8c &#x3D; new Uint8ClampedArray(1);<br> uint8c[0] &#x3D; 256;<br> uint8c[0] &#x2F;&#x2F; 255<br> uint8c[0] &#x3D; -1;<br> uint8c[0] &#x2F;&#x2F; 0</p>
<p>上面例子中，uint8C是一个Uint8ClampedArray视图，正向溢出时都返回255，负向溢出都返回0。</p>
<h3 id="TypedArray-prototype-buffer"><a href="#TypedArray-prototype-buffer" class="headerlink" title="TypedArray.prototype.buffer"></a>TypedArray.prototype.buffer</h3><p>TypedArray实例的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。</p>
<p> var a &#x3D; new Float32Array(64);<br> var b &#x3D; new Uint8Array(a.buffer);<br>上面代码的a视图对象和b视图对象，对应同一个ArrayBuffer对象，即同一段内存。</p>
<h3 id="TypedArray-prototype-byteLength，TypedArray-prototype-byteOffset"><a href="#TypedArray-prototype-byteLength，TypedArray-prototype-byteOffset" class="headerlink" title="TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset"></a>TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset</h3><p>byteLength属性返回TypedArray数组占据的内存长度，单位为字节。byteOffset属性返回TypedArray数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。</p>
<p> var b &#x3D; new ArrayBuffer(8);<br> var v1 &#x3D; new Int32Array(b);<br> var v2 &#x3D; new Uint8Array(b, 2);<br> var v3 &#x3D; new Int16Array(b, 2, 2);<br> v1.byteLength &#x2F;&#x2F; 8<br> v2.byteLength &#x2F;&#x2F; 6<br> v3.byteLength &#x2F;&#x2F; 4<br> v1.byteOffset &#x2F;&#x2F; 0<br> v2.byteOffset &#x2F;&#x2F; 2<br> v3.byteOffset &#x2F;&#x2F; 2</p>
<h3 id="TypedArray-prototype-length"><a href="#TypedArray-prototype-length" class="headerlink" title="TypedArray.prototype.length"></a>TypedArray.prototype.length</h3><p>length属性表示TypedArray数组含有多少个成员。注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度。</p>
<p> var a &#x3D; new Int16Array(8);<br> a.length &#x2F;&#x2F; 8<br> a.byteLength &#x2F;&#x2F; 16</p>
<h4 id="TypedArray-prototype-set"><a href="#TypedArray-prototype-set" class="headerlink" title="TypedArray.prototype.set()"></a>TypedArray.prototype.set()</h4><p>TypedArray数组的set方法用于复制数组（普通数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p>
<p> var a &#x3D; new Uint8Array(8);<br> var b &#x3D; new Uint8Array(8);<br> b.set(a);</p>
<p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。</p>
<p>set方法还可以接受第二个参数，表示从b对象的哪一个成员开始复制a对象。</p>
<p> var a &#x3D; new Uint16Array(8);<br> var b &#x3D; new Uint16Array(10);<br> b.set(a, 2)</p>
<p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p>
<h3 id="TypedArray-prototype-subarray"><a href="#TypedArray-prototype-subarray" class="headerlink" title="TypedArray.prototype.subarray()"></a>TypedArray.prototype.subarray()</h3><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p>
<p> var a &#x3D; new Uint16Array(8);<br> var b &#x3D; a.subarray(2,3);<br> a.byteLength &#x2F;&#x2F; 16<br> b.byteLength &#x2F;&#x2F; 2</p>
<p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p>
<h4 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a>TypedArray.prototype.slice()</h4><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p>
<p> let ui8 &#x3D; Uint8Array.of(0, 1, 2);<br> ui8.slice(-1)<br> &#x2F;&#x2F; Uint8Array [ 2 ]</p>
<p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p>
<p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p>
<h3 id="TypedArray-of"><a href="#TypedArray-of" class="headerlink" title="TypedArray.of()"></a>TypedArray.of()</h3><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p>
<p> Float32Array.of(0.151, -8, 3.7)<br> &#x2F;&#x2F; Float32Array [ 0.151, -8, 3.7 ]<br> 下面三种方法都会生成同样一个TypedArray数组。<br> &#x2F;&#x2F; 方法一<br> let tarr &#x3D; new Uint8Array([1,2,3]);<br> &#x2F;&#x2F; 方法二<br> let tarr &#x3D; Uint8Array.of(1,2,3);<br> &#x2F;&#x2F; 方法三<br> let tarr &#x3D; new Uint8Array(3);<br> tarr[0] &#x3D; 1;<br> tarr[1] &#x3D; 2;<br> tarr[2] &#x3D; 3;</p>
<h3 id="TypedArray-from"><a href="#TypedArray-from" class="headerlink" title="TypedArray.from()"></a>TypedArray.from()</h3><p>静态方法from接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的TypedArray实例。</p>
<p> Uint16Array.from([0, 1, 2])<br> &#x2F;&#x2F; Uint16Array [ 0, 1, 2 ]<br> 这个方法还可以将一种TypedArray实例，转为另一种。<br> var ui16 &#x3D; Uint16Array.from(Uint8Array.of(0, 1, 2));<br> ui16 instanceof Uint16Array &#x2F;&#x2F; true<br> from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。<br> Int8Array.of(127, 126, 125).map(x &#x3D;&gt; 2 <em>x)<br> &#x2F;&#x2F; Int8Array [ -2, -4, -6 ]<br>Int16Array.from(Int8Array.of(127, 126, 125), x &#x3D;&gt; 2</em> x)<br> &#x2F;&#x2F; Int16Array [ 254, 252, 250 ]</p>
<p>上面的例子中，from方法没有发生溢出，这说明遍历不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式。</p>
<h2 id="复合视图"><a href="#复合视图" class="headerlink" title="复合视图"></a>复合视图</h2><p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p>
<p> var buffer &#x3D; new ArrayBuffer(24);<br> var idView &#x3D; new Uint32Array(buffer, 0, 1);<br> var usernameView &#x3D; new Uint8Array(buffer, 4, 16);<br> var amountDueView &#x3D; new Float32Array(buffer, 20, 1);</p>
<p>上面代码将一个24字节长度的ArrayBuffer对象，分成三个部分：</p>
<p>字节0到字节3：1个32位无符号整数</p>
<p>字节4到字节19：16个8位整数</p>
<p>字节20到字节23：1个32位浮点数</p>
<p>这种数据结构可以用如下的C语言描述：</p>
<p> struct someStruct {<br>  unsigned long id;<br>  char username[16];<br>  float amountDue;<br> };</p>
<h2 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h2><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
<p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p>
<p>DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);</p>
<p>下面是一个例子。</p>
<p> var buffer &#x3D; new ArrayBuffer(24);<br> var dv &#x3D; new DataView(buffer);<br> DataView实例有以下属性，含义与TypedArray实例的同名方法相同。<br> DataView.prototype.buffer：返回对应的ArrayBuffer对象<br> DataView.prototype.byteLength：返回占据的内存字节长度<br> DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始<br> DataView实例提供8个方法读取内存。<br> getInt8：读取1个字节，返回一个8位整数。<br> getUint8：读取1个字节，返回一个无符号的8位整数。<br> getInt16：读取2个字节，返回一个16位整数。<br> getUint16：读取2个字节，返回一个无符号的16位整数。<br> getInt32：读取4个字节，返回一个32位整数。<br> getUint32：读取4个字节，返回一个无符号的32位整数。<br> getFloat32：读取4个字节，返回一个32位浮点数。<br> getFloat64：读取8个字节，返回一个64位浮点数。</p>
<p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p>
<p> var buffer &#x3D; new ArrayBuffer(24);<br> var dv &#x3D; new DataView(buffer);<br> &#x2F;&#x2F; 从第1个字节读取一个8位无符号整数<br> var v1 &#x3D; dv.getUint8(0);<br> &#x2F;&#x2F; 从第2个字节读取一个16位无符号整数<br> var v2 &#x3D; dv.getUint16(1);<br> &#x2F;&#x2F; 从第4个字节读取一个16位无符号整数<br> var v3 &#x3D; dv.getUint16(3);</p>
<p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p>
<p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p>
<p> &#x2F;&#x2F; 小端字节序<br> var v1 &#x3D; dv.getUint16(1, true);<br> &#x2F;&#x2F; 大端字节序<br> var v2 &#x3D; dv.getUint16(3, false);<br> &#x2F;&#x2F; 大端字节序<br> var v3 &#x3D; dv.getUint16(3);<br> DataView视图提供8个方法写入内存。<br> setInt8：写入1个字节的8位整数。<br> setUint8：写入1个字节的8位无符号整数。<br> setInt16：写入2个字节的16位整数。<br> setUint16：写入2个字节的16位无符号整数。<br> setInt32：写入4个字节的32位整数。<br> setUint32：写入4个字节的32位无符号整数。<br> setFloat32：写入4个字节的32位浮点数。<br> setFloat64：写入8个字节的64位浮点数。</p>
<p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p>
<p> &#x2F;&#x2F; 在第1个字节，以大端字节序写入值为25的32位整数<br> dv.setInt32(0, 25, false);<br> &#x2F;&#x2F; 在第5个字节，以大端字节序写入值为25的32位整数<br> dv.setInt32(4, 25);<br> &#x2F;&#x2F; 在第9个字节，以小端字节序写入值为2.5的32位浮点数<br> dv.setFloat32(8, 2.5, true);<br> 如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。<br> var littleEndian &#x3D; (function() {<br> var buffer &#x3D; new ArrayBuffer(2);<br> new DataView(buffer).setInt16(0, 256, true);<br> return new Int16Array<a href="0">buffer</a> &#x3D;&#x3D;&#x3D; 256;<br> })();</p>
<p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p>
<h2 id="12-5-二进制数组的应用"><a href="#12-5-二进制数组的应用" class="headerlink" title="12.5 二进制数组的应用"></a>12.5 二进制数组的应用</h2><p>大量的Web API用到了ArrayBuffer对象和它的视图对象。</p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>传统上，服务器通过AJAX操作只能返回文本数据，即responseType属性默认为text。XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。</p>
<p> var xhr &#x3D; new XMLHttpRequest();<br> xhr.open(‘GET’, someUrl);<br> xhr.responseType &#x3D; ‘arraybuffer’;<br> xhr.onload &#x3D; function () {<br>  let arrayBuffer &#x3D; xhr.response;<br>  &#x2F;&#x2F; ···<br> };<br> xhr.send();</p>
<p>如果知道传回来的是32位整数，可以像下面这样处理。</p>
<p> xhr.onreadystatechange &#x3D; function () {<br>  if (req.readyState &#x3D;&#x3D;&#x3D; 4 ) {<br>   var arrayResponse &#x3D; xhr.response;<br>   var dataView &#x3D; new DataView(arrayResponse);<br>   var ints &#x3D; new Uint32Array(dataView.byteLength &#x2F; 4);<br>   xhrDiv.style.backgroundColor &#x3D; “#00FF00”;<br>   xhrDiv.innerText &#x3D; “Array is “ + ints.length + “uints long”;<br>  }<br> }</p>
<h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>网页Canvas元素输出的二进制像素数据，就是TypedArray数组。</p>
<p> var canvas &#x3D; document.getElementById(‘myCanvas’);<br> var ctx &#x3D; canvas.getContext(‘2d’);<br> var imageData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height);<br> var uint8ClampedArray &#x3D; imageData.data;</p>
<p>需要注意的是，上面代码的uint8ClampedArray虽然是一个TypedArray数组，但是它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray。<br>这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数，即只能取值0～255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p>
<p>举例来说，如果把像素的颜色值设为Uint8Array类型，那么乘以一个gamma值的时候，就必须这样计算：</p>
<p> u8[i] &#x3D; Math.min(255, Math.max(0, u8[i] * gamma));</p>
<p>因为Uint8Array类型对于大于255的运算结果（比如0xFF+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。<br>如果将颜色值设为Uint8ClampedArray类型，计算就简化许多。</p>
<p> pixels[i] *&#x3D; gamma;</p>
<p>Uint8ClampedArray类型确保将小于0的值设为0，将大于255的值设为255。注意，IE 10不支持该类型。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket可以通过ArrayBuffer，发送或接收二进制数据。</p>
<p> var socket &#x3D; new WebSocket(‘ws:&#x2F;&#x2F;127.0.0.1:8081’);<br> socket.binaryType &#x3D; ‘arraybuffer’;<br>  &#x2F;&#x2F; Wait until socket is open<br> socket.addEventListener(‘open’, function (event) {<br>  &#x2F;&#x2F; Send binary data<br>  var typedArray &#x3D; new Uint8Array(4);<br>  socket.send(typedArray.buffer);<br> });<br> &#x2F;&#x2F; Receive binary data<br> socket.addEventListener(‘message’, function (event) {<br>  var arrayBuffer &#x3D; event.data;<br>  &#x2F;&#x2F; ···<br> });</p>
<h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>Fetch API取回的数据，就是ArrayBuffer对象。</p>
<p> fetch(url)<br>  .then(function(request){<br>  return request.arrayBuffer()<br> })<br>  .then(function(arrayBuffer){<br>  &#x2F;&#x2F; …<br> });</p>
<h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象。</p>
<p> var fileInput &#x3D; document.getElementById(‘fileInput’);<br> var file &#x3D; fileInput.files[0];<br> var reader &#x3D; new FileReader();<br> reader.readAsArrayBuffer(file);<br> reader.onload &#x3D; function () {<br>  var arrayBuffer &#x3D; reader.result;<br>  &#x2F;&#x2F; ···<br> };<br>下面以处理bmp文件为例。假定file变量是一个指向bmp文件的文件对象，首先读取文件。</p>
<p> var reader &#x3D; new FileReader();<br> reader.addEventListener(“load”, processimage, false);<br> reader.readAsArrayBuffer(file);</p>
<p>然后，定义处理图像的回调函数：先在二进制数据之上建立一个DataView视图，再建立一个bitmap对象，用于存放处理后的数据，最后将图像展示在Canvas元素之中。</p>
<p> function processimage(e) {<br> var buffer &#x3D; e.target.result;<br> var datav &#x3D; new DataView(buffer);<br> var bitmap &#x3D; {};<br>  &#x2F;&#x2F; 具体的处理步骤<br> }<br>具体处理图像数据时，先处理bmp的文件头。具体每个文件头的格式和定义，请参阅有关资料。</p>
<p> bitmap.fileheader &#x3D; {};<br> bitmap.fileheader.bfType &#x3D; datav.getUint16(0, true);<br> bitmap.fileheader.bfSize &#x3D; datav.getUint32(2, true);<br> bitmap.fileheader.bfReserved1 &#x3D; datav.getUint16(6, true);<br> bitmap.fileheader.bfReserved2 &#x3D; datav.getUint16(8, true);<br> bitmap.fileheader.bfOffBits &#x3D; datav.getUint32(10, true);</p>
<p>接着处理图像元信息部分。</p>
<p> bitmap.infoheader &#x3D; {};<br> bitmap.infoheader.biSize &#x3D; datav.getUint32(14, true);<br> bitmap.infoheader.biWidth &#x3D; datav.getUint32(18, true);<br> bitmap.infoheader.biHeight &#x3D; datav.getUint32(22, true);<br> bitmap.infoheader.biPlanes &#x3D; datav.getUint16(26, true);<br> bitmap.infoheader.biBitCount &#x3D; datav.getUint16(28, true);<br> bitmap.infoheader.biCompression &#x3D; datav.getUint32(30, true);<br> bitmap.infoheader.biSizeImage &#x3D; datav.getUint32(34, true);<br> bitmap.infoheader.biXPelsPerMeter &#x3D; datav.getUint32(38, true);<br> bitmap.infoheader.biYPelsPerMeter &#x3D; datav.getUint32(42, true);<br> bitmap.infoheader.biClrUsed &#x3D; datav.getUint32(46, true);<br> bitmap.infoheader.biClrImportant &#x3D; datav.getUint32(50, true);</p>
<p>最后处理图像本身的像素信息。</p>
<p> var start &#x3D; bitmap.fileheader.bfOffBits;<br> bitmap.pixels &#x3D; new Uint8Array(buffer, start);</p>
<p>至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在Canvas网页元素之中。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ES6/" class="category-chain-item">ES6</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ES6/">#ES6</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ES6第十二章 二进制数组</div>
      <div>http://example.com/2022/06/24/ECAMScript-twelve-chart/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>朱羽飞</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/27/ECAMScript-fourteen-chart/" title="ES6 第十四章 iterator(遍历器)的概念">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ES6 第十四章 iterator(遍历器)的概念</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/22/ECAMScript-thirteenfourteen-chart/" title="ES6 第十三章 Set和Map数据结构">
                        <span class="hidden-mobile">ES6 第十三章 Set和Map数据结构</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
