

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="朱羽飞">
  <meta name="keywords" content="">
  
    <meta name="description" content="在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6第八章 函数的扩展">
<meta property="og:url" content="http://example.com/2017/06/13/2017-06-13-ECAMScript-eight-chart/index.html">
<meta property="og:site_name" content="micky 朱羽飞的博客">
<meta property="og:description" content="在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-06-13T15:35:54.000Z">
<meta property="article:modified_time" content="2023-05-13T16:42:51.041Z">
<meta property="article:author" content="micky">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>ES6第八章 函数的扩展 - micky 朱羽飞的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Micky-朱羽飞</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ES6第八章 函数的扩展"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-06-13 23:35" pubdate>
          2017年6月13日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          160 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ES6第八章 函数的扩展</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法</p>
<p> function log(x,y){<br>  y &#x3D; y|| ‘World’;<br>  console.log(x,y);<br> }<br> log(‘Hello’); &#x2F;&#x2F;Hello World<br> log(‘Hello’,’China’) &#x2F;&#x2F;Hello China<br> log(‘Helllo’,’’) &#x2F;&#x2F;Hello World<br>上面代码检查函数log的参数有没有赋值，如果没有，则指定默认值World，这种写法的缺点在于，如果没有参数y赋值了，但是对应的布尔值为false，则赋值不起作用，就像上面的代码最后一行，参数y等于空字符，结构被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值</p>
<p> if(typeof y &#x3D;&#x3D;&#x3D; ‘undefined’){<br>  y &#x3D; ‘World’;<br> }</p>
<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<p> function log(x,y &#x3D; ‘World’){<br>  console.log(x,y);<br> }<br> log(‘Hello’);<br> log(‘Hello’,’China’) &#x2F;&#x2F;Hello China<br> log(‘Hello’,’’) &#x2F;&#x2F;Hello</p>
<p>ES6的写法比ES5简介许多，而且非常自然</p>
<p>除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立即意识到哪些参数是可以省略的，不用查看函数体或文档，其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量的默认申明的，所以不能用let或const再次声明</p>
<p> function foo(x &#x3D; 5){<br>  let x &#x3D;1;&#x2F;&#x2F;error<br>  const x &#x3D;2;&#x2F;&#x2F;error<br> }</p>
<h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与结构赋值的默认值，结合起来使用</p>
<p> function foo({x,y&#x3D;5}){<br>  console.log(x,y);<br> }<br> foo({}); &#x2F;&#x2F;undefined,5<br> foo({x:1}); &#x2F;&#x2F;1,5<br> foo({x:1,y:2}) &#x2F;&#x2F;1,2<br> foo() &#x2F;&#x2F;TypeError:Cannot read property ‘x’ of undefined</p>
<p>另一个对象的结构赋值默认的例子</p>
<p> function fetch(url,{body &#x3D; ‘’,method &#x3D; ‘GET’,headers &#x3D;{} }){<br>  console.log(method);<br> }</p>
<p> fetch(‘<a target="_blank" rel="noopener" href="http://example.com&/#39;,{}">http://example.com&#39;,{}</a>)<br> &#x2F;&#x2F;“GET”</p>
<p> fetch(‘<a href="http://example.com/">http://example.com</a>‘)<br> &#x2F;&#x2F;报错</p>
<p>比较下面两种写法的区别</p>
<p> &#x2F;&#x2F;写法一<br> function m1({x &#x3D; 0,y &#x3D; 0} &#x3D; {}){<br>  return [x,y];<br> }</p>
<p> &#x2F;&#x2F;写法二<br> function me({x,y} &#x3D; {x:0,y:0}){<br>  return [x,y];<br> }<br>写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</p>
<p>写法而函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<p> &#x2F;&#x2F;函数没有参数的情况<br> m1()   &#x2F;&#x2F;[0,0]<br> m2()   &#x2F;&#x2F;[0,0]</p>
<p> &#x2F;&#x2F;x和y都有值的情况<br> m1({x:3,y:8})   &#x2F;&#x2F;[3,8]<br> m2({x:3,y:8})  &#x2F;&#x2F;[3,8]</p>
<p> &#x2F;&#x2F;x有值，y无值的情况<br> m1({x:3})    &#x2F;&#x2F;[3,0]<br> m2({x:3})    &#x2F;&#x2F;[3,undefined]</p>
<p> &#x2F;&#x2F;x和y都无值的情况<br> m1({})   &#x2F;&#x2F;[0,0]<br> me({})   &#x2F;&#x2F;[undefined,undefined]</p>
<p> m1({z:3})  &#x2F;&#x2F;[0,0]<br> me({z:3})  &#x2F;&#x2F;[undefined,undefined]</p>
<h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数，因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<p> &#x2F;&#x2F;例一<br> function f(x &#x3D; 1,y){<br>  return [x,y];<br> }</p>
<p> f()  &#x2F;&#x2F;[1,undefined]<br> f(2) &#x2F;&#x2F;[2,undefined]<br> f(,1) &#x2F;&#x2F;报错<br> f(undefined,1)  &#x2F;&#x2F;[1,1]</p>
<p> &#x2F;&#x2F;例二<br> function f(x,y &#x3D; 5,z){<br>  return [x,y,z];<br> }<br> f()  &#x2F;&#x2F;[undefined,5,undefined]<br> f(1)  &#x2F;&#x2F;[1,5,undefined]<br> f(1,2)  &#x2F;&#x2F;报错<br> f(1,undefined,2)  &#x2F;&#x2F;[1,5,2]<br>这里有默认值的参数不是尾参数，这时，无法只省略该参数，而不是省略它后面的参数，除非显式输入undefined。</p>
<p>如果传入undefined，将触发参数等于默认值，null则没有这个效果</p>
<p> function foo(x&#x3D;5,y&#x3D;6){<br>  console.log(x,y);<br> }</p>
<p> foo(undefined,null)<br> &#x2F;&#x2F;5 null</p>
<p>x参数对用undefined,结果触发了默认值，y参数等于null，就没有触发默认值。</p>
<h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p>指定默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值以后，length属性将失真。</p>
<p> (function (a){}).length &#x2F;&#x2F;1<br> (function (a &#x3D; 5){}).length &#x2F;&#x2F;0<br> (function (a,b,c &#x3D; 5){}).length &#x2F;&#x2F;2</p>
<p>length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。</p>
<p> (function(…args) {}).length &#x2F;&#x2F;0</p>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</p>
<p> (function (a &#x3D; 0,b,c){}).length &#x2F;&#x2F;0<br> (function (a,b &#x3D; 1,c){}).length &#x2F;&#x2F;1</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p>
<p> var x &#x3D; 1;<br> function f(x,y &#x3D; x){<br>  console.log(y);<br> }<br> f(2)  &#x2F;&#x2F;2<br>上面代码中，参数y的默认值等于x。调用时，由于函数作用域内部的变量x已经生成，所以y等于参数x，而不是全局变量x。如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。</p>
<p> let x  &#x3D; 1;</p>
<p> function f(y &#x3D; x){<br>  let x &#x3D;2;<br>  console.log(y)<br> }<br> f() &#x2F;&#x2F;1<br>函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量</p>
<p> function f(y &#x3D; x){<br>  let x &#x3D;2;<br>  console.log(y);<br> }<br> f() &#x2F;&#x2F;ReferenceError : x is not defined</p>
<p>这样写也会报错<br> var x &#x3D;1;<br> function foo(x &#x3D; x){<br>  &#x2F;&#x2F;…<br> }<br> foo() &#x2F;&#x2F;ReferenceError : x is not defined<br>函数foo的参数x的默认值也是x。这时，默认值x的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量x，但是默认值在x赋值之前就执行了，所以这时属于暂时性死区，任何对x的报错都会报错。</p>
<p> let foo &#x3D; ‘outer’;<br> function bar(func &#x3D; x &#x3D;&gt; foo){<br>  ley foo &#x3D;  “inner”;<br>  console.log(func()); &#x2F;&#x2F;outer<br> }<br> bar();<br>函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。</p>
<p> function bar(func &#x3D;() &#x3D;&gt; foo){<br>  let foo &#x3D; ‘inner’;<br>  console.log(func());<br> }</p>
<p> bar() &#x2F;&#x2F;ReferenceError: foo is not defined<br>匿名函数里面的foo指向函数外层，但是函数外层并没有声明foo，所以就报错了。</p>
<p>这有一个更复杂的例子</p>
<p> var x &#x3D; 1;<br> function foo (x,y &#x3D; function(){ x &#x3D; 2;}){<br>  var x &#x3D; 3;<br>  y();<br>  console.log(x);<br> }<br> foo() &#x2F;&#x2F;3<br>函数foo的参数y的默认值是一个匿名函数，函数foo调用时，它的参数x的值为undefined，所以y函数内部一开始是undefined，后来被重新赋值为2.但是，函数foo内部重新声明了一个x，值为3，这两个x是不一样的，互相不产生影响，因此最后输出3。</p>
<p>如果将var x &#x3D; 3的var去掉，两个x就是一样的了，最后输出就是2。</p>
<p> var x &#x3D;1 ;<br> function foo(x,y &#x3D; function(){x &#x3D;2;}){<br>  x &#x3D; 3;<br>  y();<br>  console.log(x);<br> }<br> foo() &#x2F;&#x2F;2</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<p> function throwIfMissing(){<br>  throw new Error(‘Missing parameter’);<br> }<br> function foo(mustBeProvided &#x3D; throwIfMissing()){<br>  return mustBeProvided;<br> }<br> foo();<br> &#x2F;&#x2F;Error: Missing parameter</p>
<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出错误。</p>
<h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数(形式为”…变量名”)，用于获取函数的多余参数，这样就不需要使用argument对象了。rest参数搭配的变量是数组，该变量将多余的参数放入数组中。</p>
<p> function add(…values){<br>  let sum &#x3D; 0;</p>
<p>  for(var val of values){<br>   sum +&#x3D; val;<br>  }</p>
<p>  return sum;<br> }<br> add(2,5,3) &#x2F;&#x2F;10<br>上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数</p>
<p>下面是一个rest参数替代arguments变量的例子</p>
<p> &#x2F;&#x2F;arguments变量的写法<br> function sortNumbers(){<br>  return Array.prototype.slice.call(arguments).sort();<br> }</p>
<p> &#x2F;&#x2F;rest参数的写法<br> const sortNumbers &#x3D; {…numbers} &#x3D;&gt; numbers.sort();<br>可以发现rest参数的写法更加自然也更加简洁</p>
<p>rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push的例子。</p>
<p> function push(array, …items){<br>  items.forEach(function(item){<br>   array.push(item);<br>   console.log(item);<br>  });<br> }</p>
<p> var a &#x3D; [];<br> push(a,1,2,3);<br>注意，rest参数之后不能再有其他参数(即只能是最后一个参数)，否则会报错。</p>
<p> &#x2F;&#x2F;报错<br> function f(a, …b,c){<br>  &#x2F;&#x2F;…<br> }<br>函数的length属性，不包含rest参数</p>
<p> (function(a){}).length &#x2F;&#x2F;1<br> (function(…a){}).length &#x2F;&#x2F;0<br> (function(a, …b){}).length &#x2F;&#x2F;1</p>
<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>扩展运算符(spread)是三个点(…)。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<p> console.log(…[1,2,3])<br> &#x2F;&#x2F;1 2 3</p>
<p> console.log(1,…[2,3,4],5)<br> &#x2F;&#x2F;1 2 3 4 5</p>
<p> […document.querySelectorAll(‘div’)]<br> &#x2F;&#x2F;[<div>,<div>,<div>]</p>
<p>该运算只要用于函数调用。</p>
<p> function push(array,…items){<br>  array.push(…items);<br> }</p>
<p> function add(x,y){<br>  return x+y;<br> }</p>
<p> var numbers &#x3D; [4,38];<br> add(…numbers) &#x2F;&#x2F;42<br>array.push(…items)和add(…numbers)都是函数的调用，都使用了扩展运算符将一个数组变为参数序列</p>
<p>扩展运算符，可以结合正常函数参数使用，非常灵活</p>
<h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要啊apply方法，将数组转为函数的参数了。</p>
<p> &#x2F;&#x2F;ES5的写法<br> function f(x,y,z){<br>  &#x2F;&#x2F;…<br> }<br> var args &#x3D; [0,1,2];<br> f.apply(null,args);</p>
<p> &#x2F;&#x2F;ES6的写法<br> function f(x,y,z){<br>  &#x2F;&#x2F; …<br> }</p>
<p> var args &#x3D; [0,1,2];<br> f(…args);</p>
<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。<br> &#x2F;&#x2F;ES5的写法<br> Math.max.apply(null,[14,3,77])</p>
<p> &#x2F;&#x2F;ES6的写法<br> Math.max(…[14,3,77])</p>
<p> &#x2F;&#x2F;等同于<br> Math.max(14,3,77)<br>JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值，有了扩展运算符以后，就可以只直接使用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<p>  &#x2F;&#x2F;ES5的写法<br> var arr1 &#x3D; [0,1,2];<br> var arr2 &#x3D; [3,4,5];<br> Array.prototype.push.apply(arr1,arr2);</p>
<p> &#x2F;&#x2F;ES6的写法<br> var arr1 &#x3D; [0,1,2];<br> var arr2 &#x3D; [3,4,5];<br> arr1.push(…arr2);<br>push方法的参数不能是数组，所以只好通过applay方法变通使用push。有了扩展运算符，就可以直接将数组传入push方法。</p>
<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><ol>
<li>合并数组</li>
</ol>
<p> 扩展运算符提供了数组合并的新写法。</p>
<p>  &#x2F;&#x2F;ES5<br>  [1,2].concat(more)<br>  &#x2F;&#x2F;ES6<br>  [1,2,…more]</p>
<p>  var arr1 &#x3D; [‘a’,’b’];<br>  var arr2 &#x3D; [‘c’];<br>  var arr3 &#x3D; [‘d’,’e’];</p>
<p>  &#x2F;&#x2F;ES5的合并数组<br>  arr1.concat(arr2,arr3);<br>  &#x2F;&#x2F;[‘a’,’b’,’c’,’d’,’e’]<br>2. 与解构赋值结合</p>
<p>  const[first,…rest] &#x3D; [1,2,3,4,5];<br>  &#x2F;&#x2F;first &#x2F;&#x2F;1<br>  &#x2F;&#x2F;rest  &#x2F;&#x2F;[2,3,4,5]</p>
<p>  const[first,…rest] &#x3D; [];<br>  first &#x2F;&#x2F;undefined<br>  rest &#x2F;&#x2F;[];</p>
<p>  const [first,…rest] &#x3D; [“foo”];<br>  &#x2F;&#x2F;first &#x2F;&#x2F;“foo”<br>  &#x2F;&#x2F; rest &#x2F;&#x2F;[]<br> 如果扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<p>  const […butLat,last] &#x3D; [1,2,3,4,5];<br>  &#x2F;&#x2F;报错<br>  const [first,…middle,last] &#x3D; [1,2,3,4,5];<br>  &#x2F;&#x2F;报错</p>
<ol start="3">
<li>函数的返回值</li>
</ol>
<p> JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p>
<p>  var dateFields &#x3D; readDateFields(database);<br>  var d &#x3D; new Date(…dateFields);<br> 上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date</p>
<ol start="4">
<li>字符串</li>
</ol>
<p> 扩展运算符还可以将字符串转为真正的数组。</p>
<p>  […’hello’]<br>  &#x2F;&#x2F;[“h”,”e”,”l”,”l”,”o”]<br> 这样写，有一个好处就是，能正确识别32位的Unicode字符</p>
<p>  ‘x\uD83D\uDE89y’.length &#x2F;&#x2F;4<br>  […’x\uD83D\uDE89y’].length &#x2F;&#x2F;3<br> JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题，因此，正确返回字符串长度的函数，可以这样写</p>
<p>  function length(str){<br>   return […str].length;<br>  }<br>  length(‘x\uD83D\uDE80y’) &#x2F;&#x2F;3<br> 凡是涉及操作32位Unicode字符的函数，都有这个问题，因此，最好都用扩展运算符改写。</p>
<p> let str &#x3D; ‘x\uD83D\uDE80y’;</p>
<p> str.split(‘’).reverse().join(‘’);<br> &#x2F;&#x2F;‘y\uDE80\uD83Dx’</p>
<p> […str].reverse().join(‘’)<br> &#x2F;&#x2F;‘y\uDE80\uD83Dx’<br>5. 实现Iterator接口的对象</p>
<p> 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
<p>  var nodeList &#x3D; document.querySelectorAll(‘div’);<br>  var array &#x3D; […nodeList];<br> querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口</p>
<p> 对于那些没有部署Iterator接口的类似数组对象，扩展运算符就无法将其转为真正的数组。</p>
<p>  let arrayLike &#x3D; {<br>   ‘0’:’a’,<br>   ‘1’:’b’,<br>   ‘2’:’c’,<br>   length:3<br>  };<br>  &#x2F;&#x2F;TypeError:Cannot spread non-iterable object.<br> let arr &#x3D; […arrayLike];</p>
<p> 上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错，这时，可以改为使用Array.from方法将arrayLike转为正真的数组。<br>6. Map和Set结构，Generator函数<br> 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p>
<p>  let map &#x3D; new Map([<br>   [1,’one’],<br>   [2,’two’],<br>   [3,’three’],<br>  ])<br>  let arr &#x3D; […map.keys()];&#x2F;&#x2F;[1,2,3]<br> Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<p>  var go &#x3D; function(){<br>   yield 1 ;<br>   yield 2;<br>   yield 3;<br>  };<br>  […go()]&#x2F;&#x2F;[1,2,3]<br> 变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p> 如果对没有iterator接口的对象，使用扩展运算符，将会报错。</p>
<p> var obj &#x3D; {a:1,b:2};<br> let arr &#x3D; […obj]; &#x2F;&#x2F;TypeError: Cannot spread non-iterable object</p>
<h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>函数的name属性，返回该函数的函数名。</p>
<p> function foo(){}<br> fo.name &#x2F;&#x2F;“foo”<br>这个属性早就被浏览器广泛支持，但是直到es6，才将其写入标准。</p>
<p>需要注意的是，ES6对这个属性的行为作出了一些修改。如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名。</p>
<p> var func1 &#x3D; function (){}</p>
<p> &#x2F;&#x2F;ES5<br> func1.name &#x2F;&#x2F;“”</p>
<p> &#x2F;&#x2F;ES6<br> func1.name &#x2F;&#x2F;“func1”<br>func1等于一个匿名函数，ES5和ES6的name属性返回值不一样。<br>如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。</p>
<p> const bar &#x3D; function baz(){}</p>
<p> &#x2F;&#x2F;ES5<br> bar.name &#x2F;&#x2F;“baz”</p>
<p> &#x2F;&#x2F;ES6<br> bar.name &#x2F;&#x2F;“baz”<br>Function构造函数返回的函数实例，name属性值为”anonymous”。</p>
<p> (new Function).name &#x2F;&#x2F;“anonymous”<br>binde返回的函数，name属性值会加上”bound”前缀。</p>
<p> function foo(){}<br> foo.bind({}).name &#x2F;&#x2F;“bound foo”</p>
<p> (function(){}).bind({}).name  &#x2F;&#x2F;“bound”</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6允许使用”箭头”(&#x3D;&gt;)定义函数。</p>
<p> var f &#x3D; v &#x3D;&gt; v;<br>上面的箭头函数等同于；</p>
<p> var f &#x3D; function (v){<br>  return v;<br> }</p>
<p>如果箭头函数不需要参数或需要多个参数，就是用一个圆括号代表参数部分。</p>
<p> var f &#x3D; () &#x3D;&gt; 5;<br> &#x2F;&#x2F;等同于<br> var f &#x3D; function () {return 5};</p>
<p> var sum &#x3D; (num1,num2) &#x3D;&gt; num1 + num2;<br> &#x2F;&#x2F;等同于<br> var sum &#x3D; function(num1,num2){<br>  return num1 + num2;<br> }<br>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回</p>
<p> var sum &#x3D; (num1,num2) &#x3D;&gt; {return num1 + num2;}<br>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<p> var getTempItem &#x3D; id &#x3D;&gt; ({id:id,name:”Temp”});<br>箭头函数可以与变量解构结合使用。</p>
<p> const full &#x3D; ({first,last}) &#x3D;&gt; first + ‘ ‘ +last;</p>
<p> &#x2F;&#x2F;等同于<br> function full(person){<br>  return person.first + ‘’ +person.last;<br> }<br>箭头函数使得表达更加简洁</p>
<p> const isEven &#x3D; n &#x3D;&gt; n%2 &#x3D;&#x3D; 0;<br> const square &#x3D; n &#x3D;&gt; n*n;<br>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<p> &#x2F;&#x2F;正常函数写法<br> [1,2,3].map(function (x){<br>  return x * x;<br> });<br> &#x2F;&#x2F;箭头函数写法<br> [1,2,3].map(x &#x3D;&gt; x*x);</p>
<p> &#x2F;&#x2F;正常函数写法<br> var result &#x3D; values.sort(function (a,b){<br>  return a - b;<br> });<br> &#x2F;&#x2F;箭头函数写法<br> var result &#x3D; values.sort((a,b) &#x3D;&gt; a-b);<br>同样，rest参数与箭头函数也可以混合使用</p>
<p> const numbers &#x3D; (…nums) &#x3D;&gt; nums;</p>
<p> numbers(1,2,3,4,5)<br> &#x2F;&#x2F;[1,2,3,4,5]</p>
<p> const headAndTail &#x3D; (head, …tail) &#x3D;&gt; [head,taill];</p>
<p> headAndTail(1,2,3,4,5)<br> &#x2F;&#x2F;[1,[2,3,4,5]]</p>
<h3 id="箭头函数使用注意点"><a href="#箭头函数使用注意点" class="headerlink" title="箭头函数使用注意点"></a>箭头函数使用注意点</h3><ol>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体中不存在，如果要用，使用Rest参数代替</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li>
</ol>
<p>第一点尤其值得注意，this对象的指向是可变的，但是在箭头函数内，它是固定的</p>
<p> function foo(){<br>  setTimeout(() &#x3D;&gt; {<br>   console.log(‘id’,this.id);<br>  },100);<br> }<br> var id &#x3D; 21;</p>
<p> foo.call({id:42});<br> &#x2F;&#x2F;id:42<br>setTimeout的参数是一个箭头函数，这个箭头函数的定义生效在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这是应该输出21.但是，箭头导致this总是指向函数定义生效时所在的对象，所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在作用域，而不是指向运行时坐在的作用域。</p>
<p> function Timer(){<br>  this.s1 &#x3D;0;<br>  this.s2 &#x3D;0;<br>  &#x2F;&#x2F;箭头函数<br>  setInterval(() &#x3D;&gt; this.s1++,1000);</p>
<p>  &#x2F;&#x2F;普通函数<br>  setInterval(function(){<br>   this.s2++;<br>  },1000);<br> }</p>
<p> var timer new Timer();</p>
<p> setTimeout(() &#x3D;&gt; console.log(‘s1:’,timer.s1),3100);<br> setTimeout(() &#x3D;&gt; console.log(‘s2:’,timer.s2),3100);<br> &#x2F;&#x2F;s1:3<br> &#x2F;&#x2F;s2:0<br>Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域(即Timer函数)，后者的this指向运行时所在的作用域(全局对象)。所以，3100毫秒之后，timer.s1被更新了三次，而timer.s2一次都没有更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p>
<p> var handler &#x3D; {<br>  id:’123456’,</p>
<p>  init:function(){<br>   document.addEventListener(‘click’,<br>   event &#x3D;&gt; this.doSomething(event.type),false);<br>  },</p>
<p>  doSomething: function(type){<br>   console.log(‘Handling’ + type + ‘for’ + this.id);<br>  }<br> };<br>init方法中使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成ES5的代码如下</p>
<p> &#x2F;&#x2F;ES6<br> function foo(){<br>  setTimeout(() &#x3D;&gt; {<br>   console.log(‘id:’,this.id);<br>  },100);<br> };</p>
<p> &#x2F;&#x2F;ES5<br> function foo(){<br>  var _this &#x3D; this;</p>
<p>  setTimeout(function (){<br>   console.log(“id:”,_this.id);<br>  },100);<br> };<br>请问下面的代码之中有几个this?</p>
<p> function foo(){<br>  return () &#x3D;&gt;{<br>   return () &#x3D;&gt; {<br>    return () &#x3D;&gt;{<br>     console.log(‘id:’,this.id);<br>    };<br>   };<br>  };<br> }<br> var f &#x3D; foo.call({id:1});</p>
<p> var t1 &#x3D; f.call({id:2})()();  &#x2F;&#x2F;id:1<br> var t2 &#x3D; f().call({id:3})(); &#x2F;&#x2F;id:1<br> var t3 &#x3D; f()().call({id:4}); &#x2F;&#x2F;id: 1<br>上面代码，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果，因为所有内层函数都是箭头函数，都没有自己的this，它们的this都是最外层foo函数的this。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p>
<p> function foo(){<br>  setTimeout(() &#x3D;&gt;{<br>   console.log(‘args:’,arguments);<br>  },100);<br> }</p>
<p> foo(2,4,6,8)<br> &#x2F;&#x2F;args:[2,4,6,8]<br>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法改变this的指向</p>
<p> (function(){<br>  return[<br>   (() &#x3D;&gt; this.x).bind({x:’inner’})()<br>  ];<br> }).call({x:’outer’});<br> &#x2F;&#x2F;[‘outer’]<br>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。<br>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this,很大程度上解决了这个困扰。</p>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</p>
<p> function ionsert(value){<br>  return {into:function (array){<br>   return {after: function (afterValue){<br>    array.splice(array.indexOf(afterValue) + 1,0,value);<br>    return array;<br>   }};<br>  }};<br> }<br> insert(2).into([1,3]).after.(1);&#x2F;&#x2F;[1,2,3]<br>上面这个函数，可以使用箭头函数改写。</p>
<p> let insert &#x3D; (value) &#x3D;&gt; ({into:(array) &#x3D;&gt; ({after:(afterValue) &#x3D;&gt;{<br>   array.splice(array.indexOf(afterValue) + 1, 0,value);<br>   return array;<br>  }})<br> });<br> insert(2).into([1,3]).after(1);&#x2F;&#x2F;[1,2,3];</p>
<p>下面是一个部署管道机制(pipeline)的例子，即前一个函数的输出是后一个函数的输入。</p>
<p> const pipeline &#x3D;(…funcs) &#x3D;&gt;<br>  varl &#x3D;&gt; funcs.reduce((a,b) &#x3D;&gt; b(a),val);<br> const plus1 &#x3D; a &#x3D;&gt; a + 1;<br> const mult2 &#x3D; a &#x3D;&gt; a * 2;<br> const addThenMult &#x3D; pipeline(plus1,mult2);</p>
<p> addThenMult(5);<br> &#x2F;&#x2F;12<br>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<p> const plus1 &#x3D; a &#x3D;&gt; a +1;<br> const mult2 &#x3D; a &#x3D;&gt; a *2;</p>
<p> mult2(plus1(5))<br> &#x2F;&#x2F;12</p>
<h2 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h2><p>箭头函数可以绑定this对象，大大减少了显示绑定this对象的写法(call、apply、bind)。但是，箭头函数并不适用于所有场合，所以ES7提出了”函数绑定”(function bind)运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<p>函数绑定运算符是并排的两个双冒号(::),双冒号左边是一个对象，右边是一个函数。该运算会自动将左边的对象，作为上下文环境(即this对象)，绑定到右边的函数上面。</p>
<p> foo::bar;<br> &#x2F;&#x2F;等同于<br> bar.bind(foo);</p>
<p> foo::bar(…arguments);<br> &#x2F;&#x2F;等同于<br> bar.apply(foo,arguments);</p>
<p> const hasOwnProperty &#x3D; Object.prototype.hasOwnProperty;<br> function hasOwn(obj,key){<br>  return obj::hasOwnProperty(key);<br> }<br>如果双冒号左边为空，右边是一个对象方法，则等于将该对象绑定在该对象上面。</p>
<p> var method &#x3D; obj :: obj.foo;<br> &#x2F;&#x2F;等同于</p>
<p> var method &#x3D; ::obj.foo;</p>
<p> let log &#x3D; :: console.log;<br> &#x2F;&#x2F;等同于<br> var log &#x3D; console.log.bind(console);<br>由于双冒号运算符返回的还是原对象，因此，可以采用链式写法。</p>
<p> &#x2F;&#x2F;例一<br> import {map,takeWhile,forEach } form “iterlib”;</p>
<p> getPlayers()</p>
<p> ::map(x &#x3D;&gt; x.character())<br> ::takeWhile(x &#x3D;&gt; x.strength &gt;100)<br> ::forEach(x &#x3D;&gt; console.log(x));</p>
<p> &#x2F;&#x2F;例二<br> let {find,html} &#x3D; jake;</p>
<p> document.querySelectorAll(“div.myClass”);<br> ::find(“p”)<br> ::html(“hahaha”);</p>
<h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><h3 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h3><p>尾调用(Tail Call) 是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某一个函数的最后一步是调用另一个函数。</p>
<p> function f(x){<br>  return g(x);<br> }<br>函数f的最后一步是调用函数g，这就叫尾调用。</p>
<p> &#x2F;&#x2F;情况一<br> function f(x){<br>  let y &#x3D; g(x);<br>  return y;<br> }<br> &#x2F;&#x2F;情况二<br> function f(x){<br>  return g(x) +1;<br> }<br> &#x2F;&#x2F;情况三<br> function f(x){<br>  g(x);<br> }<br>上面这三种情况都不是尾调用，情况一是电泳函数g之后，还有赋值操作，所以不属于尾调用。情况二属于调用后还有操作。<br>情况三同</p>
<p> function f(x){<br>  g(x);<br>  return undefined;<br> }<br>所以也不是尾调用。</p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<p> function f(x){<br>  if (x &gt; 0){<br>   return m(x)<br>  }<br>  return n(x);<br> }<br>函数m和n都属于尾调用，因为它们都是函数f的最后一步操作</p>
<h3 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”(call frame),保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个”调用栈”(call stack)。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<p> function f(){<br>  let m &#x3D;1;<br>  let n &#x3D;2;<br>  return g(m + n);<br> }<br> f();</p>
<p> &#x2F;&#x2F;等同于<br> function f(){<br>  return g(3);<br> }<br> f();</p>
<p> &#x2F;&#x2F;等同于<br> g(3);<br>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧。只保留g(3)的调用帧。</p>
<p>这就叫做”尾调用优化”(Tail call optimization)，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这既是”尾调用优化”的意义</p>
<p>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行”尾调用优化”。</p>
<p> function addOne(a){<br>  var one &#x3D;1;<br>  function inner(b){<br>   return b + one;<br>  }<br>  return inner(a);<br> }<br>上面的函数不会进行尾调用优化，因为内层函数(inner)用到了外层addOne的内部变量one。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<br>递归非常耗内存，因为需要同时保存成千上万个调用帧，很容易发生”栈溢出”错误(stack overflow)。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生”栈溢出”错误</p>
<p> functioon factorial(n){<br>  if(n &#x3D;&#x3D;&#x3D;1) return 1;<br>  return n * factorial(n - 1);<br> }<br> factorial(5) &#x2F;&#x2F;120<br>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。</p>
<p>如果改成尾递归，只保留一个调用记录，复杂度为O(1)。</p>
<p> function factorial(n,total){<br>  if (n &#x3D;&#x3D;&#x3D; 1) return total;<br>  return factorial(n -1 ,n * tatal);<br> }<br> factorial(5,1) &#x2F;&#x2F;120</p>
<p>还有一个比较著名的例子，就是计算fibonacci数列，也能充分说明尾递归优化的重要性，如果是非尾递归的fibonacci递归方法</p>
<p> function Fibonacci (n){<br>  if (n &lt;&#x3D; 1){<br>   return 1;<br>  }<br>  return Fibonacci(n -1) +Fibonacci(n -2);<br> }<br> Fibonacci(10);&#x2F;&#x2F;  89<br> &#x2F;&#x2F;Fibonacci(100)<br> &#x2F;&#x2F;Finbonacc(500)<br> &#x2F;&#x2F;堆栈溢出了<br>如果我们使用尾递归优化过的fibonacci递归算法</p>
<p> function Finbonacci2(n ,ac1 &#x3D;1,ac2 &#x3D; 1){<br>  if(n &lt;&#x3D; 1){ return ac2};</p>
<p>  return Fibonacci2(n-1,ac2,ac1 + ac2);<br> }<br> Fibonacci2(100) &#x2F;&#x2F;573147844013817200000<br> Fibonacci2(1000) &#x2F;&#x2F;7.0330367711422765e+208<br> Fibonacci2(10000) &#x2F;&#x2F;Infinity<br>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程与雅安将其写入语言规格。ES6也是如此，所有ECMAScript的实现，都必须部署”尾调用优化”。这就是说，ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数factorial需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p> function tailFactorial(n,total){<br>  if (n &#x3D;&#x3D;&#x3D; 1)<br>   return total;<br>  return tailFactorial(n-1,n *total);<br> }</p>
<p>   function factorial(n){<br>  return tailFactorial(n,1);<br> }<br> factorial(5); &#x2F;&#x2F;120<br>上面代码通过一个正常形式的阶乘函数factorial,调用尾递归函数tailFactorial，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化(currying),意思是将多参数的函数转化成单参数的形式。这里也可以使用柯里化。</p>
<p> function currying(fn,n){<br>  return function (m){<br>   return fn.call(this,m,n);<br>  }<br> }</p>
<p> function tailFactorial(n,total){<br>  if (n &#x3D;&#x3D;&#x3D; 1) return total;<br>  return tailFactorial(n-1,n*total);<br> }</p>
<p> const factorial &#x3D; currying(tailFactor,1);</p>
<p> factorial(5) &#x2F;&#x2F;120<br>上面代码通过柯里化，将尾递归函数tailFactorial变为只接受1个参数的factorial。</p>
<p>第二种方法就简单多了，就是采用ES6的函数默认值</p>
<p> function factorial(n,total &#x3D; 1){<br>  if (n &#x3D;&#x3D;&#x3D; 1)<br>   return total;<br>  return factorial(n-1,n * total);<br> }<br> factorial(5) &#x2F;&#x2F;120<br>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一个循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li>func.arguments:返回调用时函数的参数</li>
<li>func.caller：返回调用当前函数 的那个函数</li>
</ul>
<p>尾调用优化发生时，函数调用栈会改写，因此上面两个变量会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效</p>
<p> function restricted(){<br>  “use strict”;<br>  restructed.caller;&#x2F;&#x2F;报错<br>  restricted.arguments;&#x2F;&#x2F;报错<br> }<br> restricted();</p>
<h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><p>ES7有一个提案，允许函数的最后一个参数有尾逗号</p>
<p>目前，函数定义和调用时，都不允许有参数的尾逗号</p>
<p> function clownsEverywhere(param1,param2){<br>  &#x2F;&#x2F;…<br> }<br> clownsEverywhere(‘foo’,’bar’);<br>如果以后要遭函数的定义之中添加参数，就势必还要添加一个逗号，这对版本管理系统来说，就会显示，添加逗号的哪一行也发生了变动。这看上去有点冗余，因此，新提案允许定义和调用时，尾部直接有一个逗号。</p>
<p> function clownsEverywhere(param1,param2,){}</p>
<p> clownsEverywhere(‘foo’,’bar’,);</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ES6/" class="category-chain-item">ES6</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ES6/">#ES6</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ES6第八章 函数的扩展</div>
      <div>http://example.com/2017/06/13/2017-06-13-ECAMScript-eight-chart/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>朱羽飞</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年6月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/06/14/2017-06-14-ECAMScript-nine-chart/" title="ES6第九章 对象的扩展">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ES6第九章 对象的扩展</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/06/13/2017-06-13-jquery-validate/" title="Jquery.validate.js插件的使用心得">
                        <span class="hidden-mobile">Jquery.validate.js插件的使用心得</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
