<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ES6 第二十二章 读懂 ECMAScript 规格</title>
    <link href="/2022/07/07/ECMAScript-twenty-two/"/>
    <url>/2022/07/07/ECMAScript-twenty-two/</url>
    
    <content type="html"><![CDATA[<h1 id="第二十二章-读懂-ECMAScript-规格"><a href="#第二十二章-读懂-ECMAScript-规格" class="headerlink" title="第二十二章 读懂 ECMAScript 规格"></a>第二十二章 读懂 ECMAScript 规格</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。</p><p>一般来说，没有必要阅读规格，除非你要写编译器。因为规格写得非常抽象和精炼，又缺乏实例，不容易理解，而且对于解决实际的应用问题，帮助不大。但是，如果你遇到疑难的语法问题，实在找不到答案，这时可以去查看规格文件，了解语言标准是怎么说的。规格是解决问题的“最后一招”。</p><p>这对JavaScript语言很有必要。因为它的使用场景复杂，语法规则不统一，例外很多，各种运行环境的行为不一致，导致奇怪的语法问题层出不穷，任何语法书都不可能囊括所有情况。查看规格，不失为一种解决语法问题的最可靠、最权威的终极方法。</p><p>本章介绍如何读懂ECMAScript 6的规格文件。</p><p>ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（<a href="http://www.ecma-international.org/ecma-262/6.0/%EF%BC%89%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%9C%A8%E7%BA%BF%E9%98%85%E8%AF%BB%E3%80%82">www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。</a></p><p>这个规格文件相当庞大，一共有26章，A4打印的话，足足有545页。它的特点就是规定得非常细致，每一个语法行为、每一个函数的实现都做了详尽的清晰的描述。基本上，编译器作者只要把每一步翻译成代码就可以了。这很大程度上，保证了所有ES6实现都有一致的行为。</p><p>ECMAScript 6规格的26章之中，第1章到第3章是对文件本身的介绍，与语言关系不大。第4章是对这门语言总体设计的描述，有兴趣的读者可以读一下。第5章到第8章是语言宏观层面的描述。第5章是规格的名词解释和写法的介绍，第6章介绍数据类型，第7章介绍语言内部用到的抽象操作，第8章介绍代码如何运行。第9章到第26章介绍具体的语法。</p><p>对于一般用户来说，除了第4章，其他章节都涉及某一方面的细节，不用通读，只要在用到的时候，查阅相关章节即可。下面通过一些例子，介绍如何使用这份规格。</p><h2 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h2><p>相等运算符（&#x3D;&#x3D;）是一个很让人头痛的运算符，它的语法行为多变，不符合直觉。这个小节就看看规格怎么规定它的行为。</p><p>请看下面这个表达式，请问它的值是多少。</p><p> 0 &#x3D;&#x3D; null</p><p>如果你不确定答案，或者想知道语言内部怎么处理，就可以去查看规格，7.2.12小节是对相等运算符（&#x3D;&#x3D;）的描述。</p><p>规格对每一种语法行为的描述，都分成两部分：先是总体的行为描述，然后是实现的算法细节。相等运算符的总体描述，只有一句话。</p><p>“The comparison x &#x3D;&#x3D; y, where x and y are values, produces true or false.”</p><p>上面这句话的意思是，相等运算符用于比较两个值，返回true或false。</p><p>下面是算法细节。</p><ol><li>ReturnIfAbrupt(x).</li><li>ReturnIfAbrupt(y).</li><li>If Type(x) is the same as Type(y), then<br> Return the result of performing Strict Equality Comparison x &#x3D;&#x3D;&#x3D; y.</li><li>If x is null and y is undefined, return true.</li><li>If x is undefined and y is null, return true.</li><li>If Type(x) is Number and Type(y) is String,<br> return the result of the comparison x &#x3D;&#x3D; ToNumber(y).</li><li>If Type(x) is String and Type(y) is Number,<br> return the result of the comparison ToNumber(x) &#x3D;&#x3D; y.</li><li>If Type(x) is Boolean, return the result of the comparison ToNumber(x) &#x3D;&#x3D; y.</li><li>If Type(y) is Boolean, return the result of the comparison x &#x3D;&#x3D; ToNumber(y).</li><li>If Type(x) is either String, Number, or Symbol and Type(y) is Object, then<br> return the result of the comparison x &#x3D;&#x3D; ToPrimitive(y).</li><li>If Type(x) is Object and Type(y) is either String, Number, or Symbol, then<br> return the result of the comparison ToPrimitive(x) &#x3D;&#x3D; y.</li><li>Return false.</li></ol><p>上面这段算法，一共有12步，翻译如下。</p><ol><li>如果x不是正常值（比如抛出一个错误），中断执行。</li><li>如果y不是正常值，中断执行。</li><li>如果Type(x)与Type(y)相同，执行严格相等运算x &#x3D;&#x3D;&#x3D; y。</li><li>如果x是null，y是undefined，返回true。</li><li>如果x是undefined，y是null，返回true。</li><li>如果Type(x)是数值，Type(y)是字符串，返回x &#x3D;&#x3D; ToNumber(y)的结果。</li><li>如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) &#x3D;&#x3D; y的结果。</li><li>如果Type(x)是布尔值，返回ToNumber(x) &#x3D;&#x3D; y的结果。</li><li>如果Type(y)是布尔值，返回x &#x3D;&#x3D; ToNumber(y)的结果。</li><li>如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x &#x3D;&#x3D; ToPrimitive(y)的结果。</li><li>如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) &#x3D;&#x3D; y的结果。</li><li>返回false。</li><li></li></ol><p>由于0的类型是数值，null的类型是Null（这是规格4.3.13小节的规定，是内部Type运算的结果，跟typeof运算符无关）。因此上面的前11步都得不到结果，要到第12步才能得到false。</p><p> 0 &#x3D;&#x3D; null &#x2F;&#x2F; false</p><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>下面再看另一个例子。</p><p> const a1 &#x3D; [undefined, undefined, undefined];<br> const a2 &#x3D; [, , ,];<br> a1.length &#x2F;&#x2F; 3<br> a2.length &#x2F;&#x2F; 3<br> a1[0] &#x2F;&#x2F; undefined<br> a2[0] &#x2F;&#x2F; undefined<br> a1[0] &#x3D;&#x3D;&#x3D; a2[0] &#x2F;&#x2F; true</p><p>上面代码中，数组a1的成员是三个undefined，数组a2的成员是三个空位。这两个数组很相似，长度都是3，每个位置的成员读取出来都是undefined。</p><p>但是，它们实际上存在重大差异。</p><p> 0 in a1 &#x2F;&#x2F; true<br> 0 in a2 &#x2F;&#x2F; false<br> a1.hasOwnProperty(0) &#x2F;&#x2F; true<br> a2.hasOwnProperty(0) &#x2F;&#x2F; false<br> Object.keys(a1) &#x2F;&#x2F; [“0”, “1”, “2”]<br> Object.keys(a2) &#x2F;&#x2F; []<br> a1.map(n &#x3D;&gt; 1) &#x2F;&#x2F; [1, 1, 1]<br> a2.map(n &#x3D;&gt; 1) &#x2F;&#x2F; [, , ,]</p><p>上面代码一共列出了四种运算，数组a1和a2的结果都不一样。前三种运算（in运算符、数组的hasOwnProperty方法、Object.keys方法）都说明，数组a2取不到属性名。最后一种运算（数组的map方法）说明，数组a2没有发生遍历。</p><p>为什么a1与a2成员的行为不一致？数组的成员是undefined或空位，到底有什么不同？</p><p>规格的12.2.5小节《数组的初始化》给出了答案。</p><p>“Array elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by<br>an AssignmentExpression (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the<br>Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array,<br>that element does not contribute to the length of the Array.”</p><p>翻译如下。</p><p>“数组成员可以省略。只要逗号前面没有任何表达式，数组的length属性就会加1，并且相应增加其后成员的位置索引。被省略的成员不会被定义。如果被省略的成员是数组最后一个成员，则不会导致数组length属性增加。”</p><p>上面的规格说得很清楚，数组的空位会反映在length属性，也就是说空位有自己的位置，但是这个位置的值是未定义，即这个值是不存在的。如果一定要读取，结果就是undefined（因为undefined在JavaScript语言中表示不存在）。</p><p>这就解释了为什么in运算符、数组的hasOwnProperty方法、Object.keys方法，都取不到空位的属性名。因为这个属性名根本就不存在，规格里面没说要为空位分配属性名(位置索引），只说要为下一个元素的位置索引加1。</p><p>至于为什么数组的map方法会跳过空位，请看下一节。</p><h3 id="数组的map方法"><a href="#数组的map方法" class="headerlink" title="数组的map方法"></a>数组的map方法</h3><p>规格的22.1.3.15小节定义了数组的map方法。该小节先是总体描述map方法的行为，里面没有提到数组空位。</p><p>后面的算法描述是这样的。</p><ol><li>Let O be ToObject(this value).</li><li>ReturnIfAbrupt(O).</li><li>Let len be ToLength(Get(O, “length”)).</li><li>ReturnIfAbrupt(len).</li><li>If IsCallable(callbackfn) is false, throw a TypeError exception.</li><li>If thisArg was supplied, let T be thisArg; else let T be undefined.</li><li>Let A be ArraySpeciesCreate(O, len).</li><li>ReturnIfAbrupt(A).</li><li>Let k be 0.</li><li>Repeat, while k &lt; len<br> a. Let Pk be ToString(k).<br> b. Let kPresent be HasProperty(O, Pk).<br> c. ReturnIfAbrupt(kPresent).<br> d. If kPresent is true, then<br> d-1. Let kValue be Get(O, Pk).<br> d-2. ReturnIfAbrupt(kValue).<br> d-3. Let mappedValue be Call(callbackfn, T, «kValue, k, O»).<br> d-4. ReturnIfAbrupt(mappedValue).<br> d-5. Let status be CreateDataPropertyOrThrow (A, Pk, mappedValue).<br> d-6. ReturnIfAbrupt(status).<br> e. Increase k by 1.</li><li>Return A.</li></ol><p>翻译如下。</p><ol><li>得到当前数组的this对象</li><li>如果报错就返回</li><li>求出当前数组的length属性</li><li>如果报错就返回</li><li>如果map方法的参数callbackfn不可执行，就报错</li><li>如果map方法的参数之中，指定了this，就让T等于该参数，否则T为undefined</li><li>生成一个新的数组A，跟当前数组的length属性保持一致</li><li>如果报错就返回</li><li>设定k等于0</li><li>只要k小于当前数组的length属性，就重复下面步骤<br> a. 设定Pk等于ToString(k)，即将K转为字符串<br> b. 设定kPresent等于HasProperty(O, Pk)，即求当前数组有没有指定属性<br> c. 如果报错就返回<br> d. 如果kPresent等于true，则进行下面步骤<br> d-1. 设定kValue等于Get(O, Pk)，取出当前数组的指定属性<br> d-2. 如果报错就返回<br> d-3. 设定mappedValue等于Call(callbackfn, T, «kValue, k, O»)，即执行回调函数<br> d-4. 如果报错就返回<br> d-5. 设定status等于CreateDataPropertyOrThrow (A, Pk, mappedValue)，即将回调函数的值放入A数组的指定位置<br> d-6. 如果报错就返回<br> e. k增加1</li><li>返回A</li></ol><p>仔细查看上面的算法，可以发现，当处理一个全是空位的数组时，前面步骤都没有问题。进入第10步的b时，kpresent会报错，因为空位对应的属性名，对于数组来说是不存在的，因此就会返回，不会进行后面的步骤。</p><p> const arr &#x3D; [, , ,];<br> arr.map(n &#x3D;&gt; {<br> console.log(n);<br> return 1;<br> }) &#x2F;&#x2F; [, , ,]</p><p>上面代码中，arr是一个全是空位的数组，map方法遍历成员时，发现是空位，就直接跳过，不会进入回调函数。因此，回调函数里面的console.log语句根本不会执行，整个map方法返回一个全是空位的新数组。</p><p>V8引擎对map方法的实现如下，可以看到跟规格的算法描述完全一致。</p><p> function ArrayMap(f, receiver) {</p><p>  CHECK_OBJECT_COERCIBLE(this, “Array.prototype.map”);<br>  &#x2F;&#x2F; Pull out the length so that modifications to the length in the<br>  &#x2F;&#x2F; loop will not affect the looping and side effects are visible.<br>  var array &#x3D; TO_OBJECT(this);<br>  var length &#x3D; TO_LENGTH_OR_UINT32(array.length);<br>  return InnerArrayMap(f, receiver, array, length);<br> }<br> function InnerArrayMap(f, receiver, array, length) {</p><p>  if (!IS_CALLABLE(f)) throw MakeTypeError(kCalledNonCallable, f);</p><p>  var accumulator &#x3D; new InternalArray(length);</p><p>  var is_array &#x3D; IS_ARRAY(array);</p><p>  var stepping &#x3D; DEBUG_IS_STEPPING(f);<br>  for (var i &#x3D; 0; i &lt; length; i++) {<br>   if (HAS_INDEX(array, i, is_array)) {<br>    var element &#x3D; array[i];<br>    &#x2F;&#x2F; Prepare break slots for debugger step in.<br>    if (stepping) %DebugPrepareStepInIfStepping(f);<br>    accumulator[i] &#x3D; %_Call(f, receiver, element, i, array);<br>   }<br>  }</p><p>  var result &#x3D; new GlobalArray();<br>  %MoveArrayContents(accumulator, result);<br>  return result;<br> }</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第二十一章	编程风格</title>
    <link href="/2022/07/06/ECMAScript-twenty-one/"/>
    <url>/2022/07/06/ECMAScript-twenty-one/</url>
    
    <content type="html"><![CDATA[<h1 id="第二十一章-编程风格"><a href="#第二十一章-编程风格" class="headerlink" title="第二十一章 编程风格"></a>第二十一章 编程风格</h1><p>本章探讨如何将ES6的新语法，运用到编码实践之中，与传统的JavaScript语法结合在一起，写出合理的、易于阅读和维护的代码。</p><p>多家公司和组织已经公开了它们的风格规范，具体可参阅jscs.info，下面的内容主要参考了Airbnb的</p><p>JavaScript风格规范。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><ol><li>let取代var</li></ol><p> ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。</p><p>  ‘use strict’;<br>  if (true) {<br>   let x &#x3D; ‘hello’;<br>  }<br>  for (let i &#x3D; 0; i &lt; 10; i++) {<br>   console.log(i);<br>  }</p><p> 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。</p><p> var命令存在变量提升效用，let命令没有这个问题。</p><p>  ‘use strict’;<br>  if(true) {<br>   console.log(x); &#x2F;&#x2F; ReferenceError<br>   let x &#x3D; ‘hello’;<br>  }</p><p> 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。</p><p> 所以，建议不再使用var命令，而是使用let命令取代。</p><ol start="2"><li>全局常量和线程安全</li></ol><p> 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。</p><p>  &#x2F;&#x2F; bad<br>  var a &#x3D; 1, b &#x3D; 2, c &#x3D; 3;<br>  &#x2F;&#x2F; good<br>  const a &#x3D; 1;<br>  const b &#x3D; 2;<br>  const c &#x3D; 3;<br>  &#x2F;&#x2F; best<br>  const [a, b, c] &#x3D; [1, 2, 3];</p><p> const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。</p><p> 所有的函数都应该设置为常量。</p><p> 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p><p> &#x2F;&#x2F; bad<br> const a &#x3D; “foobar”;<br> const b &#x3D; ‘foo’ + a + ‘bar’;<br> &#x2F;&#x2F; acceptable<br> const c &#x3D; <code>foobar</code>;<br> &#x2F;&#x2F; good<br> const a &#x3D; ‘foobar’;<br> const b &#x3D; <code>foo$&#123;a&#125;bar</code>;<br> const c &#x3D; ‘foobar’;</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p><p> const arr &#x3D; [1, 2, 3, 4];<br> &#x2F;&#x2F; bad<br> const first &#x3D; arr[0];<br> const second &#x3D; arr[1];<br> &#x2F;&#x2F; good<br> const [first, second] &#x3D; arr;</p><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><p> &#x2F;&#x2F; bad<br> function getFullName(user) {<br>  const firstName &#x3D; user.firstName;<br>  const lastName &#x3D; user.lastName;<br> }<br> &#x2F;&#x2F; good<br> function getFullName(obj) {<br>  const { firstName, lastName } &#x3D; obj;<br> }<br> &#x2F;&#x2F; best<br> function getFullName({ firstName, lastName }) {<br> }</p><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><p> &#x2F;&#x2F; bad<br> function processInput(input) {<br>  return [left, right, top, bottom];<br> }<br> &#x2F;&#x2F; good<br> function processInput(input) {<br>  return { left, right, top, bottom };<br> }<br> const { left, right } &#x3D; processInput(input);</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p><p> &#x2F;&#x2F; bad<br> const a &#x3D; { k1: v1, k2: v2, };<br> const b &#x3D; {<br>  k1: v1,<br>  k2: v2<br> };<br> &#x2F;&#x2F; good<br> const a &#x3D; { k1: v1, k2: v2 };<br> const b &#x3D; {<br>  k1: v1,<br>  k2: v2,<br> };<br>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。</p><p> &#x2F;&#x2F; bad<br> const a &#x3D; {};<br> a.x &#x3D; 3;<br> &#x2F;&#x2F; if reshape unavoidable<br> const a &#x3D; {};<br> Object.assign(a, { x: 3 });<br> &#x2F;&#x2F; good<br> const a &#x3D; { x: null };<br> a.x &#x3D; 3;</p><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p><p> &#x2F;&#x2F; bad<br> const obj &#x3D; {<br>  id: 5,<br>  name: ‘San Francisco’,<br> };<br> obj[getKey(‘enabled’)] &#x3D; true;<br> &#x2F;&#x2F; good<br> const obj &#x3D; {<br>  id: 5,<br>  name: ‘San Francisco’,<br>  [getKey(‘enabled’)]: true,<br> };</p><p>上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。</p><p>另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。</p><p> var ref &#x3D; ‘some value’;<br> &#x2F;&#x2F; bad<br> const atom &#x3D; {<br>  ref: ref,<br>  value: 1,<br>  addValue: function (value) {<br>   return atom.value + value;<br>  },<br> };<br> &#x2F;&#x2F; good<br> const atom &#x3D; {<br>  ref,<br>  value: 1,<br>  addValue(value) {<br>   return atom.value + value;<br>  },<br> };</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>使用扩展运算符（…）拷贝数组。</p><p> &#x2F;&#x2F; bad<br> const len &#x3D; items.length;<br> const itemsCopy &#x3D; [];<br> let i;<br> for (i &#x3D; 0; i &lt; len; i++) {<br>  itemsCopy[i] &#x3D; items[i];<br> }<br> &#x2F;&#x2F; good<br> const itemsCopy &#x3D; […items];</p><p>使用Array.from方法，将类似数组的对象转为数组。<br> const foo &#x3D; document.querySelectorAll(‘.foo’);<br> const nodes &#x3D; Array.from(foo);</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>立即执行函数可以写成箭头函数的形式。</p><p> (() &#x3D;&gt; {<br>  console.log(‘Welcome to the Internet.’);<br> })();</p><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。</p><p> &#x2F;&#x2F; bad<br> [1, 2, 3].map(function (x) {<br>  return x <em>x;<br> });<br> &#x2F;&#x2F; good<br> [1, 2, 3].map((x) &#x3D;&gt; {<br>return x</em> x;<br> });<br> &#x2F;&#x2F; best<br> [1, 2, 3].map(x &#x3D;&gt; x * x);</p><p>箭头函数取代Function.prototype.bind，不应再用self&#x2F;_this&#x2F;that绑定 this。</p><p> &#x2F;&#x2F; bad<br> const self &#x3D; this;<br> const boundMethod &#x3D; function(…params) {<br>  return method.apply(self, params);<br> }<br> &#x2F;&#x2F; acceptable<br> const boundMethod &#x3D; method.bind(this);<br> &#x2F;&#x2F; best<br> const boundMethod &#x3D; (…params) &#x3D;&gt; method.apply(this, params);</p><p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。</p><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p><p> &#x2F;&#x2F; bad<br> function divide(a, b, option &#x3D; false ) {<br> }<br> &#x2F;&#x2F; good<br> function divide(a, b, { option &#x3D; false } &#x3D; {}) {<br> }</p><p>不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。</p><p> &#x2F;&#x2F; bad<br> function concatenateAll() {<br>  const args &#x3D; Array.prototype.slice.call(arguments);<br>  return args.join(‘’);<br> }<br> &#x2F;&#x2F; good<br> function concatenateAll(…args) {<br>  return args.join(‘’);<br> }</p><p>使用默认值语法设置函数参数的默认值。</p><p> &#x2F;&#x2F; bad<br> function handleThings(opts) {<br>  opts &#x3D; opts || {};<br> }<br> &#x2F;&#x2F; good<br> function handleThings(opts &#x3D; {}) {<br>  &#x2F;&#x2F; …<br> }</p><h2 id="Map结构"><a href="#Map结构" class="headerlink" title="Map结构"></a>Map结构</h2><p>注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。</p><p> let map &#x3D; new Map(arr);<br> for (let key of map.keys()) {<br>  console.log(key);<br> }<br> for (let value of map.values()) {<br>  console.log(value);<br> }<br> for (let item of map.entries()) {<br>  console.log(item[0], item[1]);<br> }</p><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。<br> &#x2F;&#x2F; bad<br> function Queue(contents &#x3D; []) {<br>  this._queue &#x3D; […contents];<br> }<br> Queue.prototype.pop &#x3D; function() {<br>  const value &#x3D; this._queue[0];<br>  this._queue.splice(0, 1);<br>  return value;<br> }<br> &#x2F;&#x2F; good<br> class Queue {<br>  constructor(contents &#x3D; []) {<br>   this._queue &#x3D; […contents];<br>  }<br>  pop() {<br>   const value &#x3D; this._queue[0];<br>   this._queue.splice(0, 1);<br>   return value;<br>  }<br> }</p><p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p><p> &#x2F;&#x2F; bad<br> const inherits &#x3D; require(‘inherits’);<br> function PeekableQueue(contents) {<br>  Queue.apply(this, contents);<br> }<br> inherits(PeekableQueue, Queue);<br> PeekableQueue.prototype.peek &#x3D; function() {<br>  return this._queue[0];<br> }<br> &#x2F;&#x2F; good<br> class PeekableQueue extends Queue {<br>  peek() {<br>   return this._queue[0];<br>  }<br> }</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。</p><p> &#x2F;&#x2F; bad<br> const moduleA &#x3D; require(‘moduleA’);<br> const func1 &#x3D; moduleA.func1;<br> const func2 &#x3D; moduleA.func2;<br> &#x2F;&#x2F; good<br> import { func1, func2 } from ‘moduleA’;</p><p>使用export取代module.exports。</p><p> &#x2F;&#x2F; commonJS的写法<br> var React &#x3D; require(‘react’);<br> var Breadcrumbs &#x3D; React.createClass({<br>  render() {<br>   return <nav />;<br>  }<br> });<br> module.exports &#x3D; Breadcrumbs;<br> &#x2F;&#x2F; ES6的写法<br> import React from ‘react’;<br> const Breadcrumbs &#x3D; React.createClass({<br>  render() {<br>   return <nav />;<br>  }<br> });<br> export default Breadcrumbs</p><p>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。</p><p>不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。</p><p> &#x2F;&#x2F; bad<br> import * as myObject ‘.&#x2F;importModule’;<br> &#x2F;&#x2F; good<br> import myObject from ‘.&#x2F;importModule’;</p><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p><p> function makeStyleGuide() {<br> }<br> export default makeStyleGuide;</p><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p><p> const StyleGuide &#x3D; {<br>  es6: {<br>  }<br> };<br> export default StyleGuide;</p><h2 id="ESLint的使用"><a href="#ESLint的使用" class="headerlink" title="ESLint的使用"></a>ESLint的使用</h2><p>ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。</p><p>首先，安装ESLint。</p><p> npm i -g eslint</p><p>然后，安装Airbnb语法规则。</p><p> npm i -g eslint-config-airbnb</p><p>最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。</p><p> {<br> “extends”: “eslint-config-airbnb”<br> }</p><p>现在就可以检查，当前项目的代码是否符合预设的规则。</p><p>index.js文件的代码如下。</p><p> var unusued &#x3D; ‘I have no purpose!’;<br> function greet() {<br> var message &#x3D; ‘Hello, World!’;<br>  alert(message);<br> }<br> greet();</p><p>使用ESLint检查这个文件。</p><p> $ eslint index.js<br> index.js<br> 1:5 error unusued is defined but never used no-unused-vars<br> 4:5 error Expected indentation of 2 characters but found 4 indent<br> 5:5 error Expected indentation of 2 characters but found 4 indent<br> ✖ 3 problems (3 errors, 0 warnings)</p><p>上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第二十章	Module</title>
    <link href="/2022/07/05/ECMAScript-twenty-Module/"/>
    <url>/2022/07/05/ECMAScript-twenty-Module/</url>
    
    <content type="html"><![CDATA[<h1 id="第二十章-Module"><a href="#第二十章-Module" class="headerlink" title="第二十章 Module"></a>第二十章 Module</h1><p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。</p><p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如Ruby的require、Python的import，甚至就连CSS都有@import，但是JavaScript任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。</p><p> &#x2F;&#x2F; CommonJS模块</p><p> let { stat, exists, readFile } &#x3D; require(‘fs’);</p><p> &#x2F;&#x2F; 等同于<br> let _fs &#x3D; require(‘fs’);<br>let stat &#x3D;_fs.stat, exists &#x3D; _fs.exists, readfile &#x3D;_fs.readfile;</p><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p><p>ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。</p><p> &#x2F;&#x2F; ES6模块<br> import { stat, exists, readFile } from ‘fs’;</p><p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p><p>由于ES6模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽JavaScript的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p><p>除了静态加载带来的各种好处，ES6模块还有以下好处。</p><p>不再需要UMD模块格式了，将来服务器和浏览器都会支持ES6模块格式。目前，通过各种工具库，其实已经做到了这一点。</p><p>将来浏览器的新API就能用模块格式提供，不再必要做成全局变量或者navigator对象的属性。</p><p>不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。</p><p>浏览器使用ES6模块的语法如下。</p> <script type="module" src="foo.js"></script><p>上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个ES6模块。</p><p>Node的默认模块格式是CommonJS，目前还没决定怎么支持ES6模块。所以，只能通过Babel这样的转码器，在Node里面使用ES6模块。</p><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p><ol><li>严格模式主要有以下限制。</li><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li><li></li></ol><p>上面这些限制，模块都必须遵守。由于严格模式是ES5引入的，不属于ES6，所以请参阅相关ES5书籍，本书不再详细介绍了。</p><h2 id="export命令"><a href="#export命令" class="headerlink" title="export命令"></a>export命令</h2><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个JS文件，里面使用export命令输出变量。</p><p> &#x2F;&#x2F; profile.js<br> export var firstName &#x3D; ‘Michael’;<br> export var lastName &#x3D; ‘Jackson’;<br> export var year &#x3D; 1958;</p><p>上面代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量。</p><p> export的写法，除了像上面这样，还有另外一种。<br> &#x2F;&#x2F; profile.js<br> var firstName &#x3D; ‘Michael’;<br> var lastName &#x3D; ‘Jackson’;<br> var year &#x3D; 1958;<br> export {firstName, lastName, year};</p><p>上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。<br>export命令除了输出变量，还可以输出函数或类（class）。</p><p> export function multiply(x, y) {<br>  return x * y;<br> };</p><p>上面代码对外输出一个函数multiply。<br>通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。</p><p> function v1() { … }<br> function v2() { … }<br> export {<br>  v1 as streamV1,<br>  v2 as streamV2,<br>  v2 as streamLatestVersion<br> };</p><p>上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。</p><p>需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><p> &#x2F;&#x2F; 报错<br> export 1;<br> &#x2F;&#x2F; 报错<br> var m &#x3D; 1;<br> export m;</p><p>上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。</p><p> &#x2F;&#x2F; 写法一<br> export var m &#x3D; 1;<br> &#x2F;&#x2F; 写法二<br> var m &#x3D; 1;<br> export {m};<br> &#x2F;&#x2F; 写法三<br> var n &#x3D; 1;<br> export {n as m};</p><p>上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。</p><p>同样的，function和class的输出，也必须遵守这样的写法。</p><p> &#x2F;&#x2F; 报错<br> function f() {}<br> export f;<br> &#x2F;&#x2F; 正确<br> export function f() {};<br> &#x2F;&#x2F; 正确<br> function f() {}<br> export {f};</p><p>另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p><p> export var foo &#x3D; ‘bar’;<br> setTimeout(() &#x3D;&gt; foo &#x3D; ‘baz’, 500);</p><p>上面代码输出变量foo，值为bar，500毫秒之后变成baz。</p><p>这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。</p><p>最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。</p><p> function foo() {<br>  export default ‘bar’ &#x2F;&#x2F; SyntaxError<br> }<br> foo()</p><p>上面代码中，export语句放在函数之中，结果报错。</p><h2 id="import命令"><a href="#import命令" class="headerlink" title="import命令"></a>import命令</h2><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p><p> &#x2F;&#x2F; main.js<br> import {firstName, lastName, year} from ‘.&#x2F;profile’;<br> function setName(element) {<br>  element.textContent &#x3D; firstName + ‘ ‘ + lastName;<br> }</p><p>上面代码的import命令，就用于加载profile.js文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p><p>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p><p> import { lastName as surname } from ‘.&#x2F;profile’;</p><p>注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。</p><p> foo();<br> import { foo } from ‘my_module’;</p><p>上面的代码不会报错，因为import的执行早于foo的调用。<br>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p><p> export { es6 as default } from ‘.&#x2F;someModule’;<br> &#x2F;&#x2F; 等同于<br> import { es6 } from ‘.&#x2F;someModule’;<br> export default es6;</p><p>上面代码中，export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，而应该采用标准写法。</p><p>另外，ES7有一个提案，简化先输入后输出的写法，拿掉输出时的大括号。</p><p> &#x2F;&#x2F; 提案的写法<br> export v from ‘mod’;<br> &#x2F;&#x2F; 现行的写法<br> export {v} from ‘mod’;<br> import语句会执行所加载的模块，因此可以有下面的写法。<br> import ‘lodash’;</p><p>上面代码仅仅执行lodash模块，但是不输入任何值。</p><h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p><p> 下面是一个circle.js文件，它输出两个方法area和circumference。<br> &#x2F;&#x2F; circle.js<br> export function area(radius) {<br>  return Math.PI <em>radius</em> radius;<br> }<br> export function circumference(radius) {<br>  return 2 <em>Math.PI</em> radius;<br> }<br> 现在，加载这个模块。<br> &#x2F;&#x2F; main.js<br> import { area, circumference } from ‘.&#x2F;circle’;<br> console.log(‘圆面积：’ + area(4));<br> console.log(‘圆周长：’ + circumference(14));<br> 上面写法是逐一指定要加载的方法，整体加载的写法如下。<br> import * as circle from ‘.&#x2F;circle’;<br> console.log(‘圆面积：’ + circle.area(4));<br> console.log(‘圆周长：’ + circle.circumference(14));</p><h2 id="export-default命令"><a href="#export-default命令" class="headerlink" title="export default命令"></a>export default命令</h2><p>从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p><p> &#x2F;&#x2F; export-default.js<br> export default function () {<br>  console.log(‘foo’);<br> }</p><p>上面代码是一个模块文件export-default.js，它的默认输出是一个函数。</p><p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p><p> &#x2F;&#x2F; import-default.js<br> import customName from ‘.&#x2F;export-default’;<br> customName(); &#x2F;&#x2F; ‘foo’</p><p>上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。</p><p>export default命令用在非匿名函数前，也是可以的。<br> &#x2F;&#x2F; export-default.js<br> export default function foo() {<br> console.log(‘foo’);<br> }<br> &#x2F;&#x2F; 或者写成<br> function foo() {<br> console.log(‘foo’);<br> }<br> export default foo;</p><p>上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。</p><p>下面比较一下默认输出和正常输出。<br> &#x2F;&#x2F; 输出<br> export default function crc32() {<br> &#x2F;&#x2F; …<br> }<br> &#x2F;&#x2F; 输入<br> import crc32 from ‘crc32’;<br> &#x2F;&#x2F; 输出<br> export function crc32() {<br> &#x2F;&#x2F; …<br> };<br> &#x2F;&#x2F; 输入<br> import {crc32} from ‘crc32’;</p><p>上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</p><p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export deault命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p><p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><p> &#x2F;&#x2F; modules.js<br> function add(x, y) {<br>  return x * y;<br> }<br> export {add as default};<br> &#x2F;&#x2F; 等同于<br> &#x2F;&#x2F; export default add;<br> &#x2F;&#x2F; app.js<br> import { default as xxx } from ‘modules’;<br> &#x2F;&#x2F; 等同于<br> &#x2F;&#x2F; import xxx from ‘modules’;</p><p>正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</p><p> &#x2F;&#x2F; 正确<br> export var a &#x3D; 1;<br> &#x2F;&#x2F; 正确<br> var a &#x3D; 1;<br> export default a;<br> &#x2F;&#x2F; 错误<br> export default var a &#x3D; 1;</p><p>上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。<br>有了export default命令，输入模块时就非常直观了，以输入jQuery模块为例。</p><p> import $ from ‘jquery’;</p><p>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。</p><p> import customName, { otherMethod } from ‘.&#x2F;export-default’;</p><p>如果要输出默认的值，只需将值跟在export default之后即可。</p><p> export default 42;<br> export default也可以用来输出类。<br> &#x2F;&#x2F; MyClass.js<br> export default class { … }<br> &#x2F;&#x2F; main.js<br> import MyClass from ‘MyClass’;<br> let o &#x3D; new MyClass();</p><h2 id="模块的继承"><a href="#模块的继承" class="headerlink" title="模块的继承"></a>模块的继承</h2><p>模块之间也可以继承。</p><p>假设有一个circleplus模块，继承了circle模块。</p><p> &#x2F;&#x2F; circleplus.js<br> export * from ‘circle’;<br> export var e &#x3D; 2.71828182846;<br> export default function(x) {<br>  return Math.exp(x);<br> }</p><p>上面代码中的export <em>，表示再输出circle模块的所有属性和方法。注意，export</em>命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p><p>这时，也可以将circle的属性或方法，改名后再输出。</p><p> &#x2F;&#x2F; circleplus.js<br> export { area as circleArea } from ‘circle’;</p><p>上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。<br>加载上面模块的写法如下。<br> &#x2F;&#x2F; main.js<br> import * as math from ‘circleplus’;<br> import exp from ‘circleplus’;<br> console.log(exp(math.e));<br> 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。</p><h2 id="ES6模块加载的实质"><a href="#ES6模块加载的实质" class="headerlink" title="ES6模块加载的实质"></a>ES6模块加载的实质</h2><p>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。</p><p>CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。</p><p> &#x2F;&#x2F; lib.js<br> var counter &#x3D; 3;<br> function incCounter() {<br>  counter++;<br> }<br> module.exports &#x3D; {<br>  counter: counter,<br>  incCounter: incCounter,<br> };</p><p>上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。</p><p> &#x2F;&#x2F; main.js<br> var mod &#x3D; require(‘.&#x2F;lib’);<br> console.log(mod.counter); &#x2F;&#x2F; 3<br> mod.incCounter();<br> console.log(mod.counter); &#x2F;&#x2F; 3</p><p>上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p><p> &#x2F;&#x2F; lib.js<br> var counter &#x3D; 3;<br> function incCounter() {<br>  counter++;<br> }<br> module.exports &#x3D; {<br>  get counter() {<br>   return counter<br>  },<br>  incCounter: incCounter,<br> };</p><p>上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。</p><p> $ node main.js<br> 3<br> 4</p><p>ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p><p>还是举上面的例子。<br> &#x2F;&#x2F; lib.js<br> export let counter &#x3D; 3;<br> export function incCounter() {<br>  counter++;<br> }<br> &#x2F;&#x2F; main.js<br> import { counter, incCounter } from ‘.&#x2F;lib’;<br> console.log(counter); &#x2F;&#x2F; 3<br> incCounter();<br> console.log(counter); &#x2F;&#x2F; 4</p><p>上面代码说明，ES6模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。<br>再举一个出现在export一节中的例子。</p><p> &#x2F;&#x2F; m1.js<br> export var foo &#x3D; ‘bar’;<br> setTimeout(() &#x3D;&gt; foo &#x3D; ‘baz’, 500);<br> &#x2F;&#x2F; m2.js<br> import {foo} from ‘.&#x2F;m1.js’;<br> console.log(foo);<br> setTimeout(() &#x3D;&gt; console.log(foo), 500);</p><p>上面代码中，m1.js的变量foo，在刚加载时等于bar，过了500毫秒，又变为等于baz。<br>让我们看看，m2.js能否正确读取这个变化。</p><p> $ babel-node m2.js<br> bar<br> baz</p><p>上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</p><p>由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。</p><p> &#x2F;&#x2F; lib.js<br> export let obj &#x3D; {};<br> &#x2F;&#x2F; main.js<br> import { obj } from ‘.&#x2F;lib’;<br> obj.prop &#x3D; 123; &#x2F;&#x2F; OK<br> obj &#x3D; {}; &#x2F;&#x2F; TypeError</p><p>上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。</p><p>最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。</p><p> &#x2F;&#x2F; mod.js<br> function C() {<br>  this.sum &#x3D; 0;<br>  this.add &#x3D; function () {<br>   this.sum +&#x3D; 1;<br>  };<br>  this.show &#x3D; function () {<br>   console.log(this.sum);<br>  };<br> }<br> export let c &#x3D; new C();</p><p>上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。</p><p> &#x2F;&#x2F; x.js<br> import {c} from ‘.&#x2F;mod’;<br> c.add();<br> &#x2F;&#x2F; y.js<br> import {c} from ‘.&#x2F;mod’;<br> c.show();<br> &#x2F;&#x2F; main.js<br> import ‘.&#x2F;x’;<br> import ‘.&#x2F;y’;<br>现在执行main.js，输出的是1。</p><p> $ babel-node main.js<br> 1</p><p>这就证明了x.js和y.js加载的都是C的同一个实例。</p><h2 id="循环加载"><a href="#循环加载" class="headerlink" title="循环加载"></a>循环加载</h2><p>“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。</p><p> &#x2F;&#x2F; a.js<br> var b &#x3D; require(‘b’);<br> &#x2F;&#x2F; b.js<br> var a &#x3D; require(‘a’);</p><p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p><p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p><p>对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p><h3 id="CommonJS模块的加载原理"><a href="#CommonJS模块的加载原理" class="headerlink" title="CommonJS模块的加载原理"></a>CommonJS模块的加载原理</h3><p>介绍ES6如何处理”循环加载”之前，先介绍目前最流行的CommonJS模块格式的加载原理。<br>CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p><p> {<br>  id: ‘…’,<br>  exports: { … },<br>  loaded: true,<br>  …<br> }<br>上面代码就是Node内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。<br>以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p><h3 id="CommonJS模块的循环加载"><a href="#CommonJS模块的循环加载" class="headerlink" title="CommonJS模块的循环加载"></a>CommonJS模块的循环加载</h3><p>CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p><p>让我们来看，Node官方文档里面的例子。脚本文件a.js代码如下。</p><p> exports.done &#x3D; false;<br> var b &#x3D; require(‘.&#x2F;b.js’);<br> console.log(‘在 a.js 之中，b.done &#x3D; %j’, b.done);<br> exports.done &#x3D; true;<br> console.log(‘a.js 执行完毕’);</p><p>上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。</p><p>再看b.js的代码。</p><p> exports.done &#x3D; false;<br> var a &#x3D; require(‘.&#x2F;a.js’);<br> console.log(‘在 b.js 之中，a.done &#x3D; %j’, a.done);<br> exports.done &#x3D; true;<br> console.log(‘b.js 执行完毕’);</p><p>上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</p><p>a.js已经执行的部分，只有一行。</p><p> exports.done &#x3D; false;</p><p>因此，对于b.js来说，它从a.js只输入一个变量done，值为false。</p><p>然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。</p><p> var a &#x3D; require(‘.&#x2F;a.js’);<br> var b &#x3D; require(‘.&#x2F;b.js’);<br> console.log(‘在 main.js 之中, a.done&#x3D;%j, b.done&#x3D;%j’, a.done, b.done);</p><p>执行main.js，运行结果如下。</p><p> node main.js</p><p>在 b.js 之中，a.done &#x3D; false</p><p>b.js 执行完毕</p><p>在 a.js 之中，b.done &#x3D; true</p><p>a.js 执行完毕</p><p>在 main.js 之中, a.done&#x3D;true, b.done&#x3D;true</p><p>上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。</p><p> exports.done &#x3D; true;</p><p>总之，CommonJS输入的是被输出值的拷贝，不是引用。</p><p>另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</p><p> var a &#x3D; require(‘a’); &#x2F;&#x2F; 安全的写法<br> var foo &#x3D; require(‘a’).foo; &#x2F;&#x2F; 危险的写法<br> exports.good &#x3D; function (arg) {<br>  return a.foo(‘good’, arg); &#x2F;&#x2F; 使用的是 a.foo 的最新值<br> };<br> exports.bad &#x3D; function (arg) {<br>  return foo(‘bad’, arg); &#x2F;&#x2F; 使用的是一个部分加载时的值<br> };<br>上面代码中，如果发生循环加载，require(‘a’).foo的值很可能后面会被改写，改用require(‘a’)会更保险一点。</p><h3 id="ES6模块的循环加载"><a href="#ES6模块的循环加载" class="headerlink" title="ES6模块的循环加载"></a>ES6模块的循环加载</h3><p>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用import从一个模块加载变量（即import foo from ‘foo’），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p><p>请看下面这个例子。</p><p> &#x2F;&#x2F; a.js如下<br> import {bar} from ‘.&#x2F;b.js’;<br> console.log(‘a.js’);<br> console.log(bar);<br> export let foo &#x3D; ‘foo’;<br> &#x2F;&#x2F; b.js<br> import {foo} from ‘.&#x2F;a.js’;<br> console.log(‘b.js’);<br> console.log(foo);<br> export let bar &#x3D; ‘bar’;</p><p>上面代码中，a.js加载b.js，b.js又加载a.js，构成循环加载。执行a.js，结果如下。</p><p> $ babel-node a.js<br> b.js<br> undefined<br> a.js<br> bar<br>上面代码中，由于a.js的第一行是加载b.js，所以先执行的是b.js。而b.js的第一行又是加载a.js，这时由<br>于a.js已经开始执行了，所以不会重复执行，而是继续往下执行b.js，所以第一行输出的是b.js。<br>接着，b.js要打印变量foo，这时a.js还没执行完，取不到foo的值，导致打印出来是undefined。b.js执行完，开始执行a.js，这时就一切正常了。</p><p>再看一个稍微复杂的例子（摘自 Dr. Axel Rauschmayer 的《Exploring ES6》）。</p><p> &#x2F;&#x2F; a.js<br> import {bar} from ‘.&#x2F;b.js’;<br> export function foo() {<br>  console.log(‘foo’);<br>  bar();<br>  console.log(‘执行完毕’);<br> }<br> foo();<br> &#x2F;&#x2F; b.js<br> import {foo} from ‘.&#x2F;a.js’;<br> export function bar() {<br>  console.log(‘bar’);<br>  if (Math.random() &gt; 0.5) {<br>   foo();<br>  }<br> }</p><p>按照CommonJS规范，上面的代码是没法执行的。a先加载b，然后b又加载a，这时a还没有任何执行结果，所以输出结果为null，即对于b.js来说，变量foo的值等于null，后面的foo()就会报错。</p><p>但是，ES6可以执行上面的代码。</p><p> $ babel-node a.js<br> foo<br> bar<br>执行完毕<br> &#x2F;&#x2F; 执行结果也有可能是<br> foo<br> bar<br> foo<br> bar<br> 执行完毕<br> 执行完毕<br>上面代码中，a.js之所以能够执行，原因就在于ES6加载的变量，都是动态引用其所在的模块。只要引用存在，代码就能执行。</p><p>下面，我们详细分析这段代码的运行过程。</p><p> &#x2F;&#x2F; a.js<br> &#x2F;&#x2F; 这一行建立一个引用，<br> &#x2F;&#x2F; 从<code>b.js</code>引用<code>bar</code><br> import {bar} from ‘.&#x2F;b.js’;<br> export function foo() {<br>  &#x2F;&#x2F; 执行时第一行输出 foo<br>  console.log(‘foo’);<br>  &#x2F;&#x2F; 到 b.js 执行 bar<br>  bar();<br>  console.log(‘执行完毕’);<br> }<br> foo();<br> &#x2F;&#x2F; b.js<br> &#x2F;&#x2F; 建立<code>a.js</code>的<code>foo</code>引用<br> import {foo} from ‘.&#x2F;a.js’;<br> export function bar() {<br>  &#x2F;&#x2F; 执行时，第二行输出 bar<br>  console.log(‘bar’);<br>  &#x2F;&#x2F; 递归执行 foo，一旦随机数<br>  &#x2F;&#x2F; 小于等于0.5，就停止执行<br>  if (Math.random() &gt; 0.5) {<br>   foo();<br>  }<br> }</p><p>我们再来看ES6模块加载器SystemJS给出的一个例子。</p><p> &#x2F;&#x2F; even.js<br> import { odd } from ‘.&#x2F;odd’<br> export var counter &#x3D; 0;<br> export function even(n) {<br>  counter++;<br>  return n &#x3D;&#x3D; 0 || odd(n - 1);<br> }<br> &#x2F;&#x2F; odd.js<br> import { even } from ‘.&#x2F;even’;<br> export function odd(n) {<br>  return n !&#x3D; 0 &amp;&amp; even(n - 1);<br> }</p><p>上面代码中，even.js里面的函数even有一个参数n，只要不等于0，就会减去1，传入加载的odd()。odd.js也会做类似操作。</p><p>运行上面这段代码，结果如下。</p><p> $ babel-node</p><blockquote><p>import * as m from ‘.&#x2F;even.js’;<br>m.even(10);<br> true<br>m.counter<br> 6<br>m.even(20)<br> true<br>m.counter<br> 17</p></blockquote><p>上面代码中，参数n从10变为0的过程中，even()一共会执行6次，所以变量counter等于6。第二次调用even()时，参数n从20变为0，even()一共会执行11次，加上前面的6次，所以变量counter等于17。</p><p>这个例子要是改写成CommonJS，就根本无法执行，会报错。</p><p> &#x2F;&#x2F; even.js<br> var odd &#x3D; require(‘.&#x2F;odd’);<br> var counter &#x3D; 0;<br> exports.counter &#x3D; counter;<br> exports.even &#x3D; function(n) {<br>  counter++;<br>  return n &#x3D;&#x3D; 0 || odd(n - 1);<br> }<br> &#x2F;&#x2F; odd.js<br> var even &#x3D; require(‘.&#x2F;even’).even;<br> module.exports &#x3D; function(n) {<br>  return n !&#x3D; 0 &amp;&amp; even(n - 1);<br> }</p><p>上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。</p><p> $ node</p><blockquote><p>var m &#x3D; require(‘.&#x2F;even’);<br>m.even(10)<br> TypeError: even is not a function</p></blockquote><h2 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h2><p>上面说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可以采用下面的写法。</p><p> &#x2F;&#x2F; constants.js 模块<br> export const A &#x3D; 1;<br> export const B &#x3D; 3;<br> export const C &#x3D; 4;<br> &#x2F;&#x2F; test1.js 模块<br> import * as constants from ‘.&#x2F;constants’;<br> console.log(constants.A); &#x2F;&#x2F; 1<br> console.log(constants.B); &#x2F;&#x2F; 3<br> &#x2F;&#x2F; test2.js 模块<br> import {A, B} from ‘.&#x2F;constants’;<br> console.log(A); &#x2F;&#x2F; 1<br> console.log(B); &#x2F;&#x2F; 3</p><h2 id="ES6模块的转码"><a href="#ES6模块的转码" class="headerlink" title="ES6模块的转码"></a>ES6模块的转码</h2><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。</p><h3 id="ES6-module-transpiler"><a href="#ES6-module-transpiler" class="headerlink" title="ES6 module transpiler"></a>ES6 module transpiler</h3><p>ES6 module transpiler是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。</p><p>首先，安装这个转玛器。</p><p> $ npm install -g es6-module-transpiler</p><p> 然后，使用compile-modules convert命令，将ES6模块文件转码。</p><p> $ compile-modules convert file1.js file2.js</p><p> -o参数可以指定转码后的文件名。</p><p> $ compile-modules convert -o out.js file1.js</p><h3 id="SystemJS"><a href="#SystemJS" class="headerlink" title="SystemJS"></a>SystemJS</h3><p>另一种解决方法是使用SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。</p><p>使用时，先在网页内载入system.js文件。</p> <script src="system.js"></script><p>然后，使用System.import方法加载模块文件。</p> <script> System.import('./app.js'); </script><p>上面代码中的.&#x2F;app，指的是当前目录下的app.js文件。它可以是ES6模块文件，System.import会自动将其转码。</p><p>需要注意的是，System.import使用异步加载，返回一个Promise对象，可以针对这个对象编程。下面是一个模块文件。<br> &#x2F;&#x2F; app&#x2F;es6-file.js:<br> export class q {<br>  constructor() {<br>   this.es6 &#x3D; ‘hello’;<br>  }<br> }<br>然后，在网页内加载这个模块文件。<br> <script><br> System.import('app/es6-file').then(function(m) {<br>  console.log(new m.q().es6); // hello<br> });<br> </script><br>上面代码中，System.import方法返回的是一个Promise对象，所以可以用then方法指定回调函数。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十九章 修饰器</title>
    <link href="/2022/07/04/ECMAScript-nineTeen-fix/"/>
    <url>/2022/07/04/ECMAScript-nineTeen-fix/</url>
    
    <content type="html"><![CDATA[<h1 id="第十九章-修饰器"><a href="#第十九章-修饰器" class="headerlink" title="第十九章 修饰器"></a>第十九章 修饰器</h1><h2 id="类的修饰"><a href="#类的修饰" class="headerlink" title="类的修饰"></a>类的修饰</h2><p>修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。</p><p>修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。</p><p> function testable(target) {<br>  target.isTestable &#x3D; true;<br> }<br> @testable<br> class MyTestableClass {}<br> console.log(MyTestableClass.isTestable) &#x2F;&#x2F; true</p><p>上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。</p><p>基本上，修饰器的行为就是下面这样。</p><p> @decorator<br> class A {}<br> &#x2F;&#x2F; 等同于<br> class A {}<br> A &#x3D; decorator(A) || A;<br>也就是说，修饰器本质就是编译时执行的函数。修饰器函数的第一个参数，就是所要修饰的目标类。</p><p> function testable(target) {<br>  &#x2F;&#x2F; …<br> }</p><p>上面代码中，testable函数的参数target，就是会被修饰的类。</p><p>如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。</p><p> function testable(isTestable) {<br>  return function(target) {<br>   target.isTestable &#x3D; isTestable;<br>  }<br> }<br> @testable(true)<br> class MyTestableClass {}<br> MyTestableClass.isTestable &#x2F;&#x2F; true<br> @testable(false)<br> class MyClass {}<br> MyClass.isTestable &#x2F;&#x2F; false</p><p>上面代码中，修饰器testable可以接受参数，这就等于可以修改修饰器的行为。</p><p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。</p><p> function testable(target) {<br>  target.prototype.isTestable &#x3D; true;<br> }<br> @testable<br> class MyTestableClass {}<br> let obj &#x3D; new MyTestableClass();<br> obj.isTestable &#x2F;&#x2F; true</p><p>上面代码中，修饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。<br>下面是另外一个例子。</p><p> &#x2F;&#x2F; mixins.js<br> export function mixins(…list) {<br>  return function (target) {<br>   Object.assign(target.prototype, …list)<br>  }<br> }<br> &#x2F;&#x2F; main.js<br> import { mixins } from ‘.&#x2F;mixins’<br> const Foo &#x3D; {<br>  foo() { console.log(‘foo’) }<br> };<br> @mixins(Foo)<br> class MyClass {}<br> let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; ‘foo’</p><p>上面代码通过修饰器mixins，把Foo类的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。</p><p> const Foo &#x3D; {<br>  foo() { console.log(‘foo’) }<br> };<br> class MyClass {}<br> Object.assign(MyClass.prototype, Foo);<br> let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; ‘foo’</p><h2 id="方法的修饰"><a href="#方法的修饰" class="headerlink" title="方法的修饰"></a>方法的修饰</h2><p>修饰器不仅可以修饰类，还可以修饰类的属性。</p><p> class Person {<br>  @readonly<br>  name() { return <code>$&#123;this.first&#125; $&#123;this.last&#125;</code> }<br> }</p><p>上面代码中，修饰器readonly用来修饰“类”的name方法。</p><p>此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。</p><p> function readonly(target, name, descriptor){<br> &#x2F;&#x2F; descriptor对象原来的值如下<br> &#x2F;&#x2F; {<br> &#x2F;&#x2F;   value: specifiedFunction,<br> &#x2F;&#x2F;   enumerable: false,<br> &#x2F;&#x2F;   configurable: true,<br> &#x2F;&#x2F;   writable: true<br> &#x2F;&#x2F; };<br> descriptor.writable &#x3D; false;<br>  return descriptor;<br> }<br> readonly(Person.prototype, ‘name’, descriptor);<br> &#x2F;&#x2F; 类似于<br> Object.defineProperty(Person.prototype, ‘name’, descriptor);</p><p>上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</p><p>下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。</p><p>class Person {<br>@nonenumerable<br> get kidCount() { return this.children.length; }<br>}<br>function nonenumerable(target, name, descriptor) {<br> descriptor.enumerable &#x3D; false;<br> return descriptor;<br>}</p><p>下面的@log修饰器，可以起到输出日志的作用。</p><p> class Math {<br>  @log<br>  add(a, b) {<br>   return a + b;<br>  }<br> }<br> function log(target, name, descriptor) {<br>  var oldValue &#x3D; descriptor.value;<br>  descriptor.value &#x3D; function() {<br>   console.log(<code>Calling &quot;$&#123;name&#125;&quot; with</code>, arguments);<br>   return oldValue.apply(null, arguments);<br>  };<br>  return descriptor;<br> }<br> const math &#x3D; new Math();<br> &#x2F;&#x2F; passed parameters should get logged now<br> math.add(2, 4);</p><p>上面代码中，@log修饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。</p><p>修饰器有注释的作用。</p><p> @testable<br> class Person {<br>  @readonly<br>  @nonenumerable<br>  name() { return <code>$&#123;this.first&#125; $&#123;this.last&#125;</code> }<br> }<br>从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。</p><p>如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><p> function dec(id){<br>  console.log(‘evaluated’, id);<br>  return (target, property, descriptor) &#x3D;&gt; console.log(‘executed’, id);<br> }<br> class Example {<br>  @dec(1)<br>  @dec(2)<br>  method(){}<br> }<br> &#x2F;&#x2F; evaluated 1<br> &#x2F;&#x2F; evaluated 2<br> &#x2F;&#x2F; executed 2<br> &#x2F;&#x2F; executed 1<br>上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。</p><p>除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是JavaScript代码静态分析的重要工具。</p><h2 id="为什么修饰器不能用于函数？"><a href="#为什么修饰器不能用于函数？" class="headerlink" title="为什么修饰器不能用于函数？"></a>为什么修饰器不能用于函数？</h2><p>修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。</p><p> var counter &#x3D; 0;<br> var add &#x3D; function () {<br>  counter++;<br> };<br> @add<br> function foo() {<br> }</p><p>上面的代码，意图是执行后counter等于1，但是实际上结果是counter等于0。因为函数提升，使得实际执行的代码是下面这样。</p><p> var counter;<br> var add;<br> @add<br> function foo() {<br> }<br> counter &#x3D; 0;<br> add &#x3D; function () {<br>  counter++;<br> };<br>下面是另一个例子。</p><p> var readOnly &#x3D; require(“some-decorator”);<br> @readOnly<br>  function foo() {<br> }<br>上面代码也有问题，因为实际执行是下面这样。</p><p> var readOnly;<br> @readOnly<br> function foo() {<br> }<br> readOnly &#x3D; require(“some-decorator”);</p><p>总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><h2 id="core-decorators-js"><a href="#core-decorators-js" class="headerlink" title="core-decorators.js"></a>core-decorators.js</h2><p>core-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。</p><ol><li>@autobind</li></ol><p> autobind修饰器使得方法中的this对象，绑定原始对象。</p><p>  import { autobind } from ‘core-decorators’;<br>   class Person {<br>    @autobind<br>    getPerson() {<br>     return this;<br>    }<br>   }<br>  let person &#x3D; new Person();<br>  let getPerson &#x3D; person.getPerson;<br>  getPerson() &#x3D;&#x3D;&#x3D; person;<br>  &#x2F;&#x2F; true</p><ol start="2"><li>@readonly</li></ol><p> readonly修饰器使得属性或方法不可写。</p><p>  import { readonly } from ‘core-decorators’;<br>  class Meal {<br>   @readonly<br>   entree &#x3D; ‘steak’;<br>  }<br>  var dinner &#x3D; new Meal();<br>  dinner.entree &#x3D; ‘salmon’;<br>  &#x2F;&#x2F; Cannot assign to read only property ‘entree’ of [object Object]</p><ol start="3"><li>@override</li></ol><p> override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><p>  import { override } from ‘core-decorators’;</p><p>  class Parent {<br>   speak(first, second) {}<br>  }</p><p>  class Child extends Parent {</p><p>  @override<br>  speak() {}<br>   &#x2F;&#x2F; SyntaxError: Child#speak() does not properly override Parent#speak(first, second)<br>  }</p><p>  &#x2F;&#x2F; or</p><p>  class Child extends Parent {</p><p>   @override<br>   speaks() {}<br>   &#x2F;&#x2F; SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F; Did you mean “speak”?<br>  }</p><ol start="4"><li>@deprecate (别名@deprecated)</li></ol><p> deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。</p><p>  import { deprecate } from ‘core-decorators’;</p><p>  class Person {<br>   @deprecate<br>   facepalm() {}</p><p>   @deprecate(‘We stopped facepalming’)<br>   facepalmHard() {}</p><p>   @deprecate(‘We stopped facepalming’, { url: ‘<a href="http://knowyourmeme.com/memes/facepalm">http://knowyourmeme.com/memes/facepalm</a>‘ })</p><p>   facepalmHarder() {}<br>  }</p><p>  let person &#x3D; new Person();<br>  person.facepalm();</p><p>  &#x2F;&#x2F; DEPRECATION Person#facepalm: This function will be removed in future versions.<br>  person.facepalmHard();</p><p>  &#x2F;&#x2F; DEPRECATION Person#facepalmHard: We stopped facepalming</p><p>  person.facepalmHarder();</p><p>  &#x2F;&#x2F; DEPRECATION Person#facepalmHarder: We stopped facepalming<br>  &#x2F;&#x2F;<br>  &#x2F;&#x2F; See <a href="http://knowyourmeme.com/memes/facepalm">http://knowyourmeme.com/memes/facepalm</a> for more details.<br>  &#x2F;&#x2F;<br>5. @suppressWarnings</p><p> suppressWarnings修饰器抑制decorated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。</p><p>  import { suppressWarnings } from ‘core-decorators’;</p><p>  class Person {<br>   @deprecated<br>   facepalm() {}</p><p>   @suppressWarnings<br>   facepalmWithoutWarning() {<br>     this.facepalm();<br>   }<br>  }</p><p>  let person &#x3D; new Person();<br>  person.facepalmWithoutWarning();<br>  &#x2F;&#x2F; no warning is logged</p><h2 id="我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件"><a href="#我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件" class="headerlink" title="我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件"></a>我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件</h2><p> import postal from “postal&#x2F;lib&#x2F;postal.lodash”;<br> export default function publish(topic, channel) {<br>  return function(target, name, descriptor) {<br>   const fn &#x3D; descriptor.value;<br>   descriptor.value &#x3D; function() {<br>    let value &#x3D; fn.apply(this, arguments);<br>    postal.channel(channel || target.channel || “&#x2F;“).publish(topic, value);<br>   };<br>  };<br> }</p><p>上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布&#x2F;订阅”库是Postal.js。</p><p>它的用法如下。</p><p> import publish from “path&#x2F;to&#x2F;decorators&#x2F;publish”;</p><p> class FooComponent {</p><p>  @publish(“foo.some.message”, “component”)<br>   someMethod() {</p><p>   return {<br>    my: “data”<br>   };<br>  }<br>  @publish(“foo.some.other”)<br>  anotherMethod() {<br>   &#x2F;&#x2F; …<br>   }<br> }<br>以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。</p><p> let foo &#x3D; new FooComponent();<br> foo.someMethod() &#x2F;&#x2F; 在”component”频道发布”foo.some.message”事件，附带的数据是{ my: “data” }<br> foo.anotherMethod() &#x2F;&#x2F; 在”&#x2F;“频道发布”foo.some.other”事件，不附带数据</p><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p>请看下面的例子。</p><p> const Foo &#x3D; {<br>  foo() { console.log(‘foo’) }<br> };<br> class MyClass {}<br> Object.assign(MyClass.prototype, Foo);<br>  let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; ‘foo’</p><p>上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。</p><p>下面，我们部署一个通用脚本mixins.js，将mixin写成一个修饰器。</p><p> export function mixins(…list) {<br>  return function (target) {<br>   Object.assign(target.prototype, …list);<br>  };<br> }</p><p>然后，就可以使用上面这个修饰器，为类“混入”各种方法。</p><p> import { mixins } from ‘.&#x2F;mixins’;<br> const Foo &#x3D; {<br>  foo() { console.log(‘foo’) }<br> };<br> @mixins(Foo)<br> class MyClass {}<br>  let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; “foo”</p><p>通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。</p><p>不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现mixin。</p><p> class MyClass extends MyBaseClass {<br>  &#x2F;<em>…</em>&#x2F;<br> }</p><p>上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。</p><p> let MyMixin &#x3D; (superclass) &#x3D;&gt; class extends superclass {<br>  foo() {<br>   console.log(‘foo from MyMixin’);<br>  }<br> };</p><p>上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。</p><p>接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。</p><p> class MyClass extends MyMixin(MyBaseClass) {<br>  &#x2F;<em>…</em>&#x2F;<br> }<br> let c &#x3D; new MyClass();<br> c.foo(); &#x2F;&#x2F; “foo from MyMixin”</p><p>如果需要“混入”多个方法，就生成多个混入类。</p><p> class MyClass extends Mixin1(Mixin2(MyBaseClass)) {<br>  &#x2F;<em>…</em>&#x2F;<br> }<br>这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><p> let Mixin1 &#x3D; (superclass) &#x3D;&gt; class extends superclass {<br>  foo() {<br>   console.log(‘foo from Mixin1’);<br>   if (super.foo) super.foo();<br>  }<br> };<br> let Mixin2 &#x3D; (superclass) &#x3D;&gt; class extends superclass {</p><p>  foo() {<br>   console.log(‘foo from Mixin2’);<br>   if (super.foo) super.foo();<br>  }<br> };<br> class S {</p><p>  foo() {<br>   console.log(‘foo from S’);<br>  }<br> }</p><p> class C extends Mixin1(Mixin2(S)) {</p><p>  foo() {<br>   console.log(‘foo from C’);<br>   super.foo();<br>  }<br> }</p><p>上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><p> new C().foo()<br> &#x2F;&#x2F; foo from C<br> &#x2F;&#x2F; foo from Mixin1<br> &#x2F;&#x2F; foo from Mixin2<br> &#x2F;&#x2F; foo from S</p><h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>Trait也是一种修饰器，效果与Mixin类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p>下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受ES6类作为参数。</p><p> import { traits } from ‘traits-decorator’;<br> class TFoo {<br>  foo() { console.log(‘foo’) }<br> }<br> const TBar &#x3D; {<br>  bar() { console.log(‘bar’) }<br> };<br> @traits(TFoo, TBar)<br> class MyClass { }<br> let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; foo<br> obj.bar() &#x2F;&#x2F; bar</p><p>上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。<br>Trait不允许“混入”同名方法。</p><p> import { traits } from ‘traits-decorator’;<br> class TFoo {<br>  foo() { console.log(‘foo’) }<br> }<br> const TBar &#x3D; {<br>  bar() { console.log(‘bar’) },<br>  foo() { console.log(‘foo’) }<br> };<br> @traits(TFoo, TBar)<br> class MyClass { }<br> &#x2F;&#x2F; 报错<br> &#x2F;&#x2F; throw new Error(‘Method named: ‘ + methodName + ‘ is defined twice.’);<br> &#x2F;&#x2F; ^<br> &#x2F;&#x2F; Error: Method named: foo is defined twice.</p><p>上面代码中，TFoo和TBar都有foo方法，结果traits修饰器报错。</p><p>一种解决方法是排除TBar的foo方法。</p><p> import { traits, excludes } from ‘traits-decorator’;<br> class TFoo {<br>  foo() { console.log(‘foo’) }<br> }<br> const TBar &#x3D; {<br>  bar() { console.log(‘bar’) },<br>  foo() { console.log(‘foo’) }<br> };<br> @traits(TFoo, TBar::excludes(‘foo’))<br> class MyClass { }<br> let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; foo<br> obj.bar() &#x2F;&#x2F; bar</p><p>上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。</p><p>另一种方法是为TBar的foo方法起一个别名。</p><p> import { traits, alias } from ‘traits-decorator’;<br> class TFoo {<br>  foo() { console.log(‘foo’) }<br> }<br> const TBar &#x3D; {<br>  bar() { console.log(‘bar’) },<br>  foo() { console.log(‘foo’) }<br> };<br> @traits(TFoo, TBar::alias({foo: ‘aliasFoo’}))<br> class MyClass { }<br> let obj &#x3D; new MyClass();<br> obj.foo() &#x2F;&#x2F; foo<br> obj.aliasFoo() &#x2F;&#x2F; foo<br> obj.bar() &#x2F;&#x2F; bar</p><p>上面代码为TBar的foo方法起了别名aliasFoo，于是MyClass也可以混入TBar的foo方法了。<br>alias和excludes方法，可以结合起来使用。</p><p> @traits(TExample::excludes(‘foo’,’bar’)::alias({baz:’exampleBaz’}))<br> class MyClass {}</p><p>上面代码排除了TExample的foo方法和bar方法，为baz方法起了别名exampleBaz。</p><p>as方法则为上面的代码提供了另一种写法。</p><p> @traits(TExample::as({excludes:[‘foo’, ‘bar’], alias: {baz: ‘exampleBaz’}}))<br> class MyClass {}</p><h2 id="Babel转码器的支持"><a href="#Babel转码器的支持" class="headerlink" title="Babel转码器的支持"></a>Babel转码器的支持</h2><p>目前，Babel转码器已经支持Decorator。</p><p>首先，安装babel-core和babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。</p><p>$ npm install babel-core babel-plugin-transform-decorators</p><p>然后，设置配置文件.babelrc。</p><p> {<br>  “plugins”: [“transform-decorators”]<br> }</p><p>这时，Babel就可以对Decorator转码了。</p><p>脚本中打开的命令如下。</p><p>babel.transform(“code”, {plugins: [“transform-decorators”]})</p><p>Babel的官方网站提供一个在线转码器，只要勾选Experimental，就能支持Decorator的在线转码。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十八章	Class</title>
    <link href="/2022/07/03/ECAMScript-eighteen-Class/"/>
    <url>/2022/07/03/ECAMScript-eighteen-Class/</url>
    
    <content type="html"><![CDATA[<h1 id="第十八章-Class"><a href="#第十八章-Class" class="headerlink" title="第十八章 Class"></a>第十八章 Class</h1><h2 id="Class基本语法"><a href="#Class基本语法" class="headerlink" title="Class基本语法"></a>Class基本语法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。</p><p> function Point(x, y) {<br>  this.x &#x3D; x;<br>  this.y &#x3D; y;<br> }<br> Point.prototype.toString &#x3D; function () {<br>  return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br> };<br> var p &#x3D; new Point(1, 2);</p><p>上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。</p><p> &#x2F;&#x2F;定义类<br> class Point {<br>  constructor(x, y) {<br>   this.x &#x3D; x;<br>   this.y &#x3D; y;<br>  }<br>  toString() {<br>   return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }<br> }</p><p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。</p><p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。<br>ES6的类，完全可以看作构造函数的另一种写法。</p><p> class Point {<br>  &#x2F;&#x2F; …<br> }<br> typeof Point &#x2F;&#x2F; “function”<br> Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</p><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p><p> class Bar {<br>  doStuff() {<br>   console.log(‘stuff’);<br>  }<br> }<br> var b &#x3D; new Bar();<br> b.doStuff() &#x2F;&#x2F; “stuff”</p><p>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。</p><p> class Point {<br>  constructor(){<br>   &#x2F;&#x2F; …<br>  }<br>  toString(){<br>   &#x2F;&#x2F; …<br>  }<br>  toValue(){<br>   &#x2F;&#x2F; …<br>  }<br> }<br> &#x2F;&#x2F; 等同于<br> Point.prototype &#x3D; {<br>  toString(){},<br>  toValue(){}<br> };</p><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><p> class B {}<br> let b &#x3D; new B();<br> b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor &#x2F;&#x2F; true<br>上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。</p><p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。</p><p>Object.assign方法可以很方便地一次向类添加多个方法。</p><p> class Point {<br>  constructor(){<br>   &#x2F;&#x2F; …<br>  }<br> }<br> Object.assign(Point.prototype, {<br>  toString(){},<br>  toValue(){}<br> });<br> prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。<br> Point.prototype.constructor &#x3D;&#x3D;&#x3D; Point &#x2F;&#x2F; true’’</p><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><p> class Point {<br>  constructor(x, y) {<br>   &#x2F;&#x2F; …<br>  }<br>  toString() {<br>   &#x2F;&#x2F; …<br>  }<br> }<br> Object.keys(Point.prototype)<br> &#x2F;&#x2F; []<br> Object.getOwnPropertyNames(Point.prototype)<br> &#x2F;&#x2F; [“constructor”,”toString”]</p><p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p><p> var Point &#x3D; function (x, y) {<br>  &#x2F;&#x2F; …<br> };<br> Point.prototype.toString &#x3D; function() {<br>  &#x2F;&#x2F; …<br> };<br> Object.keys(Point.prototype)<br> &#x2F;&#x2F; [“toString”]<br> Object.getOwnPropertyNames(Point.prototype)<br> &#x2F;&#x2F; [“constructor”,”toString”]</p><p>上面代码采用ES5的写法，toString方法就是可枚举的。</p><p>类的属性名，可以采用表达式。</p><p> let methodName &#x3D; “getArea”;<br> class Square{<br>  constructor(length) {<br>  &#x2F;&#x2F; …<br> }<br> <a href="">methodName</a> {<br>  &#x2F;&#x2F; …<br>  }<br> }<br>上面代码中，Square类的方法名getArea，是从表达式得到的。</p><h3 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p><p> constructor() {}<br> constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br> class Foo {<br>  constructor() {<br>   return Object.create(null);<br>  }<br> }<br> new Foo() instanceof Foo<br> &#x2F;&#x2F; false</p><p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p><p>类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</p><p> class Foo {<br>  constructor() {<br>   return Object.create(null);<br>  }<br> }<br> Foo()<br> &#x2F;&#x2F; TypeError: Class constructor Foo cannot be invoked without ‘new’</p><h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><p>生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p><p> &#x2F;&#x2F; 报错<br> var point &#x3D; Point(2, 3);<br> &#x2F;&#x2F; 正确<br> var point &#x3D; new Point(2, 3);<br> 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。<br> &#x2F;&#x2F;定义类<br> class Point {<br>  constructor(x, y) {<br>   this.x &#x3D; x;<br>   this.y &#x3D; y;<br>  }<br>  toString() {<br>   return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }<br> }<br> var point &#x3D; new Point(2, 3);<br> point.toString() &#x2F;&#x2F; (2, 3)<br> point.hasOwnProperty(‘x’) &#x2F;&#x2F; true<br> point.hasOwnProperty(‘y’) &#x2F;&#x2F; true<br> point.hasOwnProperty(‘toString’) &#x2F;&#x2F; false<br> point.<strong>proto</strong>.hasOwnProperty(‘toString’) &#x2F;&#x2F; true</p><p>上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。</p><p>与ES5一样，类的所有实例共享一个原型对象。</p><p> var p1 &#x3D; new Point(2,3);<br> var p2 &#x3D; new Point(3,2);<br> p1.<strong>proto</strong> &#x3D;&#x3D;&#x3D; p2.<strong>proto</strong><br> &#x2F;&#x2F;true<br> 上面代码中，p1和p2都是Point的实例，它们的原型都是Point，所以__proto__属性是相等的。<br> 这也意味着，可以通过实例的__proto__属性为Class添加方法。</p><p> var p1 &#x3D; new Point(2,3);<br> var p2 &#x3D; new Point(3,2);<br> p1.<strong>proto</strong>.printName &#x3D; function () { return ‘Oops’ };<br> p1.printName() &#x2F;&#x2F; “Oops”<br> p2.printName() &#x2F;&#x2F; “Oops”<br> var p3 &#x3D; new Point(4,2);<br> p3.printName() &#x2F;&#x2F; “Oops”</p><p>上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。</p><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p><p> new Foo(); &#x2F;&#x2F; ReferenceError<br> class Foo {}</p><p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p><p> {<br>  let Foo &#x3D; class {};<br>  class Bar extends Foo {<br>  }<br> }</p><p>上面的代码不会报错，因为class继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致class继承Foo的时候，Foo还没有定义。</p><h3 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p><p> const MyClass &#x3D; class Me {<br>  getClassName() {<br>   return Me.name;<br>  }<br> };<br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p><p> let inst &#x3D; new MyClass();<br> inst.getClassName() &#x2F;&#x2F; Me<br> Me.name &#x2F;&#x2F; ReferenceError: Me is not defined</p><p>上面代码表示，Me只在Class内部有定义。</p><p>如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。</p><p> const MyClass &#x3D; class { &#x2F;<em>…</em>&#x2F; };<br>采用Class表达式，可以写出立即执行的Class。<br> let person &#x3D; new class {<br>  constructor(name) {<br>   this.name &#x3D; name;<br>  }<br>  sayName() {<br>   console.log(this.name);<br>  }<br> }(‘张三’);<br> person.sayName(); &#x2F;&#x2F; “张三”</p><p>上面代码中，person是一个立即执行的类的实例。</p><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。</p><p>一种做法是在命名上加以区别。</p><p> class Widget {<br>  &#x2F;&#x2F; 公有方法<br>  foo (baz) {<br>   this._bar(baz);<br>  }<br>  &#x2F;&#x2F; 私有方法<br>  _bar(baz) {<br>   return this.snaf &#x3D; baz;<br>  }<br>  &#x2F;&#x2F; …<br> }<br>上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p><p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p><p> class Widget {<br>  foo (baz) {<br>   bar.call(this, baz);<br>  }<br>  &#x2F;&#x2F; …<br> }<br> function bar(baz) {<br>  return this.snaf &#x3D; baz;<br> }</p><p>上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。</p><p>还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。</p><p> const bar &#x3D; Symbol(‘bar’);<br> const snaf &#x3D; Symbol(‘snaf’);<br> export default class myClass{<br>  &#x2F;&#x2F; 公有方法<br>  foo(baz) {<br>   this<a href="baz">bar</a>;<br>  }<br>  &#x2F;&#x2F; 私有方法<br>  <a href="baz">bar</a> {<br>   return this[snaf] &#x3D; baz;<br>  }<br>  &#x2F;&#x2F; …<br> };</p><p>上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p><h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><p> class Logger {<br>  printName(name &#x3D; ‘there’) {<br>   this.print(<code>Hello $&#123;name&#125;</code>);<br>  }<br>  print(text) {<br>   console.log(text);<br>  }<br> }<br> const logger &#x3D; new Logger();<br> const { printName } &#x3D; logger;<br> printName(); &#x2F;&#x2F; TypeError: Cannot read property ‘print’ of undefined</p><p>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。</p><p> class Logger {<br>  constructor() {<br>   this.printName &#x3D; this.printName.bind(this);<br>  }<br>  &#x2F;&#x2F; …<br> }<br>另一种解决方法是使用箭头函数。</p><p> class Logger {<br>  constructor() {<br>   this.printName &#x3D; (name &#x3D; ‘there’) &#x3D;&gt; {<br>   this.print(<code>Hello $&#123;name&#125;</code>);<br>   };<br>  }<br>  &#x2F;&#x2F; …<br> }<br>还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。</p><p> function selfish (target) {<br>  const cache &#x3D; new WeakMap();<br>  const handler &#x3D; {<br>   get (target, key) {<br>    const value &#x3D; Reflect.get(target, key);<br>    if (typeof value !&#x3D;&#x3D; ‘function’) {<br>     return value;<br>    }<br>    if (!cache.has(value)) {<br>     cache.set(value, value.bind(target));<br>    }<br>    return cache.get(value);<br>   }<br>  };<br>  const proxy &#x3D; new Proxy(target, handler);<br>  return proxy;<br> }<br> const logger &#x3D; selfish(new Logger());</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p><p>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><p> class Point {}<br> Point.name &#x2F;&#x2F; “Point”<br> Point.name &#x2F;&#x2F; “Point”<br> name属性总是返回紧跟在class关键字后面的类名。</p><h2 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p><p>class ColorPoint extends Point {}</p><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。</p><p> class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>   super(x, y); &#x2F;&#x2F; 调用父类的constructor(x, y)<br>   this.color &#x3D; color;<br>  }<br>  toString() {<br>   return this.color + ‘ ‘ + super.toString(); &#x2F;&#x2F; 调用父类的toString()<br>  }<br> }</p><p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p><p> class Point { &#x2F;<em>…</em>&#x2F; }<br> class ColorPoint extends Point {<br>  constructor() {<br>  }<br> }<br> let cp &#x3D; new ColorPoint(); &#x2F;&#x2F; ReferenceError</p><p>上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。<br>ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p><p> constructor(…args) {<br>  super(…args);<br> }</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p><p> class Point {<br>  constructor(x, y) {<br>   this.x &#x3D; x;<br>   this.y &#x3D; y;<br>   }<br> }<br> class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>   this.color &#x3D; color; &#x2F;&#x2F; ReferenceError<br>   super(x, y);<br>   this.color &#x3D; color; &#x2F;&#x2F; 正确<br>  }<br> }</p><p>上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。</p><p>下面是生成子类实例的代码。</p><p> let cp &#x3D; new ColorPoint(25, 8, ‘green’);<br> cp instanceof ColorPoint &#x2F;&#x2F; true<br> cp instanceof Point &#x2F;&#x2F; true</p><p>上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。</p><h3 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="headerlink" title="类的prototype属性和__proto__属性"></a>类的prototype属性和__proto__属性</h3><p>大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。</p><ol><li>子类的__proto__属性，表示构造函数的继承，总是指向父类。</li><li>子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</li></ol><p> class A {<br> }<br> class B extends A {<br> }<br> B.<strong>proto</strong> &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F; true<br> B.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; A.prototype &#x2F;&#x2F; true</p><p>上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。</p><p>这样的结果是因为，类的继承是按照下面的模式实现的。</p><p> class A {<br> }<br> class B {<br> }<br> &#x2F;&#x2F; B的实例继承A的实例<br> Object.setPrototypeOf(B.prototype, A.prototype);<br> &#x2F;&#x2F; B继承A的静态属性<br> Object.setPrototypeOf(B, A);<br>《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。</p><p> Object.setPrototypeOf &#x3D; function (obj, proto) {<br>  obj.<strong>proto</strong> &#x3D; proto;<br>  return obj;<br> }<br>因此，就得到了上面的结果。</p><p> Object.setPrototypeOf(B.prototype, A.prototype);<br> &#x2F;&#x2F; 等同于<br> B.prototype.<strong>proto</strong> &#x3D; A.prototype;</p><p> Object.setPrototypeOf(B, A);<br> &#x2F;&#x2F; 等同于<br> B.<strong>proto</strong> &#x3D; A;</p><p>这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。</p><p> Object.create(A.prototype);<br> &#x2F;&#x2F; 等同于<br> B.prototype.<strong>proto</strong> &#x3D; A.prototype;</p><h3 id="Extends-的继承目标"><a href="#Extends-的继承目标" class="headerlink" title="Extends 的继承目标"></a>Extends 的继承目标</h3><p>extends关键字后面可以跟多种类型的值。</p><p> class B extends A {<br> }</p><p>上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。</p><p>下面，讨论三种特殊情况。</p><p>第一种特殊情况，子类继承Object类。<br> class A extends Object {<br> }<br> A.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true<br> A.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</p><p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p><p>第二种特殊情况，不存在任何继承。</p><p> class A {<br> }<br> A.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true<br> A.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true<br>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。</p><p>第三种特殊情况，子类继承null。</p><p> class A extends null {<br> }<br> A.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true<br> A.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; undefined &#x2F;&#x2F; true</p><p>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码。</p><p> class C extends null {<br>  constructor() { return Object.create(null); }<br> }</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p> Object.getPrototypeOf方法可以用来从子类上获取父类。<br> Object.getPrototypeOf(ColorPoint) &#x3D;&#x3D;&#x3D; Point<br> &#x2F;&#x2F; true</p><p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super这个关键字，有两种用法，含义不同。</p><ol><li><p>作为函数调用时（即super(…args)），super代表父类的构造函数。</p></li><li><p>作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</p></li></ol><p> class B extends A {<br>  get m() {<br>   return this._p * super._p;<br>  }<br>  set m() {<br>   throw new Error(‘该属性只读’);<br>  }<br> }<br>上面代码中，子类通过super关键字，调用父类实例的_p属性。</p><p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p><p> var obj &#x3D; {<br>  toString() {<br>   return “MyObject: “ + super.toString();<br>  }<br> };<br> obj.toString(); &#x2F;&#x2F; MyObject: [object Object]</p><h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的__proto__属性"></a>实例的__proto__属性</h3><p>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。</p><p> var p1 &#x3D; new Point(2, 3);<br> var p2 &#x3D; new ColorPoint(2, 3, ‘red’);<br> p2.<strong>proto</strong> &#x3D;&#x3D;&#x3D; p1.<strong>proto</strong> &#x2F;&#x2F; false<br> p2.<strong>proto</strong>.<strong>proto</strong> &#x3D;&#x3D;&#x3D; p1.<strong>proto</strong> &#x2F;&#x2F; true</p><p>上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。</p><p>因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。</p><p> p2.<strong>proto</strong>.<strong>proto</strong>.printName &#x3D; function () {<br>  console.log(‘Ha’);<br> };<br> p1.printName() &#x2F;&#x2F; “Ha”<br>上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。</p><h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="headerlink" title="原生构造函数的继承"></a>原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><p>以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。</p><p> function MyArray() {<br>  Array.apply(this, arguments);<br> }<br> MyArray.prototype &#x3D; Object.create(Array.prototype, {<br>  constructor: {<br>   value: MyArray,<br>   writable: true,<br>   configurable: true,<br>   enumerable: true<br>  }<br> });</p><p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p><p> var colors &#x3D; new MyArray();<br> colors[0] &#x3D; “red”;<br> colors.length &#x2F;&#x2F; 0<br> colors.length &#x3D; 0;<br> colors[0] &#x2F;&#x2F; “red”</p><p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p><p>ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。<br>下面的例子中，我们想让一个普通对象继承Error对象。</p><p> var e &#x3D; {};<br> Object.getOwnPropertyNames(Error.call(e))<br> &#x2F;&#x2F; [ ‘stack’ ]<br> Object.getOwnPropertyNames(e)<br> &#x2F;&#x2F; []<br>上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是 返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。</p><p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p><p> class MyArray extends Array {<br>  constructor(…args) {<br>   super(…args);<br>  }<br> }<br> var arr &#x3D; new MyArray();<br> arr[0] &#x3D; 12;<br> arr.length &#x2F;&#x2F; 1<br> arr.length &#x3D; 0;<br> arr[0] &#x2F;&#x2F; undefined</p><p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p><p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p><p> class VersionedArray extends Array {<br>  constructor() {<br>   super();<br>   this.history &#x3D; [[]];<br>  }<br>  commit() {<br>   this.history.push(this.slice());<br>  }<br>  revert() {<br>   this.splice(0, this.length, …this.history[this.history.length - 1]);<br>  }<br> }<br> var x &#x3D; new VersionedArray();<br> x.push(1);<br> x.push(2);<br> x &#x2F;&#x2F; [1, 2]<br> x.history &#x2F;&#x2F; [[]]<br> x.commit();<br> x.history &#x2F;&#x2F; [[], [1, 2]]<br> x.push(3);<br> x &#x2F;&#x2F; [1, 2, 3]<br> x.revert();<br> x &#x2F;&#x2F; [1, 2]</p><p>上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p><p>下面是一个自定义Error子类的例子。</p><p> class ExtendableError extends Error {<br> constructor(message) {<br>  super();<br>  this.message &#x3D; message;<br>  this.stack &#x3D; (new Error()).stack;<br>  this.name &#x3D; this.constructor.name;<br>  }<br> }<br> class MyError extends ExtendableError {<br>  constructor(m) {<br>   super(m);<br>  }<br> }<br> var myerror &#x3D; new MyError(‘ll’);<br> myerror.message &#x2F;&#x2F; “ll”<br> myerror instanceof Error &#x2F;&#x2F; true<br> myerror.name &#x2F;&#x2F; “MyError”<br> myerror.stack<br> &#x2F;&#x2F; Error<br> &#x2F;&#x2F; at MyError.ExtendableError<br> &#x2F;&#x2F; …<br> 注意，继承Object的子类，有一个行为差异。<br> class NewObj extends Object{<br>  constructor(){<br>   super(…arguments);<br>  }<br> }<br> var o &#x3D; new NewObj({attr: true});<br> console.log(o.attr &#x3D;&#x3D;&#x3D; true); &#x2F;&#x2F; false</p><p>上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。</p><h3 id="Class的取值函数（getter）和存值函数（setter）"><a href="#Class的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class的取值函数（getter）和存值函数（setter）"></a>Class的取值函数（getter）和存值函数（setter）</h3><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><p> class MyClass {<br>  constructor() {<br>   &#x2F;&#x2F; …<br>  }<br>  get prop() {<br>   return ‘getter’;<br>  }<br>  set prop(value) {<br>   console.log(‘setter: ‘+value);<br>  }<br> }<br> let inst &#x3D; new MyClass();<br> inst.prop &#x3D; 123;<br> &#x2F;&#x2F; setter: 123<br> inst.prop<br> &#x2F;&#x2F; ‘getter’</p><p>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。<br>存值函数和取值函数是设置在属性的descriptor对象上的。</p><p> class CustomHTMLElement {<br>  constructor(element) {<br>   this.element &#x3D; element;<br>  }<br>  get html() {<br>   return this.element.innerHTML;<br>  }<br>  set html(value) {<br>   this.element.innerHTML &#x3D; value;<br>  }<br> }<br> var descriptor &#x3D; Object.getOwnPropertyDescriptor(<br> CustomHTMLElement.prototype, “html”);<br> “get” in descriptor &#x2F;&#x2F; true<br> “set” in descriptor &#x2F;&#x2F; true</p><p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p><h2 id="Class的Generator方法"><a href="#Class的Generator方法" class="headerlink" title="Class的Generator方法"></a>Class的Generator方法</h2><p>如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。</p><p> class Foo {<br>  constructor(…args) {<br>   this.args &#x3D; args;<br>  }</p><ul><li><a href="">Symbol.iterator</a> {<br> for (let arg of this.args) {<br>  yield arg;<br> }<br>}<br> }<br> for (let x of new Foo(‘hello’, ‘world’)) {<br>console.log(x);<br> }<br> &#x2F;&#x2F; hello<br> &#x2F;&#x2F; world</li></ul><p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。</p><h2 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><p> class Foo {<br>  static classMethod() {<br>   return ‘hello’;<br>  }<br> }<br> Foo.classMethod() &#x2F;&#x2F; ‘hello’<br> var foo &#x3D; new Foo();<br> foo.classMethod()<br> &#x2F;&#x2F; TypeError: foo.classMethod is not a function</p><p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>父类的静态方法，可以被子类继承。</p><p> class Foo {<br>  static classMethod() {<br>   return ‘hello’;<br>  }<br> }<br> class Bar extends Foo {<br> }<br> Bar.classMethod(); &#x2F;&#x2F; ‘hello’</p><p>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p><p>静态方法也是可以从super对象上调用的。</p><p> class Foo {<br>  static classMethod() {<br>   return ‘hello’;<br>  }<br> }<br> class Bar extends Foo {<br>  static classMethod() {<br>   return super.classMethod() + ‘, too’;<br>  }<br> }<br> Bar.classMethod();</p><h2 id="Class的静态属性和实例属性"><a href="#Class的静态属性和实例属性" class="headerlink" title="Class的静态属性和实例属性"></a>Class的静态属性和实例属性</h2><p>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p><p> class Foo {<br> }<br> Foo.prop &#x3D; 1;<br> Foo.prop &#x2F;&#x2F; 1</p><p>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p><p> &#x2F;&#x2F; 以下两种写法都无效<br> class Foo {<br>  &#x2F;&#x2F; 写法一<br>  prop: 2<br>  &#x2F;&#x2F; 写法二<br>  static prop: 2<br> }<br> Foo.prop &#x2F;&#x2F; undefined</p><p>ES7有一个静态属性的提案，目前Babel转码器支持。</p><p>这个提案对实例属性和静态属性，都规定了新的写法。</p><ol><li>类的实例属性</li></ol><p> 类的实例属性可以用等式，写入类的定义之中。</p><p>  class MyClass {<br>   myProp &#x3D; 42;<br>   constructor() {<br>    console.log(this.myProp); &#x2F;&#x2F; 42<br>   }<br>  }</p><p> 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。</p><p> 以前，我们定义实例属性，只能写在类的constructor方法里面。</p><p> class ReactCounter extends React.Component {<br>  constructor(props) {<br>   super(props);<br>   this.state &#x3D; {<br>    count: 0<br>   };<br>  }<br> }</p><p> 上面代码中，构造方法constructor里面，定义了this.state属性。</p><p> 有了新的写法以后，可以不在constructor方法里面定义。</p><p>  class ReactCounter extends React.Component {<br>   state &#x3D; {<br>    count: 0<br>   };<br>  }</p><p> 这种写法比以前更清晰。</p><p> 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。</p><p>  class ReactCounter extends React.Component {<br>   constructor(props) {<br>    super(props);<br>    this.state &#x3D; {<br>     count: 0<br>    };<br>   }<br>   state;</p><ol start="2"><li>类的静态属性</li></ol><p> 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。</p><p>  class MyClass {<br>   static myStaticProp &#x3D; 42;<br>   constructor() {<br>    console.log(MyClass.myProp); &#x2F;&#x2F; 42<br>   }<br>  }<br> 同样的，这个新写法大大方便了静态属性的表达。<br>  &#x2F;&#x2F; 老写法<br>  class Foo {<br>  }<br>  Foo.prop &#x3D; 1;<br>  &#x2F;&#x2F; 新写法<br>  class Foo {<br>   static prop &#x3D; 1;<br>  }</p><p> 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p><h2 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h2><p>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p><p> function Person(name) {<br>  if (new.target !&#x3D;&#x3D; undefined) {<br>   this.name &#x3D; name;<br>  } else {<br>   throw new Error(‘必须使用new生成实例’);<br>  }<br> }<br> &#x2F;&#x2F; 另一种写法<br> function Person(name) {<br>  if (new.target &#x3D;&#x3D;&#x3D; Person) {<br>   this.name &#x3D; name;<br>  } else {<br>   throw new Error(‘必须使用new生成实例’);<br>  }<br> }<br> var person &#x3D; new Person(‘张三’); &#x2F;&#x2F; 正确<br> var notAPerson &#x3D; Person.call(person, ‘张三’); &#x2F;&#x2F; 报错<br> 上面代码确保构造函数只能通过new命令调用。<br> Class内部调用new.target，返回当前Class。<br> class Rectangle {<br>  constructor(length, width) {<br>   console.log(new.target &#x3D;&#x3D;&#x3D; Rectangle);<br>   this.length &#x3D; length;<br>   this.width &#x3D; width;<br>  }<br> }<br> var obj &#x3D; new Rectangle(3, 4); &#x2F;&#x2F; 输出 true<br> 需要注意的是，子类继承父类时，new.target会返回子类。<br> class Rectangle {<br>  constructor(length, width) {<br>   console.log(new.target &#x3D;&#x3D;&#x3D; Rectangle);<br>   &#x2F;&#x2F; …<br>  }<br> }<br> class Square extends Rectangle {<br>  constructor(length) {<br>   super(length, length);<br>  }<br> }<br> var obj &#x3D; new Square(3); &#x2F;&#x2F; 输出 false<br> 上面代码中，new.target会返回子类。<br> 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。<br> class Shape {<br>  constructor() {<br>   if (new.target &#x3D;&#x3D;&#x3D; Shape) {<br>    throw new Error(‘本类不能实例化’);<br>   }<br>  }<br> }<br> class Rectangle extends Shape {<br>  constructor(length, width) {<br>   super();<br>   &#x2F;&#x2F; …<br>  }<br> }<br> var x &#x3D; new Shape(); &#x2F;&#x2F; 报错<br> var y &#x3D; new Rectangle(3, 4); &#x2F;&#x2F; 正确</p><p>上面代码中，Shape类不能被实例化，只能用于继承。</p><p>注意，在函数外部，使用new.target会报错。</p><h2 id="Mixin模式的实现"><a href="#Mixin模式的实现" class="headerlink" title="Mixin模式的实现"></a>Mixin模式的实现</h2><p>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p><p> function mix(…mixins) {<br>  class Mix {}<br>  for (let mixin of mixins) {<br>   copyProperties(Mix, mixin);<br>   copyProperties(Mix.prototype, mixin.prototype);<br>  }<br>  return Mix;<br> }<br> function copyProperties(target, source) {<br>  for (let key of Reflect.ownKeys(source)) {<br>   if ( key !&#x3D;&#x3D; “constructor”&amp;&amp; key !&#x3D;&#x3D; “prototype”&amp;&amp; key !&#x3D;&#x3D; “name”) {<br>    let desc &#x3D; Object.getOwnPropertyDescriptor(source, key);<br>    Object.defineProperty(target, key, desc);<br>   }<br>  }<br> }<br>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p><p> class DistributedEdit extends mix(Loggable,Serializable) {<br>  &#x2F;&#x2F; …<br> }</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十七章 异步操作和Async函数</title>
    <link href="/2022/07/01/ECMAScript-seventeen-AsyncFunction/"/>
    <url>/2022/07/01/ECMAScript-seventeen-AsyncFunction/</url>
    
    <content type="html"><![CDATA[<h1 id="第十七章-异步操作和Async函数"><a href="#第十七章-异步操作和Async函数" class="headerlink" title="第十七章 异步操作和Async函数"></a>第十七章 异步操作和Async函数</h1><p>异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。</p><p>ES6诞生以前，异步编程的方法，大概有下面四种。</p><ol><li><p>回调函数</p></li><li><p>事件监听</p></li><li><p>发布&#x2F;订阅</p></li><li><p>Promise 对象</p></li></ol><p>ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p><p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。<br>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是”重新调用”。</p><p>读取文件进行处理，是这样写的。</p><p> fs.readFile(‘&#x2F;etc&#x2F;passwd’, function (err, data) {<br>  if (err) throw err;<br>  console.log(data);<br> });</p><p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了&#x2F;etc&#x2F;passwd这个文件以后，回调函数才会执行。</p><p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p><p> fs.readFile(fileA, function (err, data) {<br>  fs.readFile(fileB, function (err, data) {<br>   &#x2F;&#x2F; …<br>  });<br> });</p><p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调函数噩梦”（callback hell）。</p><p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。</p><p> var readFile &#x3D; require(‘fs-readfile-promise’);<br> readFile(fileA)<br> .then(function(data){<br>  console.log(data.toString());<br> })<br> .then(function(){<br>  return readFile(fileB);<br> })<br> .then(function(data){<br>  console.log(data.toString());<br> })<br> .catch(function(err) {<br>  console.log(err);<br> });</p><p>上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p><p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p><p>那么，有没有更好的写法呢？</p><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一做”协”（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><p>第一步，协程A开始执行。</p><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p><p>第三步，（一段时间后）协程B交还执行权。</p><p>第四步，协程A恢复执行。</p><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><p> function *asyncJob() {<br>  &#x2F;&#x2F; …其他代码<br> var f &#x3D; yield readFile(fileA);<br>  &#x2F;&#x2F; …其他代码<br> }</p><p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p><p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p><h3 id="Generator函数的概念"><a href="#Generator函数的概念" class="headerlink" title="Generator函数的概念"></a>Generator函数的概念</h3><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p><p> function* gen(x){<br>  var y &#x3D; yield x + 2;<br>  return y;<br> }<br> var g &#x3D; gen(1);<br> g.next() &#x2F;&#x2F; { value: 3, done: false }<br> g.next() &#x2F;&#x2F; { value: undefined, done: true }</p><p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。</p><p>这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</p><p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p><h3 id="Generator函数的数据交换和错误处理"><a href="#Generator函数的数据交换和错误处理" class="headerlink" title="Generator函数的数据交换和错误处理"></a>Generator函数的数据交换和错误处理</h3><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：</p><p>函数体内外的数据交换和错误处理机制。</p><p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p><p> function* gen(x){<br>  var y &#x3D; yield x + 2;<br>  return y;<br> }<br> var g &#x3D; gen(1);<br> g.next() &#x2F;&#x2F; { value: 3, done: false }<br> g.next(2) &#x2F;&#x2F; { value: 2, done: true }</p><p>上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p><p> function* gen(x){<br>  try {<br>   var y &#x3D; yield x + 2;<br>  } catch (e){<br>   console.log(e);<br>  }<br>  return y;<br> }<br> var g &#x3D; gen(1);<br> g.next();<br> g.throw(‘出错了’);<br> &#x2F;&#x2F; 出错了</p><p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p><h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><p> var fetch &#x3D; require(‘node-fetch’);<br> function* gen(){<br>  var url &#x3D; ‘<a href="https://api.github.com/users/github">https://api.github.com/users/github</a>‘;<br>  var result &#x3D; yield fetch(url);<br>  console.log(result.bio);<br> }</p><p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p><p>执行这段代码的方法如下。</p><p> var g &#x3D; gen();<br> var result &#x3D; g.next();<br> result.value.then(function(data){<br>  return data.json();<br> }).then(function(data){<br>  g.next(data);<br> });</p><p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h2 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h2><h3 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h3><p>Thunk函数早在上个世纪60年代就诞生了。</p><p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p><p> var x &#x3D; 1;<br> function f(m){<br>  return m * 2;<br> }<br> f(x + 5)</p><p>上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？</p><p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p><p> f(x + 5)<br> &#x2F;&#x2F; 传值调用时，等同于<br> f(6)<br>另一种意见是”传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p><p> f(x + 5)<br> &#x2F;&#x2F; 传名调用时，等同于<br> (x + 5) * 2</p><p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p><p> function f(a, b){<br>  return b;<br> }<br> f(3 <em>x</em> x - 2 * x - 1, x);</p><p>上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p><h3 id="Thunk函数的含义"><a href="#Thunk函数的含义" class="headerlink" title="Thunk函数的含义"></a>Thunk函数的含义</h3><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p><p> function f(m){<br>  return m <em>2;<br> }<br> f(x + 5);<br> &#x2F;&#x2F; 等同于<br> var thunk &#x3D; function () {<br>  return x + 5;<br> };<br> function f(thunk){<br>return thunk()</em> 2;<br> }<br>上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。<br>这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p><h3 id="JavaScript语言的Thunk函数"><a href="#JavaScript语言的Thunk函数" class="headerlink" title="JavaScript语言的Thunk函数"></a>JavaScript语言的Thunk函数</h3><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p><p> &#x2F;&#x2F; 正常版本的readFile（多参数版本）<br> fs.readFile(fileName, callback);<br> &#x2F;&#x2F; Thunk版本的readFile（单参数版本）<br> var readFileThunk &#x3D; Thunk(fileName);<br> readFileThunk(callback);<br> var Thunk &#x3D; function (fileName){<br>  return function (callback){<br>   return fs.readFile(fileName, callback);<br>  };<br> };</p><p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p><p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p><p> &#x2F;&#x2F; ES5版本<br> var Thunk &#x3D; function(fn){<br> return function (){<br>  var args &#x3D; Array.prototype.slice.call(arguments);<br>  return function (callback){<br>   args.push(callback);<br>   return fn.apply(this, args);<br>   }<br>  };<br> };<br> &#x2F;&#x2F; ES6版本<br> var Thunk &#x3D; function(fn) {<br>  return function (…args) {<br>   return function (callback) {<br>    return fn.call(this, …args, callback);<br>   }<br>  };<br> };</p><p>使用上面的转换器，生成fs.readFile的Thunk函数。</p><p> var readFileThunk &#x3D; Thunk(fs.readFile);<br> readFileThunk(fileA)(callback);</p><p>下面是另一个完整的例子。</p><p> function f(a, cb) {<br>  cb(a);<br> }<br> let ft &#x3D; Thunk(f);<br> let log &#x3D; console.log.bind(console);<br> ft(1)(log) &#x2F;&#x2F; 1</p><h3 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h3><p>生产环境的转换器，建议使用Thunkify模块。<br>首先是安装。</p><p> $ npm install thunkify<br> 使用方式如下。<br> var thunkify &#x3D; require(‘thunkify’);<br> var fs &#x3D; require(‘fs’);<br> var read &#x3D; thunkify(fs.readFile);<br> read(‘package.json’)(function(err, str){<br>  &#x2F;&#x2F; …<br> });<br> Thunkify的源码与上一节那个简单的转换器非常像。<br> function thunkify(fn){<br>  return function(){<br>  var args &#x3D; new Array(arguments.length);<br>  var ctx &#x3D; this;<br>  for(var i &#x3D; 0; i &lt; args.length; ++i) {<br>   args[i] &#x3D; arguments[i];<br>  }<br>  return function(done){<br>   var called;<br>   args.push(function(){<br>    if (called) return;<br>    called &#x3D; true;<br>    done.apply(null, arguments);<br>   });<br>   try {<br>    fn.apply(ctx, args);<br>    } catch (err) {<br>     done(err);<br>    }<br>   }<br>  }<br> };</p><p>它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p><p> function f(a, b, callback){<br>  var sum &#x3D; a + b;<br>  callback(sum);<br>  callback(sum);<br> }<br> var ft &#x3D; thunkify(f);<br> var print &#x3D; console.log.bind(console);<br> ft(1, 2)(print);<br> &#x2F;&#x2F; 3<br>上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。</p><h3 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h3><p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p><p> Generator函数可以自动执行。<br> function* gen() {<br>  &#x2F;&#x2F; …<br> }<br> var g &#x3D; gen();<br> var res &#x3D; g.next();<br> while(!res.done){<br>  console.log(res.value);<br>  res &#x3D; g.next();<br> }<br>上面代码中，Generator函数gen会自动执行完所有步骤。</p><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk函数就能派上用处。以读取文件为例。下面的Generator函数封装了两个异步操作。</p><p> var fs &#x3D; require(‘fs’);<br> var thunkify &#x3D; require(‘thunkify’);<br> var readFile &#x3D; thunkify(fs.readFile);<br> var gen &#x3D; function* (){<br>  var r1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  console.log(r1.toString());<br>  var r2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(r2.toString());<br>  };</p><p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p><p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p><p> var g &#x3D; gen();<br> var r1 &#x3D; g.next();<br> r1.value(function(err, data){<br>  if (err) throw err;<br>  var r2 &#x3D; g.next(data);<br>  r2.value(function(err, data){<br>   if (err) throw err;<br>  g.next(data);<br> });<br> });</p><p>上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p><p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p><h3 id="Thunk函数的自动流程管理"><a href="#Thunk函数的自动流程管理" class="headerlink" title="Thunk函数的自动流程管理"></a>Thunk函数的自动流程管理</h3><p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p><p> function run(fn) {<br>  var gen &#x3D; fn();<br>  function next(err, data) {<br>   var result &#x3D; gen.next(data);<br>   if (result.done) return;<br>   result.value(next);<br>  }<br>  next();<br> }<br> function* g() {<br>  &#x2F;&#x2F; …<br> }<br> run(g);</p><p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。</p><p>有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。</p><p> var g &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘fileA’);<br>  var f2 &#x3D; yield readFile(‘fileB’);<br>  &#x2F;&#x2F; …<br>  var fn &#x3D; yield readFile(‘fileN’);<br> };<br> run(g);</p><p>上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p><p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p><h2 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。<br>比如，有一个Generator函数，用于依次读取两个文件。</p><p> var gen &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };<br>co模块可以让你不用编写Generator函数的执行器。</p><p> var co &#x3D; require(‘co’);<br> co(gen);<br>上面代码中，Generator函数只要传入co函数，就会自动执行。</p><p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p><p> co(gen).then(function (){<br>  console.log(‘Generator 函数执行完成’);<br> });<br>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p><h3 id="co模块的原理"><a href="#co模块的原理" class="headerlink" title="co模块的原理"></a>co模块的原理</h3><p>为什么co可以自动执行Generator函数？</p><p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p><p>两种方法可以做到这一点。</p><ul><li><p>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p></li><li><p>Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</p></li><li></li></ul><p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p><p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p><h3 id="基于Promise对象的自动执行"><a href="#基于Promise对象的自动执行" class="headerlink" title="基于Promise对象的自动执行"></a>基于Promise对象的自动执行</h3><p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p><p> var fs &#x3D; require(‘fs’);<br> var readFile &#x3D; function (fileName){<br>  return new Promise(function (resolve, reject){<br>   fs.readFile(fileName, function(error, data){<br>    if (error) return reject(error);<br>    resolve(data);<br>   });<br>  });<br> };<br> var gen &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };<br> 然后，手动执行上面的Generator函数。<br> var g &#x3D; gen();<br> g.next().value.then(function(data){<br>  g.next(data).value.then(function(data){<br>   g.next(data);<br>  });<br> });</p><p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p><p> function run(gen){<br>  var g &#x3D; gen();<br>  function next(data){<br>   var result &#x3D; g.next(data);<br>   if (result.done)<br>    return result.value;<br>   result.value.then(function(data){<br>    next(data);<br>   });<br>  }<br> next();<br> }<br> run(gen);</p><p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p><h3 id="co模块的源码"><a href="#co模块的源码" class="headerlink" title="co模块的源码"></a>co模块的源码</h3><p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p><p>首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p><p> function co(gen) {<br>  var ctx &#x3D; this;<br>  return new Promise(function(resolve, reject) {<br>  });<br> }<br>在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p><p> function co(gen) {<br>  var ctx &#x3D; this;<br>  return new Promise(function(resolve, reject) {<br>   if (typeof gen &#x3D;&#x3D;&#x3D; ‘function’) gen &#x3D; gen.call(ctx);<br>   if (!gen || typeof gen.next !&#x3D;&#x3D; ‘function’) return resolve(gen);<br>  });<br> }</p><p>接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p><p> function co(gen) {<br>  var ctx &#x3D; this;<br>  return new Promise(function(resolve, reject) {<br>   if (typeof gen &#x3D;&#x3D;&#x3D; ‘function’) gen &#x3D; gen.call(ctx);<br>   if (!gen || typeof gen.next !&#x3D;&#x3D; ‘function’) return resolve(gen);<br>   onFulfilled();<br>   function onFulfilled(res) {<br>    var ret;<br>    try {<br>     ret &#x3D; gen.next(res);<br>    } catch (e) {<br>     return reject(e);<br>    }<br>    next(ret);<br>   }<br>  });<br> }</p><p>最后，就是关键的next函数，它会反复调用自身。</p><p> function next(ret) {<br> if (ret.done)<br>  return resolve(ret.value);<br> var value &#x3D; toPromise.call(ctx, ret.value);<br> if (value &amp;&amp; isPromise(value))<br>  return value.then(onFulfilled, onRejected);<br> return onRejected(new TypeError(‘You may only yield a function, promise, generator, array, or object, ‘+ ‘but the following object was passed: “‘ + String(ret.value) + ‘“‘));<br> }</p><p>上面代码中，next 函数的内部代码，一共只有四行命令。</p><p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p><p>第二行，确保每一步的返回值，是 Promise 对象。</p><p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p><p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p><h3 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h3><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p><p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p><p> &#x2F;&#x2F; 数组的写法<br> co(function* () {<br>  var res &#x3D; yield [<br>   Promise.resolve(1),<br>   Promise.resolve(2)<br>  ];<br> console.log(res);<br> }).catch(onerror);</p><p> &#x2F;&#x2F; 对象的写法<br> co(function*() {<br>  var res &#x3D; yield {<br>   1: Promise.resolve(1),<br>   2: Promise.resolve(2),<br> };<br> console.log(res);<br> }).catch(onerror);<br> 下面是另一个例子。<br> co(function* () {<br>  var values &#x3D; [n1, n2, n3];<br>  yield values.map(somethingAsync);<br> });<br> function* somethingAsync(x) {<br>  &#x2F;&#x2F; do something async<br>  return y<br> }<br>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。</p><p>前文有一个Generator函数，依次读取两个文件。</p><p> var fs &#x3D; require(‘fs’);<br> var readFile &#x3D; function (fileName) {<br>  return new Promise(function (resolve, reject) {<br>   fs.readFile(fileName, function(error, data) {<br>    if (error) reject(error);<br>    resolve(data);<br>   });<br>  });<br> };<br> var gen &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };<br> 写成async函数，就是下面这样。<br> var asyncReadFile &#x3D; async function (){<br>  var f1 &#x3D; await readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; await readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };</p><p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p><p>async函数对 Generator 函数的改进，体现在以下四点。</p><ol><li>内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li></ol><p>  var result &#x3D; asyncReadFile();</p><p> 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。</p><ol start="2"><li><p>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p></li><li><p>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p></li><li><p>返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。</p></li><li></li></ol><p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>async函数的语法规则总体上比较简单，难点是错误处理机制。</p><ol><li>async函数返回一个Promise对象。</li></ol><p> async函数内部return语句返回的值，会成为then方法回调函数的参数。</p><p>  async function f() {<br>   return ‘hello world’;<br>  }<br>  f().then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; “hello world”</p><p> 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。<br> async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p><p>  async function f() {<br>   throw new Error(‘出错了’);<br>  }<br>  f().then(<br>   v &#x3D;&gt; console.log(v),<br>   e &#x3D;&gt; console.log(e)<br>  )<br>  &#x2F;&#x2F; Error: 出错了</p><ol start="2"><li>async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li></ol><p> 下面是一个例子。</p><p>  async function getTitle(url) {<br>   let response &#x3D; await fetch(url);<br>   let html &#x3D; await response.text();<br>   return html.match(&#x2F;<title>([\s\S]+)&lt;/title&gt;&#x2F;i)[1];<br>  }<br>  getTitle(‘<a href="https://tc39.github.io/ecma262/&#39;).then(console.log)">https://tc39.github.io/ecma262/&#39;).then(console.log)</a><br>  &#x2F;&#x2F; “ECMAScript 2017 Language Specification”<br>3. 正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。<br>  async function f() {<br>   return await 123;<br>  }<br>  f().then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; 123</p><p> 上面代码中，await命令的参数是数值123，它被转成Promise对象，并立即resolve。</p><p> await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p><p>  async function f() {<br>   await Promise.reject(‘出错了’);<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  .catch(e &#x3D;&gt; console.log(e))<br>  &#x2F;&#x2F; 出错了</p><p> 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</p><p> 只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。</p><p>  async function f() {<br>   await Promise.reject(‘出错了’);<br>   await Promise.resolve(‘hello world’); &#x2F;&#x2F; 不会执行<br>  }<br> 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。</p><p> 为了避免这个问题，可以将第一个await放在try…catch结构里面，这样第二个await就会执行。</p><p>  async function f() {<br>   try {<br>    await Promise.reject(‘出错了’);<br>   } catch(e) {<br>   }<br>   return await Promise.resolve(‘hello world’);<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; hello world</p><p> 另一种方法是await后面的Promise对象再跟一个catch方面，处理前面可能出现的错误。</p><p>  async function f() {<br>   await Promise.reject(‘出错了’)<br>   .catch(e &#x3D;&gt; console.log(e));<br>   return await Promise.resolve(‘hello world’);<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; 出错了<br>  &#x2F;&#x2F; hello world</p><p> 如果有多个await命令，可以统一放在try…catch结构中。</p><p>  async function main() {<br>   try {<br>    var val1 &#x3D; await firstStep();<br>    var val2 &#x3D; await secondStep(val1);<br>    var val3 &#x3D; await thirdStep(val1, val2);<br>    console.log(‘Final: ‘, val3);<br>   }<br>   catch (err) {<br>    console.error(err);<br>   }<br>  }</p><ol start="4"><li>如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。</li></ol><p>  async function f() {<br>   await new Promise(function (resolve, reject) {<br>    throw new Error(‘出错了’);<br>   });<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  .catch(e &#x3D;&gt; console.log(e))<br>  &#x2F;&#x2F; Error：出错了</p><p> 上面代码中，async函数f执行后，await后面的Promise对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现”。</p><p> 防止出错的方法，也是将其放在try…catch代码块之中。</p><p>  async function f() {<br>  try {<br>   await new Promise(function (resolve, reject) {<br>    throw new Error(‘出错了’);<br>   });<br>   } catch(e) {<br>  }<br>   return await(‘hello world’);<br>  }</p><h3 id="async函数的实现"><a href="#async函数的实现" class="headerlink" title="async函数的实现"></a>async函数的实现</h3><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><p> async function fn(args){<br>  &#x2F;&#x2F; …<br> }<br> &#x2F;&#x2F; 等同于<br> function fn(args){<br>  return spawn(function*() {<br>  &#x2F;&#x2F; …<br>  });<br> }</p><p>所有的async函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p><p>下面给出spawn函数的实现，基本就是前文自动执行器的翻版。</p><p> function spawn(genF) {<br>  return new Promise(function(resolve, reject) {<br>  var gen &#x3D; genF();<br> function step(nextF) {<br>  try {<br>   var next &#x3D; nextF();<br>  } catch(e) {<br>   return reject(e);<br>  }<br> if(next.done) {<br>  return resolve(next.value);<br> }<br> Promise.resolve(next.value).then(function(v) {<br>  step(function() { return gen.next(v); });<br> }, function(e) {<br>   step(function() { return gen.throw(e); });<br>  });<br>  }<br>  step(function() { return gen.next(undefined); });<br>  });<br> }<br>async函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器Babel和regenerator都已经支持，转码后就能使用。</p><h3 id="async-函数的用法"><a href="#async-函数的用法" class="headerlink" title="async 函数的用法"></a>async 函数的用法</h3><p>async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p><p>下面是一个例子。</p><p> async function getStockPriceByName(name) {<br>  var symbol &#x3D; await getStockSymbol(name);<br>  var stockPrice &#x3D; await getStockPrice(symbol);<br>  return stockPrice;<br> }<br> getStockPriceByName(‘goog’).then(function (result) {<br>  console.log(result);<br> });</p><p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p><p>下面的例子，指定多少毫秒后输出一个值。</p><p> function timeout(ms) {<br>  return new Promise((resolve) &#x3D;&gt; {<br>   setTimeout(resolve, ms);<br>  });<br> }<br> async function asyncPrint(value, ms) {<br>  await timeout(ms);<br>  console.log(value)<br> }<br> asyncPrint(‘hello world’, 50);</p><p>上面代码指定50毫秒以后，输出”hello world”。</p><p>Async函数有多种使用形式。</p><p> &#x2F;&#x2F; 函数声明</p><p> async function foo() {}</p><p> &#x2F;&#x2F; 函数表达式<br> const foo &#x3D; async function () {};</p><p> &#x2F;&#x2F; 对象的方法<br> let obj &#x3D; { async foo() {} };</p><p> &#x2F;&#x2F; 箭头函数<br> const foo &#x3D; async () &#x3D;&gt; {};</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>第一点，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p><p> async function myFunction() {<br>  try {<br>   await somethingThatReturnsAPromise();<br>  } catch (err) {<br>   console.log(err);<br>  }<br> }</p><p> &#x2F;&#x2F; 另一种写法<br> async function myFunction() {<br>  await somethingThatReturnsAPromise()<br>  .catch(function (err) {<br>   console.log(err);<br>  };<br> }</p><p>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><p> let foo &#x3D; await getFoo();<br> let bar &#x3D; await getBar();</p><p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p><p> &#x2F;&#x2F; 写法一<br> let [foo, bar] &#x3D; await Promise.all([getFoo(), getBar()]);<br> &#x2F;&#x2F; 写法二<br> let fooPromise &#x3D; getFoo();<br> let barPromise &#x3D; getBar();<br> let foo &#x3D; await fooPromise;<br> let bar &#x3D; await barPromise;</p><p>上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</p><p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p><p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  &#x2F;&#x2F; 报错<br>  docs.forEach(function (doc) {<br>   await db.post(doc);<br>  });<br> }<br>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p><p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  &#x2F;&#x2F; 可能得到错误结果<br>  docs.forEach(async function (doc) {<br>   await db.post(doc);<br>  });<br> }<br>上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p><p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  for (let doc of docs) {<br>   await db.post(doc);<br>  }<br> }</p><p>如果确实希望多个请求并发执行，可以使用Promise.all方法。</p><p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  let promises &#x3D; docs.map((doc) &#x3D;&gt; db.post(doc));<br>  let results &#x3D; await Promise.all(promises);<br>  console.log(results);<br> }<br> &#x2F;&#x2F; 或者使用下面的写法<br> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  let promises &#x3D; docs.map((doc) &#x3D;&gt; db.post(doc));<br>  let results &#x3D; [];<br>  for (let promise of promises) {<br>   results.push(await promise);<br>  }<br>  console.log(results);<br> }</p><p>ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p><h3 id="与Promise、Generator的比较"><a href="#与Promise、Generator的比较" class="headerlink" title="与Promise、Generator的比较"></a>与Promise、Generator的比较</h3><p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p><p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>首先是Promise的写法。</p><p> function chainAnimationsPromise(elem, animations) {<br>  &#x2F;&#x2F; 变量ret用来保存上一个动画的返回值<br>  var ret &#x3D; null;<br>  &#x2F;&#x2F; 新建一个空的Promise<br>  var p &#x3D; Promise.resolve();<br>  &#x2F;&#x2F; 使用then方法，添加所有动画<br>  for(var anim of animations) {<br>   p &#x3D; p.then(function(val) {<br>   ret &#x3D; val;<br>   return anim(elem);<br>  });<br>  }<br>  &#x2F;&#x2F; 返回一个部署了错误捕捉机制的Promise<br>  return p.catch(function(e) {<br>   &#x2F;<em>忽略错误，继续执行</em>&#x2F;<br>  }).then(function() {<br>   return ret;<br>  });<br> }</p><p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p><p>接着是Generator函数的写法。</p><p> function chainAnimationsGenerator(elem, animations) {<br>  return spawn(function*() {<br>   var ret &#x3D; null;<br>   try {<br>    for(var anim of animations) {<br>     ret &#x3D; yield anim(elem);<br>    }<br>   } catch(e) {<br>    &#x2F;* 忽略错误，继续执行 *&#x2F;<br>   }<br>   return ret;<br>  });<br> }<br>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p><p>最后是Async函数的写法。</p><p> async function chainAnimationsAsync(elem, animations) {<br> var ret &#x3D; null;<br> try {<br>  for(var anim of animations) {<br>  ret &#x3D; await anim(elem);<br>  }<br> } catch(e) {<br>  &#x2F;<em>忽略错误，继续执行</em>&#x2F;<br> }<br>  return ret;<br> }<br>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十六章 Promise对象</title>
    <link href="/2022/06/30/ECAMScript-sixteen-Promise-object/"/>
    <url>/2022/06/30/ECAMScript-sixteen-Promise-object/</url>
    
    <content type="html"><![CDATA[<h1 id="第十六章-Promise对象"><a href="#第十六章-Promise对象" class="headerlink" title="第十六章 Promise对象"></a>第十六章 Promise对象</h1><h2 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h2><p>Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</p><p>Promise对象有以下两个特点。</p><ul><li><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled)和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul><p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p><p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。<br>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p><p>下面代码创造了一个Promise实例。</p><p> var promise &#x3D; new Promise(function(resolve, reject) {<br>  &#x2F;&#x2F; … some code<br>  if (&#x2F;<em>异步操作成功</em>&#x2F;){<br>   resolve(value);<br>  } else {<br>   reject(error);<br>  }<br> });<br>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p><p> promise.then(function(value) {<br>  &#x2F;&#x2F; success<br>  }, function(error) {<br>  &#x2F;&#x2F; failure<br> });<br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>下面是一个Promise对象的简单例子。</p><p> function timeout(ms) {<br>  return new Promise((resolve, reject) &#x3D;&gt; {<br>   setTimeout(resolve, ms, ‘done’);<br>  });<br> }<br> timeout(100).then((value) &#x3D;&gt; {<br>  console.log(value);<br> });</p><p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。</p><p>Promise新建后就会立即执行。</p><p> let promise &#x3D; new Promise(function(resolve, reject) {<br>  console.log(‘Promise’);<br>  resolve();<br> });<br> promise.then(function() {<br>  console.log(‘Resolved.’);<br> });<br> console.log(‘Hi!’);<br> &#x2F;&#x2F; Promise<br> &#x2F;&#x2F; Hi!<br> &#x2F;&#x2F; Resolved<br>上面代码中，Promise新建后立即执行，所以首先输出的是“Promise”。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。</p><p>下面是异步加载图片的例子。</p><p> function loadImageAsync(url) {<br>  return new Promise(function(resolve, reject) {<br>   var image &#x3D; new Image();<br>   image.onload &#x3D; function() {<br>    resolve(image);<br>   };<br>   image.onerror &#x3D; function() {<br>    reject(new Error(‘Could not load image at ‘ + url));<br>   };<br>   image.src &#x3D; url;<br>  });<br> }<br>上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p><p>下面是一个用Promise对象实现的Ajax操作的例子。</p><p> var getJSON &#x3D; function(url) {<br>  var promise &#x3D; new Promise(function(resolve, reject){<br>   var client &#x3D; new XMLHttpRequest();<br>   client.open(“GET”, url);<br>   client.onreadystatechange &#x3D; handler;<br>   client.responseType &#x3D; “json”;<br>   client.setRequestHeader(“Accept”, “application&#x2F;json”);<br>   client.send();<br>   function handler() {<br>    if (this.readyState !&#x3D;&#x3D; 4) {<br>     return;<br>    }<br>    if (this.status &#x3D;&#x3D;&#x3D; 200) {<br>     resolve(this.response);<br>    } else {<br>     reject(new Error(this.statusText));<br>    }<br>   };<br>  });<br>  return promise;<br> };<br> getJSON(“&#x2F;posts.json”).then(function(json) {<br>   console.log(‘Contents: ‘ + json);<br>   }, function(error) {<br>  console.error(‘出错了’, error);<br> });</p><p>上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p><p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p><p> var p1 &#x3D; new Promise(function (resolve, reject) {<br>  &#x2F;&#x2F; …<br> });<br> var p2 &#x3D; new Promise(function (resolve, reject) {<br>  &#x2F;&#x2F; …<br>  resolve(p1);<br> })<br>上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</p><p> var p1 &#x3D; new Promise(function (resolve, reject) {<br>  setTimeout(() &#x3D;&gt; reject(new Error(‘fail’)), 3000)<br> })<br> var p2 &#x3D; new Promise(function (resolve, reject) {<br>  setTimeout(() &#x3D;&gt; resolve(p1), 1000)<br> })<br> p2<br> .then(result &#x3D;&gt; console.log(result))<br> .catch(error &#x3D;&gt; console.log(error))<br> &#x2F;&#x2F; Error: fail</p><p>上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。</p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。</p><p>前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p><p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p><p> getJSON(“&#x2F;posts.json”).then(function(json) {<br>  return json.post;<br> }).then(function(post) {<br>  &#x2F;&#x2F; …<br> });<br>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p><p> getJSON(“&#x2F;post&#x2F;1.json”).then(function(post) {<br>  return getJSON(post.commentURL);<br> }).then(function funcA(comments) {<br>  console.log(“Resolved: “, comments);<br> }, function funcB(err){<br>  console.log(“Rejected: “, err);<br> });<br>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><p> getJSON(“&#x2F;post&#x2F;1.json”).then(<br>  post &#x3D;&gt; getJSON(post.commentURL)<br> ).then(<br>  comments &#x3D;&gt; console.log(“Resolved: “, comments),<br>  err &#x3D;&gt; console.log(“Rejected: “, err)<br> );</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p><p> getJSON(“&#x2F;posts.json”).then(function(posts) {<br>  &#x2F;&#x2F; …<br> }).catch(function(error) {<br>  &#x2F;&#x2F; 处理 getJSON 和 前一个回调函数运行时发生的错误<br>  console.log(‘发生错误！’, error);<br> });</p><p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。</p><p> p.then((val) &#x3D;&gt; console.log(“fulfilled:”, val))<br> .catch((err) &#x3D;&gt; console.log(“rejected:”, err));<br> &#x2F;&#x2F; 等同于<br> p.then((val) &#x3D;&gt; console.log(“fulfilled:”, val))<br> .then(null, (err) &#x3D;&gt; console.log(“rejected:”, err));<br> 下面是一个例子。<br> var promise &#x3D; new Promise(function(resolve, reject) {<br>  throw new Error(‘test’);<br> });<br> promise.catch(function(error) {<br>  console.log(error);<br> });<br> &#x2F;&#x2F; Error: test<br>上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><p> &#x2F;&#x2F; 写法一<br> var promise &#x3D; new Promise(function(resolve, reject) {<br> try {<br>  throw new Error(‘test’);<br> } catch(e) {<br>  reject(e);<br> }<br> });<br> promise.catch(function(error) {<br>  console.log(error);<br> });<br> &#x2F;&#x2F; 写法二<br> var promise &#x3D; new Promise(function(resolve, reject) {<br>  reject(new Error(‘test’));<br> });<br> promise.catch(function(error) {<br>  console.log(error);<br> });</p><p>比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。<br>如果Promise状态已经变成Resolved，再抛出错误是无效的。</p><p> var promise &#x3D; new Promise(function(resolve, reject) {<br>  resolve(‘ok’);<br>  throw new Error(‘test’);<br> });<br> promise<br> .then(function(value) { console.log(value) })<br> .catch(function(error) { console.log(error) });<br> &#x2F;&#x2F; ok<br>上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。</p><p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p><p> getJSON(“&#x2F;post&#x2F;1.json”).then(function(post) {<br>  return getJSON(post.commentURL);<br> }).then(function(comments) {<br>  &#x2F;&#x2F; some code<br> }).catch(function(error) {<br>  &#x2F;&#x2F; 处理前面三个Promise产生的错误<br> });</p><p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p><p>一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。<br> &#x2F;&#x2F; bad<br> promise<br> .then(function(data) {<br>  &#x2F;&#x2F; success<br> }, function(err) {<br>  &#x2F;&#x2F; error<br> });<br> &#x2F;&#x2F; good<br> promise<br> .then(function(data) { &#x2F;&#x2F;cb<br>  &#x2F;&#x2F; success<br> })<br> .catch(function(err) {<br>  &#x2F;&#x2F; error<br> });<br>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try&#x2F;catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。</p><p>跟传统的try&#x2F;catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><p> var someAsyncThing &#x3D; function() {<br>  return new Promise(function(resolve, reject) {<br>   &#x2F;&#x2F; 下面一行会报错，因为x没有声明<br>   resolve(x + 2);<br>  });<br> };<br> someAsyncThing().then(function() {<br>  console.log(‘everything is great’);<br> });<br>上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。</p><p> var promise &#x3D; new Promise(function(resolve, reject) {<br>  resolve(“ok”);<br>  setTimeout(function() { throw new Error(‘test’) }, 0)<br> });<br> promise.then(function(value) { console.log(value) });<br> &#x2F;&#x2F; ok<br> &#x2F;&#x2F; Uncaught Error: test</p><p>上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try…catch语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。</p><p> Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。<br> process.on(‘unhandledRejection’, function (err, p) {<br>  console.error(err.stack)<br> });</p><p>上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。</p><p>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p><p> var someAsyncThing &#x3D; function() {<br>  return new Promise(function(resolve, reject) {<br>   &#x2F;&#x2F; 下面一行会报错，因为x没有声明<br>   resolve(x + 2);<br>  });<br> };<br> someAsyncThing()<br> .catch(function(error) {<br>  console.log(‘oh no’, error);<br> })<br> .then(function() {<br>  console.log(‘carry on’);<br> });<br> &#x2F;&#x2F; oh no [ReferenceError: x is not defined]<br> &#x2F;&#x2F; carry on</p><p>上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。</p><p> Promise.resolve()<br> .catch(function(error) {<br>  console.log(‘oh no’, error);<br> })<br> .then(function() {<br>  console.log(‘carry on’);<br> });<br> &#x2F;&#x2F; carry on</p><p>上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。</p><p>catch方法之中，还能再抛出错误。</p><p> var someAsyncThing &#x3D; function() {<br>  return new Promise(function(resolve, reject) {<br>   &#x2F;&#x2F; 下面一行会报错，因为x没有声明<br>   resolve(x + 2);<br>  });<br> };<br> someAsyncThing().then(function() {<br>  return someOtherAsyncThing();<br> }).catch(function(error) {<br>  console.log(‘oh no’, error);<br>  &#x2F;&#x2F; 下面一行会报错，因为y没有声明<br>  y + 2;<br> }).then(function() {<br>  console.log(‘carry on’);<br> });<br> &#x2F;&#x2F; oh no [ReferenceError: x is not defined]</p><p>上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><p> someAsyncThing().then(function() {<br>  return someOtherAsyncThing();<br> }).catch(function(error) {<br>  console.log(‘oh no’, error);<br>  &#x2F;&#x2F; 下面一行会报错，因为y没有声明<br>  y + 2;<br> }).catch(function(error) {<br>  console.log(‘carry on’, error);<br> });<br> &#x2F;&#x2F; oh no [ReferenceError: x is not defined]<br> &#x2F;&#x2F; carry on [ReferenceError: y is not defined]<br>上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p><p> var p &#x3D; Promise.all([p1, p2, p3]);</p><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）</p><p>p的状态由p1、p2、p3决定，分成两种情况。</p><ol><li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li><li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li></ol><p>下面是一个具体的例子。</p><p> &#x2F;&#x2F; 生成一个Promise对象的数组<br> var promises &#x3D; [2, 3, 5, 7, 11, 13].map(function (id) {<br>  return getJSON(“&#x2F;post&#x2F;“ + id + “.json”);<br> });<br> Promise.all(promises).then(function (posts) {<br>  &#x2F;&#x2F; …<br> }).catch(function(reason){<br>  &#x2F;&#x2F; …<br> });</p><p>上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。</p><p>下面是另一个例子。</p><p> const databasePromise &#x3D; connectDatabase();<br> const booksPromise &#x3D; databaseProimse<br> .then(findAllBooks);<br> const userPromise &#x3D; databasePromise<br> .then(getCurrentUser);<br> Promise.all([<br>  booksPromise,<br>  userPromise<br> ])<br> .then(([books, user]) &#x3D;&gt; pickTopRecommentations(books, user));<br>上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。</p><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p><p>var p &#x3D; Promise.race([p1,p2,p3]);</p><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p><p>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。</p><p> var p &#x3D; Promise.race([<br> fetch(‘&#x2F;resource-that-may-take-a-while’),<br>  new Promise(function (resolve, reject) {<br>   setTimeout(() &#x3D;&gt; reject(new Error(‘request timeout’)), 5000)<br>  })<br> ])<br> p.then(response &#x3D;&gt; console.log(response))<br> p.catch(error &#x3D;&gt; console.log(error))</p><p>上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p><p> var jsPromise &#x3D; Promise.resolve($.ajax(‘&#x2F;whatever.json’));</p><p>上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。</p><p> Promise.resolve等价于下面的写法。<br> Promise.resolve(‘foo’)<br> &#x2F;&#x2F; 等价于<br> new Promise(resolve &#x3D;&gt; resolve(‘foo’))<br> Promise.resolve方法的参数分成四种情况。</p><ol><li>参数是一个Promise实例</li></ol><p> 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p><ol start="2"><li>参数是一个 thenable对象</li></ol><p>  thenable对象指的是具有then方法的对象，比如下面这个对象。<br>  let thenable &#x3D; {<br>   then: function(resolve, reject) {<br>    resolve(42);<br>   }<br>  };<br> Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。</p><p>  let thenable &#x3D; {<br>   then: function(resolve, reject) {<br>    resolve(42);<br>   }<br>  };<br>  let p1 &#x3D; Promise.resolve(thenable);<br>  p1.then(function(value) {<br>   console.log(value); &#x2F;&#x2F; 42<br>  });</p><p> 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。<br>3. 参数不是具有 then方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。</p><p>  var p &#x3D; Promise.resolve(‘Hello’);<br>  p.then(function (s){<br>   console.log(s)<br>  });<br>  &#x2F;&#x2F; Hello<br> 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。<br>4. 不带有任何参数<br> Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p><p>  var p &#x3D; Promise.resolve();<br>  p.then(function () {<br>   &#x2F;&#x2F; …<br>  });<br> 上面代码的变量p就是一个Promise对象。</p><p> 需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p><p>  setTimeout(function () {<br>   console.log(‘three’);<br>  }, 0);<br>  Promise.resolve().then(function () {<br>   console.log(‘two’);<br>  });<br>  console.log(‘one’);<br>  &#x2F;&#x2F; one<br>  &#x2F;&#x2F; two<br>  &#x2F;&#x2F; three</p><p> 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。</p><p> var p &#x3D; Promise.reject(‘出错了’);<br> &#x2F;&#x2F; 等同于<br> var p &#x3D; new Promise((resolve, reject) &#x3D;&gt; reject(‘出错了’))<br> p.then(null, function (s){<br>  console.log(s)<br> });<br> &#x2F;&#x2F; 出错了<br>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p><h2 id="两个有用的附加方法"><a href="#两个有用的附加方法" class="headerlink" title="两个有用的附加方法"></a>两个有用的附加方法</h2><p>ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。</p><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p><p> asyncFunc()<br> .then(f1)<br> .catch(r1)<br> .then(f2)<br> .done();</p><p>它的实现代码相当简单。</p><p> Promise.prototype.done &#x3D; function (onFulfilled, onRejected) {<br> this.then(onFulfilled, onRejected)<br> .catch(function (reason) {<br>  &#x2F;&#x2F; 抛出一个全局错误<br>  setTimeout(() &#x3D;&gt; { throw reason }, 0);<br>  });<br> };<br>从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p><p>下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。</p><p> server.listen(0)<br> .then(function () {<br>  &#x2F;&#x2F; run test<br> })<br> .finally(server.stop);</p><p>它的实现也很简单。</p><p> Promise.prototype.finally &#x3D; function (callback) {<br>  let P &#x3D; this.constructor;<br>  return this.then(<br>   value &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; value),<br>   reason &#x3D;&gt; P.resolve(callback()).then(() &#x3D;&gt; { throw reason })<br>  );<br> };</p><p>上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。</p><p> const preloadImage &#x3D; function (path) {<br>  return new Promise(function (resolve, reject) {<br>   var image &#x3D; new Image();<br>   image.onload &#x3D; resolve;<br>   image.onerror &#x3D; reject;<br>   image.src &#x3D; path;<br>  });<br> };</p><h3 id="Generator函数与Promise的结合"><a href="#Generator函数与Promise的结合" class="headerlink" title="Generator函数与Promise的结合"></a>Generator函数与Promise的结合</h3><p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p><p> function getFoo () {<br>  return new Promise(function (resolve, reject){<br>   resolve(‘foo’);<br>  });<br> }<br> var g &#x3D; function* () {<br>  try {<br>   var foo &#x3D; yield getFoo();<br>   console.log(foo);<br>  } catch (e) {<br>   console.log(e);<br>  }<br> };<br> function run (generator) {<br>  var it &#x3D; generator();<br>  function go(result) {<br>   if (result.done) return result.value;<br>   return result.value.then(function (value) {<br>     return go(it.next(value));<br>    }, function (error) {<br>     return go(it.throw(error));<br>   });<br>  }<br>  go(it.next());<br> }<br> run(g);</p><p>上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一<br>个next方法。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十五章 Generator函数</title>
    <link href="/2022/06/28/ECMAScript-fifteen-chart/"/>
    <url>/2022/06/28/ECMAScript-fifteen-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="第十五章-Generator函数"><a href="#第十五章-Generator函数" class="headerlink" title="第十五章 Generator函数"></a>第十五章 Generator函数</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。</p><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p><p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p><p>形式上，Generator函数是一个普通函数，但是有两个特征。</p><p>一是，function关键字与函数名之间有一个星号；<br>二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。</p><p> function* helloWorldGenerator() {<br>  yield ‘hello’;<br>  yield ‘world’;<br>  return ‘ending’;<br> }<br> var hw &#x3D; helloWorldGenerator();</p><p>上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。</p><p>然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。</p><p> hw.next()<br> &#x2F;&#x2F; { value: ‘hello’, done: false }<br> hw.next()<br> &#x2F;&#x2F; { value: ‘world’, done: false }<br> hw.next()<br> &#x2F;&#x2F; { value: ‘ending’, done: true }<br> hw.next()<br> &#x2F;&#x2F; { value: undefined, done: true }</p><p>上面代码一共调用了四次next方法。</p><p>第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。</p><p>第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回的对象的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。</p><p>第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。</p><p>第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</p><p>总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p><p>ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。</p><p> function <em>foo(x, y) { ··· }<br>function</em>foo(x, y) { ··· }<br> function<em>foo(x, y) { ··· }<br> function</em>foo(x, y) { ··· }</p><p>由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。</p><h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><p>由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。</p><p>遍历器对象的next方法的运行逻辑如下。</p><ol><li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li><li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li><li></li></ol><p>需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><p> function* gen() {<br>  yield 123 + 456;<br> }</p><p>上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。</p><p>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。</p><p>Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。</p><p> function* f() {<br>  console.log(‘执行了！’)<br> }<br> var generator &#x3D; f();<br> setTimeout(function () {<br>  generator.next()<br> }, 2000);</p><p>上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。</p><p>另外需要注意，yield语句不能用在普通函数中，否则会报错。</p><p> (function (){<br>  yield 1;<br> })()<br> &#x2F;&#x2F; SyntaxError: Unexpected number</p><p>上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。</p><p>下面是另外一个例子。</p><p> var arr &#x3D; [1, [[2, 3], 4], [5, 6]];<br> var flat &#x3D; function*(a) {<br>  a.forEach(function (item) {<br>   if (typeof item !&#x3D;&#x3D; ‘number’) {<br>    yield* flat(item);<br>   } else {<br>    yield item;<br>   }<br>  }<br> };<br> for (var f of flat(arr)){<br>  console.log(f);<br> }</p><p>上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句（这个函数里面还使用了yield*语句，这里可以不用理会，详细说明见后文）。一种修改方法是改用for循环。</p><p> var arr &#x3D; [1, [[2, 3], 4], [5, 6]];<br> var flat &#x3D; function*(a) {<br>  var length &#x3D; a.length;<br>  for (var i &#x3D; 0; i &lt; length; i++) {<br>   var item &#x3D; a[i];<br>   if (typeof item !&#x3D;&#x3D; ‘number’) {<br>   yield* flat(item);<br>   } else {<br>    yield item;<br>   }<br>  }<br> };<br> for (var f of flat(arr)) {<br>  console.log(f);<br> }<br> &#x2F;&#x2F; 1, 2, 3, 4, 5, 6</p><p>另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。</p><p> console.log(‘Hello’ + yield); &#x2F;&#x2F; SyntaxError<br> console.log(‘Hello’ + yield 123); &#x2F;&#x2F; SyntaxError<br> console.log(‘Hello’ + (yield)); &#x2F;&#x2F; OK<br> console.log(‘Hello’ + (yield 123)); &#x2F;&#x2F; OK</p><p>yield语句用作函数参数或赋值表达式的右边，可以不加括号。</p><p> foo(yield ‘a’, yield ‘b’); &#x2F;&#x2F; OK<br> let input &#x3D; yield; &#x2F;&#x2F; OK</p><h3 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="与Iterator接口的关系"></a>与Iterator接口的关系</h3><p>上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。</p><p> var myIterable &#x3D; {};<br> myIterable[Symbol.iterator] &#x3D; function* () {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br> };<br> […myIterable] &#x2F;&#x2F; [1, 2, 3]</p><p>上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被…运算符遍历了。</p><p>Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p><p> function* gen(){<br>  &#x2F;&#x2F; some code<br> }<br> var g &#x3D; gen();<br>  g<a href="">Symbol.iterator</a> &#x3D;&#x3D;&#x3D; g<br> &#x2F;&#x2F; true</p><p>上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。</p><h2 id="next方法的参数"><a href="#next方法的参数" class="headerlink" title="next方法的参数"></a>next方法的参数</h2><p>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p><p> function* f() {<br>  for(var i&#x3D;0; true; i++) {<br>   var reset &#x3D; yield i;<br>   if(reset) { i &#x3D; -1; }<br>  }<br> }<br> var g &#x3D; f();<br> g.next() &#x2F;&#x2F; { value: 0, done: false }<br> g.next() &#x2F;&#x2F; { value: 1, done: false }<br> g.next(true) &#x2F;&#x2F; { value: 0, done: false }</p><p>上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p><p>这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><p>再看一个例子。</p><p> function<em>foo(x) {<br>var y &#x3D; 2</em> (yield (x + 1));<br>  var z &#x3D; yield (y &#x2F; 3);<br>  return (x + y + z);<br> }<br> var a &#x3D; foo(5);<br> a.next() &#x2F;&#x2F; Object{value:6, done:false}<br> a.next() &#x2F;&#x2F; Object{value:NaN, done:false}<br> a.next() &#x2F;&#x2F; Object{value:NaN, done:true}<br> var b &#x3D; foo(5);<br> b.next() &#x2F;&#x2F; { value:6, done:false }<br> b.next(12) &#x2F;&#x2F; { value:8, done:false }<br> b.next(13) &#x2F;&#x2F; { value:42, done:true }</p><p>上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。</p><p>如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y &#x2F; 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。</p><p>注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。</p><p>如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。</p><p> function wrapper(generatorFunction) {<br>  return function (…args) {<br>    let generatorObject &#x3D; generatorFunction(…args);<br>    generatorObject.next();<br>    return generatorObject;<br>   };<br> }<br> const wrapped &#x3D; wrapper(function* () {<br>  console.log(<code>First input: $&#123;yield&#125;</code>);<br>  return ‘DONE’;<br> });<br> wrapped().next(‘hello!’)<br> &#x2F;&#x2F; First input: hello!</p><p>上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。<br>再看一个通过next方法的参数，向Generator函数内部输入值的例子。</p><p> function* dataConsumer() {<br>  console.log(‘Started’);<br>  console.log(<code>1. $&#123;yield&#125;</code>);<br>  console.log(<code>2. $&#123;yield&#125;</code>);<br>  return ‘result’;<br> }<br> let genObj &#x3D; dataConsumer();<br> genObj.next();<br> &#x2F;&#x2F; Started<br> genObj.next(‘a’)<br> &#x2F;&#x2F; 1. a<br> genObj.next(‘b’)<br> &#x2F;&#x2F; 2. b<br>上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。</p><h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。</p><p> function *foo() {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br>  yield 4;<br>  yield 5;<br>  return 6;<br> }<br> for (let v of foo()) {<br>  console.log(v);<br> }<br> &#x2F;&#x2F; 1 2 3 4 5</p><p>上面代码使用for…of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。</p><p>下面是一个利用Generator函数和for…of循环，实现斐波那契数列的例子。</p><p> function* fibonacci() {<br>  let [prev, curr] &#x3D; [0, 1];<br>  for (;;) {<br>   [prev, curr] &#x3D; [curr, prev + curr];<br>   yield curr;<br>  }<br> }<br> for (let n of fibonacci()) {<br>  if (n &gt; 1000) break;<br>  console.log(n);<br> }<br>从上面代码可见，使用for…of语句时不需要使用next方法。</p><p>利用for…of循环，可以写出遍历任意对象（object）的方法。原生的JavaScript对象没有遍历接口，无法使用for…of循环，通过Generator函数为它加上这个接口，就可以用了。</p><p> function* objectEntries(obj) {<br>  let propKeys &#x3D; Reflect.ownKeys(obj);<br>  for (let propKey of propKeys) {<br>   yield [propKey, obj[propKey]];<br>  }<br> }<br> let jane &#x3D; { first: ‘Jane’, last: ‘Doe’ };<br> for (let [key, value] of objectEntries(jane)) {<br>  console.log(<code>$&#123;key&#125;: $&#123;value&#125;</code>);<br> }<br> &#x2F;&#x2F; first: Jane<br> &#x2F;&#x2F; last: Doe</p><p>上面代码中，对象jane原生不具备Iterator接口，无法用for…of遍历。这时，我们通过Generator函数objectEntries为它加上遍历器接口，就可以用for…of遍历了。加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面。</p><p> function* objectEntries() {<br>  let propKeys &#x3D; Object.keys(this);<br>  for (let propKey of propKeys) {<br>   yield [propKey, this[propKey]];<br>  }<br> }<br> let jane &#x3D; { first: ‘Jane’, last: ‘Doe’ };<br> jane[Symbol.iterator] &#x3D; objectEntries;<br> for (let [key, value] of jane) {<br>  console.log(<code>$&#123;key&#125;: $&#123;value&#125;</code>);<br> }<br> &#x2F;&#x2F; first: Jane<br> &#x2F;&#x2F; last: Doe</p><p>除了for…of循环以外，扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将Generator函数返回的Iterator对象，作为参数。</p><p> function* numbers () {<br>  yield 1<br>  yield 2<br>  return 3<br>  yield 4<br> }<br> &#x2F;&#x2F; 扩展运算符<br> […numbers()] &#x2F;&#x2F; [1, 2]<br> &#x2F;&#x2F; Array.form 方法<br> Array.from(numbers()) &#x2F;&#x2F; [1, 2]<br> &#x2F;&#x2F; 解构赋值<br> let [x, y] &#x3D; numbers();<br> x &#x2F;&#x2F; 1<br> y &#x2F;&#x2F; 2<br> &#x2F;&#x2F; for…of 循环<br> for (let n of numbers()) {<br>  console.log(n)<br> }<br> &#x2F;&#x2F; 1<br> &#x2F;&#x2F; 2</p><h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</p><p> var g &#x3D; function* () {<br>  try {<br>   yield;<br>  } catch (e) {<br>   console.log(‘内部捕获’, e);<br>  }<br> };<br> var i &#x3D; g();<br> i.next();<br>  try {<br>   i.throw(‘a’);<br>   i.throw(‘b’);<br>  } catch (e) {<br>   console.log(‘外部捕获’, e);<br>  }<br> &#x2F;&#x2F; 内部捕获 a<br> &#x2F;&#x2F; 外部捕获 b</p><p>上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。</p><p>throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。</p><p> var g &#x3D; function* () {<br>  try {<br>   yield;<br>  } catch (e) {<br>   console.log(e);<br>  }<br> };<br> var i &#x3D; g();<br> i.next();<br> i.throw(new Error(‘出错了！’));<br> &#x2F;&#x2F; Error: 出错了！(…)</p><p>注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。</p><p> var g &#x3D; function* () {<br>  while (true) {<br>   try {<br>    yield;<br>   } catch (e) {<br>    if (e !&#x3D; ‘a’) throw e;<br>    console.log(‘内部捕获’, e);<br>   }<br>  }<br> };<br> var i &#x3D; g();<br> i.next();<br> try {<br>  throw new Error(‘a’);<br>  throw new Error(‘b’);<br> } catch (e) {<br>  console.log(‘外部捕获’, e);<br> }<br> &#x2F;&#x2F; 外部捕获 [Error: a]</p><p>上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。</p><p>如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。</p><p> var g &#x3D; function* () {<br>  while (true) {<br>   yield;<br>   console.log(‘内部捕获’, e);<br>  }<br> };<br> var i &#x3D; g();<br> i.next();<br> try {<br>  i.throw(‘a’);<br>  i.throw(‘b’);<br> } catch (e) {<br>  console.log(‘外部捕获’, e);<br> }<br> &#x2F;&#x2F; 外部捕获 a</p><p>上面代码中，Generator函数g内部没有部署try…catch代码块，所以抛出的错误直接被外部catch代码块捕获。</p><p>如果Generator函数内部和外部，都没有部署try…catch代码块，那么程序将报错，直接中断执行。</p><p> var gen &#x3D; function* gen(){<br>  yield console.log(‘hello’);<br>  yield console.log(‘world’);<br> }<br> var g &#x3D; gen();<br> g.next();<br> g.throw();<br> &#x2F;&#x2F; hello<br> &#x2F;&#x2F; Uncaught undefined</p><p>上面代码中，g.throw抛出错误以后，没有任何try…catch代码块可以捕获这个错误，导致程序报错，中断执行。</p><p>throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法。</p><p> var gen &#x3D; function* gen(){<br>  try {<br>   yield console.log(‘a’);<br>  } catch (e) {<br>   &#x2F;&#x2F; …<br>  }<br>  yield console.log(‘b’);<br>  yield console.log(‘c’);<br> }<br> var g &#x3D; gen();<br> g.next() &#x2F;&#x2F; a<br> g.throw() &#x2F;&#x2F; b<br> g.next() &#x2F;&#x2F; c</p><p>上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。<br>另外，throw命令与g.throw方法是无关的，两者互不影响。</p><p> var gen &#x3D; function* gen(){<br>  yield console.log(‘hello’);<br>  yield console.log(‘world’);<br> }<br> var g &#x3D; gen();<br> g.next();<br> try {<br>  throw new Error();<br> } catch (e) {<br>  g.next();<br> }<br> &#x2F;&#x2F; hello<br> &#x2F;&#x2F; world<br>上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。<br>这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield语句，可以只用一个try…catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。</p><p>Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。</p><p> function *foo() {<br>  var x &#x3D; yield 3;<br>  var y &#x3D; x.toUpperCase();<br>  yield y;<br> }<br> var it &#x3D; foo();<br> it.next(); &#x2F;&#x2F; { value:3, done:false }<br> try {<br>  it.next(42);<br> } catch (err) {<br>  console.log(err);<br> }<br>上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。</p><p>一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p><p> function* g() {<br>  yield 1;<br>  console.log(‘throwing an exception’);<br>  throw new Error(‘generator broke!’);<br>  yield 2;<br>  yield 3;<br> }<br> function log(generator) {<br>  var v;<br>  console.log(‘starting generator’);<br>  try {<br>   v &#x3D; generator.next();<br>   console.log(‘第一次运行next方法’, v);<br>  } catch (err) {<br>   console.log(‘捕捉错误’, v);<br>  }<br>  try {<br>   v &#x3D; generator.next();<br>   console.log(‘第二次运行next方法’, v);<br>  } catch (err) {<br>   console.log(‘捕捉错误’, v);<br>  }<br>  try {<br>   v &#x3D; generator.next();<br>   console.log(‘第三次运行next方法’, v);<br>  } catch (err) {<br>   console.log(‘捕捉错误’, v);<br>  }<br>   console.log(‘caller done’);<br> }<br> log(g());<br> &#x2F;&#x2F; starting generator<br> &#x2F;&#x2F; 第一次运行next方法 { value: 1, done: false }<br> &#x2F;&#x2F; throwing an exception<br> &#x2F;&#x2F; 捕捉错误 { value: 1, done: false }<br> &#x2F;&#x2F; 第三次运行next方法 { value: undefined, done: true }<br> &#x2F;&#x2F; caller done<br>上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。</p><h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p><p> function* gen() {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br> }<br> var g &#x3D; gen();<br> g.next() &#x2F;&#x2F; { value: 1, done: false }<br> g.return(‘foo’) &#x2F;&#x2F; { value: “foo”, done: true }<br> g.next() &#x2F;&#x2F; { value: undefined, done: true }</p><p>上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。</p><p>如果return方法调用时，不提供参数，则返回值的value属性为undefined。</p><p> function* gen() {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br> }<br> var g &#x3D; gen();<br> g.next() &#x2F;&#x2F; { value: 1, done: false }<br> g.return() &#x2F;&#x2F; { value: undefined, done: true }</p><p>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p><p> function* numbers () {<br>  yield 1;<br>  try {<br>   yield 2;<br>   yield 3;<br>  } finally {<br>   yield 4;<br>   yield 5;<br>  }<br>  yield 6;<br> }<br> var g &#x3D; numbers()<br> g.next() &#x2F;&#x2F; { done: false, value: 1 }<br> g.next() &#x2F;&#x2F; { done: false, value: 2 }<br> g.return(7) &#x2F;&#x2F; { done: false, value: 4 }<br> g.next() &#x2F;&#x2F; { done: false, value: 5 }<br> g.next() &#x2F;&#x2F; { done: true, value: 7 }</p><p>上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。</p><h2 id="yield-语句"><a href="#yield-语句" class="headerlink" title="yield*语句"></a>yield*语句</h2><p>如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。</p><p> function<em>foo() {<br>  yield ‘a’;<br>  yield ‘b’;<br> }<br> function</em> bar() {<br>  yield ‘x’;<br>  foo();<br>  yield ‘y’;<br> }<br> for (let v of bar()){<br>  console.log(v);<br> }<br> &#x2F;&#x2F; “x”<br> &#x2F;&#x2F; “y”<br>上面代码中，foo和bar都是Generator函数，在bar里面调用foo，是不会有效果的。</p><p>这个就需要用到yield*语句，用来在一个Generator函数里面执行另一个Generator函数。</p><p> function<em>bar() {<br>  yield ‘x’;<br>  yield</em> foo();<br>  yield ‘y’;<br> }<br> &#x2F;&#x2F; 等同于<br> function<em>bar() {<br>  yield ‘x’;<br>  yield ‘a’;<br>  yield ‘b’;<br>  yield ‘y’;<br> }<br> &#x2F;&#x2F; 等同于<br> function</em> bar() {<br>  yield ‘x’;<br>  for (let v of foo()) {<br>   yield v;<br>  }<br>  yield ‘y’;<br> }<br> for (let v of bar()){<br>  console.log(v);<br> }<br> &#x2F;&#x2F; “x”<br> &#x2F;&#x2F; “a”<br> &#x2F;&#x2F; “b”<br> &#x2F;&#x2F; “y”<br> 再来看一个对比的例子。<br> function<em>inner() {<br>  yield ‘hello!’;<br> }<br> function</em> outer1() {<br>  yield ‘open’;<br>  yield inner();<br>  yield ‘close’;<br> }<br> var gen &#x3D; outer1()<br> gen.next().value &#x2F;&#x2F; “open”<br> gen.next().value &#x2F;&#x2F; 返回一个遍历器对象<br> gen.next().value &#x2F;&#x2F; “close”<br> function<em>outer2() {<br>  yield ‘open’<br>  yield</em> inner()<br>  yield ‘close’<br> }<br> var gen &#x3D; outer2()<br> gen.next().value &#x2F;&#x2F; “open”<br> gen.next().value &#x2F;&#x2F; “hello!”<br> gen.next().value &#x2F;&#x2F; “close”</p><p>上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。</p><p>从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*语句。</p><p> let delegatedIterator &#x3D; (function*() {<br>  yield ‘Hello!’;<br>  yield ‘Bye!’;<br> }());<br> let delegatingIterator &#x3D; (function* () {<br>  yield ‘Greetings!’;<br>  yield<em>delegatedIterator;<br>  yield ‘Ok, bye.’;<br> }());<br> for(let value of delegatingIterator) {<br>  console.log(value);<br> }<br> &#x2F;&#x2F; “Greetings!<br> &#x2F;&#x2F; “Hello!”<br> &#x2F;&#x2F; “Bye!”<br> &#x2F;&#x2F; “Ok, bye.”<br>上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield</em>delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for…of循环。</p><p> function<em>concat(iter1, iter2) {<br>  yield</em> iter1;<br>  yield<em>iter2;<br> }<br> &#x2F;&#x2F; 等同于<br> function</em> concat(iter1, iter2) {<br>  for (var value of iter1) {<br>   yield value;<br>  }<br>  for (var value of iter2) {<br>   yield value;<br>  }<br> }<br>上面代码说明，yield<em>后面的Generator函数（没有return语句时），不过是for…of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value &#x3D; yield</em> iterator的形式获取return语句的值。<br>如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><p> function<em>gen(){<br>  yield</em> [“a”, “b”, “c”];<br> }<br> gen().next() &#x2F;&#x2F; { value:”a”, done:false }</p><p>上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。<br>实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。</p><p> let read &#x3D; (function*() {<br>  yield ‘hello’;<br>  yield* ‘hello’;<br> })();<br> read.next().value &#x2F;&#x2F; “hello”<br> read.next().value &#x2F;&#x2F; “h”</p><p>上面代码中，yield语句返回整个字符串，yield<em>语句返回单个字符。因为字符串具有Iterator接口，所以被yield</em>遍历。</p><p>如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。</p><p> function <em>foo() {<br>  yield 2;<br>  yield 3;<br>  return “foo”;<br> }<br>function</em>bar() {<br>  yield 1;<br>  var v &#x3D; yield *foo();<br>  console.log( “v: “ + v );<br>  yield 4;<br> }<br> var it &#x3D; bar();<br> it.next()<br> &#x2F;&#x2F; {value: 1, done: false}<br> it.next()<br> &#x2F;&#x2F; {value: 2, done: false}<br> it.next()<br> &#x2F;&#x2F; {value: 3, done: false}<br> it.next();<br> &#x2F;&#x2F; “v: foo”<br> &#x2F;&#x2F; {value: 4, done: false}<br> it.next()<br> &#x2F;&#x2F; {value: undefined, done: true}<br>上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。</p><p>再看一个例子。</p><p> function<em>genFuncWithReturn() {<br>  yield ‘a’;<br>  yield ‘b’;<br>  return ‘The result’;<br> }<br> function</em> logReturned(genObj) {<br>  let result &#x3D; yield<em>genObj;<br>  console.log(result);<br> }<br> […logReturned(genFuncWithReturn())]<br> &#x2F;&#x2F; The result<br> &#x2F;&#x2F; 值为 [ ‘a’, ‘b’ ]<br>上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield</em>语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ ‘a’, ‘b’ ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。</p><p>yield*命令可以很方便地取出嵌套数组的所有成员。</p><p> function<em>iterTree(tree) {<br>  if (Array.isArray(tree)) {<br>   for(let i&#x3D;0; i &lt; tree.length; i++) {<br>    yield</em> iterTree(tree[i]);<br>   }<br>  } else {<br>   yield tree;<br>  }<br> }<br> const tree &#x3D; [ ‘a’, [‘b’, ‘c’], [‘d’, ‘e’] ];<br> for(let x of iterTree(tree)) {<br>  console.log(x);<br> }<br> &#x2F;&#x2F; a<br> &#x2F;&#x2F; b<br> &#x2F;&#x2F; c<br> &#x2F;&#x2F; d<br> &#x2F;&#x2F; e<br>下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。</p><p>&#x2F;&#x2F; 下面是二叉树的构造函数，</p><p>&#x2F;&#x2F; 三个参数分别是左树、当前节点和右树</p><p> function Tree(left, label, right) {<br>  this.left &#x3D; left;<br>  this.label &#x3D; label;<br>  this.right &#x3D; right;<br> }<br>&#x2F;&#x2F; 下面是中序（inorder）遍历函数。</p><p>&#x2F;&#x2F; 由于返回的是一个遍历器，所以要用generator函数。</p><p>&#x2F;&#x2F; 函数体内采用递归算法，所以左树和右树要用yield*遍历</p><p> function<em>inorder(t) {<br>  if (t) {<br>   yield</em> inorder(t.left);<br>   yield t.label;<br>   yield* inorder(t.right);<br>  }<br> }<br>&#x2F;&#x2F; 下面生成二叉树</p><p> function make(array) {<br> &#x2F;&#x2F; 判断是否为叶节点<br>  if (array.length &#x3D;&#x3D; 1) return new Tree(null, array[0], null);<br>  return new Tree(make(array[0]), array[1], make(array[2]));<br> }</p><p> let tree &#x3D; make([[[‘a’], ‘b’, [‘c’]], ‘d’, [[‘e’], ‘f’, [‘g’]]]);<br>&#x2F;&#x2F; 遍历二叉树</p><p> var result &#x3D; [];<br> for (let node of inorder(tree)) {<br>  result.push(node);<br> }<br> result<br> &#x2F;&#x2F; [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’]</p><h2 id="作为对象属性的Generator函数"><a href="#作为对象属性的Generator函数" class="headerlink" title="作为对象属性的Generator函数"></a>作为对象属性的Generator函数</h2><p>如果一个对象的属性是Generator函数，可以简写成下面的形式。</p><p> let obj &#x3D; {</p><ul><li>myGeneratorMethod() {<br>···<br>}<br> };<br>上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。</li></ul><p>它的完整形式如下，与上面的写法是等价的。</p><p> let obj &#x3D; {<br>  myGeneratorMethod: function* () {<br>  &#x2F;&#x2F; ···<br>  }<br> };</p><h2 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h2><p>Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。</p><p> function* g() {}<br> g.prototype.hello &#x3D; function () {<br>  return ‘hi!’;<br> };<br> let obj &#x3D; g();<br> obj instanceof g &#x2F;&#x2F; true<br> obj.hello() &#x2F;&#x2F; ‘hi!’</p><p>上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。</p><p> function* g() {<br>  this.a &#x3D; 11;<br> }<br> let obj &#x3D; g();<br> obj.a &#x2F;&#x2F; undefined<br>上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。</p><p>Generator函数也不能跟new命令一起用，会报错。</p><p> function* F() {<br>  yield this.x &#x3D; 2;<br>  yield this.y &#x3D; 3;<br> }<br> new F()<br> &#x2F;&#x2F; TypeError: F is not a constructor<br>上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。</p><p>那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？<br>下面是一个变通方法。首先，生成一个空对象，使用bind方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。</p><p> function* F() {<br>  this.a &#x3D; 1;<br>  yield this.b &#x3D; 2;<br>  yield this.c &#x3D; 3;<br> }<br> var obj &#x3D; {};<br> var f &#x3D; F.call(obj);<br> f.next(); &#x2F;&#x2F; Object {value: 2, done: false}<br> f.next(); &#x2F;&#x2F; Object {value: 3, done: false}<br> f.next(); &#x2F;&#x2F; Object {value: undefined, done: true}<br> obj.a &#x2F;&#x2F; 1<br> obj.b &#x2F;&#x2F; 2<br> obj.c &#x2F;&#x2F; 3</p><p>上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。</p><p>上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？</p><p>一个办法就是将obj换成F.prototype。</p><p> function* F() {<br> this.a &#x3D; 1;<br>  yield this.b &#x3D; 2;<br>  yield this.c &#x3D; 3;<br> }<br> var f &#x3D; F.call(F.prototype);<br> f.next(); &#x2F;&#x2F; Object {value: 2, done: false}<br> f.next(); &#x2F;&#x2F; Object {value: 3, done: false}<br> f.next(); &#x2F;&#x2F; Object {value: undefined, done: true}<br> f.a &#x2F;&#x2F; 1<br> f.b &#x2F;&#x2F; 2<br> f.c &#x2F;&#x2F; 3</p><p>再将F改成构造函数，就可以对它执行new命令了。</p><p> function* gen() {<br> this.a &#x3D; 1;<br>  yield this.b &#x3D; 2;<br>  yield this.c &#x3D; 3;<br> }<br> function F() {<br>  return gen.call(gen.prototype);<br> }<br> var f &#x3D; new F();<br> f.next(); &#x2F;&#x2F; Object {value: 2, done: false}<br> f.next(); &#x2F;&#x2F; Object {value: 3, done: false}<br> f.next(); &#x2F;&#x2F; Object {value: undefined, done: true}<br> f.a &#x2F;&#x2F; 1<br> f.b &#x2F;&#x2F; 2<br> f.c &#x2F;&#x2F; 3</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><h3 id="Generator与状态机"><a href="#Generator与状态机" class="headerlink" title="Generator与状态机"></a>Generator与状态机</h3><p>Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。</p><p> var ticking &#x3D; true;<br> var clock &#x3D; function() {<br>  if (ticking)<br>   console.log(‘Tick!’);<br>  else<br>   console.log(‘Tock!’);<br>  ticking &#x3D; !ticking;<br> }</p><p>上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。</p><p> var clock &#x3D; function*() {<br>  while (true) {<br>   console.log(‘Tick!’);<br>   yield;<br>   console.log(‘Tock!’);<br>   yield;<br>  }<br> };<br>上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p><h3 id="Generator与协程"><a href="#Generator与协程" class="headerlink" title="Generator与协程"></a>Generator与协程</h3><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p><ol><li>协程与子例程的差异</li></ol><p> 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p><p> 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p><ol start="2"><li>协程与普通线程的差异</li></ol><p> 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p><p> 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p><p> Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p><p> 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。</p><ul><li>异步操作的同步化表达</li></ul><p> Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p><p>  function* loadUI() {<br>   showLoadingScreen();<br>   yield loadUIDataAsynchronously();<br>   hideLoadingScreen();<br>  }<br>  var loader &#x3D; loadUI();<br>  &#x2F;&#x2F; 加载UI<br>  loader.next()<br>  &#x2F;&#x2F; 卸载UI<br>  loader.next()</p><p> 上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p><p> Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。</p><p>  function* main() {<br>  var result &#x3D; yield request(“<a href="http://some.url/">http://some.url</a>“);<br>   var resp &#x3D; JSON.parse(result);<br>   console.log(resp.value);<br>  }<br>  function request(url) {<br>   makeAjaxCall(url, function(response){<br>    it.next(response);<br>   });<br>  }<br>  var it &#x3D; main();<br>  it.next();</p><p> 上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。</p><p> 下面是另一个例子，通过Generator函数逐行读取文本文件。</p><p>  function* numbers() {<br>   let file &#x3D; new FileReader(“numbers.txt”);<br>   try {<br>    while(!file.eof) {<br>     yield parseInt(file.readLine(), 10);<br>    }<br>   } finally {<br>    file.close();<br>   }<br>  }</p><p> 上面代码打开文本文件，使用yield语句可以手动逐行读取文件。</p><ul><li>控制流管理</li></ul><p> 如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p><p>  step1(function (value1) {<br>   step2(value1, function(value2) {<br>    step3(value2, function(value3) {<br>     step4(value3, function(value4) {<br>     &#x2F;&#x2F; Do something with value4<br>     });<br>    });<br>   });<br>  });</p><p> 采用Promise改写上面的代码。</p><p> Promise.resolve(step1)<br> .then(step2)<br> .then(step3)<br> .then(step4)<br> .then(function (value4) {<br>  &#x2F;&#x2F; Do something with value4<br> }, function (error) {<br>  &#x2F;&#x2F; Handle any error from step1 through step4<br> })<br> .done();</p><p> 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。</p><p>  function* longRunningTask(value1) {<br>   try {<br>    var value2 &#x3D; yield step1(value1);<br>    var value3 &#x3D; yield step2(value2);<br>    var value4 &#x3D; yield step3(value3);<br>    var value5 &#x3D; yield step4(value4);<br>    &#x2F;&#x2F; Do something with value4<br>   } catch (e) {<br>    &#x2F;&#x2F; Handle any error from step1 through step4<br>   }<br>  }<br> 然后，使用一个函数，按次序自动执行所有步骤。</p><p>  scheduler(longRunningTask(initialValue));<br>  function scheduler(task) {<br>   var taskObj &#x3D; task.next(task.value);<br>   &#x2F;&#x2F; 如果Generator函数未结束，就继续调用<br>   if (!taskObj.done) {<br>    task.value &#x3D; taskObj.value<br>    scheduler(task);<br>   }<br>  }<br> 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。</p><p> 下面，利用for…of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。</p><p>  let steps &#x3D; [step1Func, step2Func, step3Func];<br>  function *iterateSteps(steps){<br>   for (var i&#x3D;0; i&lt; steps.length; i++){<br>    var step &#x3D; steps[i];<br>    yield step();<br>   }<br>  }</p><p> 上面代码中，数组steps封装了一个任务的多个步骤，Generator函数iterateSteps则是依次为这些步骤加上yield命令。</p><p> 将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。</p><p>  let jobs &#x3D; [job1, job2, job3];<br>  function <em>iterateJobs(jobs){<br>   for (var i&#x3D;0; i&lt; jobs.length; i++){<br>    var job &#x3D; jobs[i];<br>yield</em>iterateSteps(job.steps);<br>   }<br>  }</p><p> 上面代码中，数组jobs封装了一个项目的多个任务，Generator函数iterateJobs则是依次为这些任务加上yield *命令。</p><p> 最后，就可以用for…of循环一次性依次执行所有任务的所有步骤。</p><p> for (var step of iterateJobs(jobs)){<br>  console.log(step.id);<br> }</p><p> 再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。</p><p> for…of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。</p><p>  var it &#x3D; iterateJobs(jobs);<br>  var res &#x3D; it.next();<br>  while (!res.done){<br>   var result &#x3D; res.value;<br>   &#x2F;&#x2F; …<br>   res &#x3D; it.next();<br>  }</p><ul><li>部署Iterator接口</li></ul><p> 利用Generator函数，可以在任意对象上部署Iterator接口。</p><p>  function* iterEntries(obj) {<br>   let keys &#x3D; Object.keys(obj);<br>   for (let i&#x3D;0; i &lt; keys.length; i++) {<br>    let key &#x3D; keys[i];<br>    yield [key, obj[key]];<br>   }<br>  }<br>  let myObj &#x3D; { foo: 3, bar: 7 };<br>  for (let [key, value] of iterEntries(myObj)) {<br>   console.log(key, value);<br>  }<br>  &#x2F;&#x2F; foo 3<br>  &#x2F;&#x2F; bar 7</p><p> 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了Iterator接口。也就是说，可以在任意对象上部署next方法。</p><p> 下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。</p><p>  function* makeSimpleGenerator(array){<br>   var nextIndex &#x3D; 0;<br>   while(nextIndex &lt; array.length){<br>    yield array[nextIndex++];<br>   }<br>  }<br>  var gen &#x3D; makeSimpleGenerator([‘yo’, ‘ya’]);<br>  gen.next().value &#x2F;&#x2F; ‘yo’<br>  gen.next().value &#x2F;&#x2F; ‘ya’<br>  gen.next().done &#x2F;&#x2F; true</p><ul><li>作为数据结构</li></ul><p> Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p><p>  function *doStuff() {<br>   yield fs.readFile.bind(null, ‘hello.txt’);<br>   yield fs.readFile.bind(null, ‘world.txt’);<br>   yield fs.readFile.bind(null, ‘and-such.txt’);<br>  }<br> 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。</p><p>  for (task of doStuff()) {<br>   &#x2F;&#x2F; task是一个函数，可以像回调函数那样使用它<br>  }</p><p> 实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。</p><p>  function doStuff() {<br>   return [<br>    fs.readFile.bind(null, ‘hello.txt’),<br>    fs.readFile.bind(null, ‘world.txt’),<br>    fs.readFile.bind(null, ‘and-such.txt’)<br>   ];<br>  }</p><p> 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十四章 iterator(遍历器)的概念</title>
    <link href="/2022/06/27/ECAMScript-fourteen-chart/"/>
    <url>/2022/06/27/ECAMScript-fourteen-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="第十四章-iterator-遍历器-的概念"><a href="#第十四章-iterator-遍历器-的概念" class="headerlink" title="第十四章 iterator(遍历器)的概念"></a>第十四章 iterator(遍历器)的概念</h1><h2 id="Iterator和for…of循环"><a href="#Iterator和for…of循环" class="headerlink" title="Iterator和for…of循环"></a>Iterator和for…of循环</h2><h3 id="Iterator-遍历器-的概念"><a href="#Iterator-遍历器-的概念" class="headerlink" title="Iterator(遍历器)的概念"></a>Iterator(遍历器)的概念</h3><p>JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</p><p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><h4 id="Iterator的作用有三个"><a href="#Iterator的作用有三个" class="headerlink" title="Iterator的作用有三个"></a>Iterator的作用有三个</h4><ol><li><p>一是为各种数据结构，提供一个统一的、简便的访问接口；</p></li><li><p>二是使得数据结构的成员能够按某种次序排列；</p></li><li><p>三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。</p></li></ol><h5 id="Iterator的遍历过程是这样的"><a href="#Iterator的遍历过程是这样的" class="headerlink" title="Iterator的遍历过程是这样的"></a>Iterator的遍历过程是这样的</h5><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p><p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p><p>下面是一个模拟next方法返回值的例子。</p><p> var it &#x3D; makeIterator([‘a’, ‘b’]);<br> it.next() &#x2F;&#x2F; { value: “a”, done: false }<br> it.next() &#x2F;&#x2F; { value: “b”, done: false }<br> it.next() &#x2F;&#x2F; { value: undefined, done: true }</p><p> function makeIterator(array) {</p><p>  var nextIndex &#x3D; 0;</p><p>  return {<br>   next: function() {<br>    return nextIndex &lt; array.length ?<br>      {value: array[nextIndex++], done: false} :<br>      {value: undefined, done: true};<br>      }<br>   };<br> }</p><p>上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[‘a’, ‘b’]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。</p><p>指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。</p><p>next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。</p><p>总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。</p><p>对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。</p><p> function makeIterator(array) {<br>  var nextIndex &#x3D; 0;<br>  return {<br>   next: function() {<br>     return nextIndex &lt; array.length ?<br>     {value: array[nextIndex++]} :<br>     {done: true};<br>     }<br>   };<br> }</p><p>由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。</p><p> var it &#x3D; idMaker();<br> it.next().value &#x2F;&#x2F; ‘0’<br> it.next().value &#x2F;&#x2F; ‘1’<br> it.next().value &#x2F;&#x2F; ‘2’<br> &#x2F;&#x2F; …<br> function idMaker() {<br>  var index &#x3D; 0;<br>  return {<br>   next: function() {<br>    return {value: index++, done: false};<br>   }<br>  };<br> }</p><p>上面的例子中，遍历器生成函数idMaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。</p><p>在ES6中，有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。</p><p>如果使用TypeScript的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。</p><p> interface Iterable {<br>  <a href="">Symbol.iterator</a> : Iterator,<br> }<br> interface Iterator {<br>  next(value?: any) : IterationResult,<br> }<br> interface IterationResult {<br>  value: any,<br>  done: boolean,<br> }</p><h2 id="数据结构的默认Iterator接口"><a href="#数据结构的默认Iterator接口" class="headerlink" title="数据结构的默认Iterator接口"></a>数据结构的默认Iterator接口</h2><p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p><p>ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。调用Symbol.iterator方法，就会得到当前数据结构默认的遍历器生成函数。Symbol.iterator本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内（请参考Symbol一章）。</p><p>在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</p><p> let arr &#x3D; [‘a’, ‘b’, ‘c’];<br> let iter &#x3D; arr<a href="">Symbol.iterator</a>;<br> iter.next() &#x2F;&#x2F; { value: ‘a’, done: false }<br> iter.next() &#x2F;&#x2F; { value: ‘b’, done: false }<br> iter.next() &#x2F;&#x2F; { value: ‘c’, done: false }<br> iter.next() &#x2F;&#x2F; { value: undefined, done: true }</p><p>上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。</p><p>上面提到，原生就部署Iterator接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。</p><p>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。</p><p>一个对象如果要有可被for…of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p><p> class RangeIterator {<br>  constructor(start, stop) {<br>   this.value &#x3D; start;<br>   this.stop &#x3D; stop;<br>  }<br>  <a href="">Symbol.iterator</a> { return this; }<br>  next() {<br>   var value &#x3D; this.value;<br>   if (value &lt; this.stop) {<br>    this.value++;<br>    return {done: false, value: value};<br>   } else {<br>    return {done: true, value: undefined};<br>   }<br>  }<br> }<br> function range(start, stop) {<br>  return new RangeIterator(start, stop);<br> }<br> for (var value of range(0, 3)) {<br>  console.log(value);<br> }<br>上面代码是一个类部署Iterator接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。</p><p>下面是通过遍历器实现指针结构的例子。</p><p> function Obj(value) {<br>  this.value &#x3D; value;<br>  this.next &#x3D; null;<br> }<br> Obj.prototype[Symbol.iterator] &#x3D; function() {<br>  var iterator &#x3D; {<br>   next: next<br>  };<br>  var current &#x3D; this;<br>  function next() {<br>   if (current) {<br>    var value &#x3D; current.value;<br>    current &#x3D; current.next;<br>    return {<br>     done: false,<br>     value: value<br>    };<br>   } else {<br>    return {<br>     done: true<br>    };<br>   }<br>  }<br>  return iterator;<br> }<br> var one &#x3D; new Obj(1);<br> var two &#x3D; new Obj(2);<br> var three &#x3D; new Obj(3);<br> one.next &#x3D; two;<br> two.next &#x3D; three;<br> for (var i of one){<br>  console.log(i);<br> }<br> &#x2F;&#x2F; 1<br> &#x2F;&#x2F; 2<br> &#x2F;&#x2F; 2<br> &#x2F;&#x2F; 3</p><p>上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍历器对象iterator，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。<br>下面是另一个为对象添加Iterator接口的例子。</p><p> let obj &#x3D; {<br>  data: [ ‘hello’, ‘world’ ],<br>  <a href="">Symbol.iterator</a> {<br>   const self &#x3D; this;<br>   let index &#x3D; 0;<br>   return {<br>    next() {<br>     if (index &lt; self.data.length) {<br>      return {<br>       value: self.data[index++],<br>       done: false<br>      };<br>     } else {<br>      return { value: undefined, done: true };<br>     }<br>    }<br>   };<br>  }<br> };</p><p>对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口。</p><p> NodeList.prototype[Symbol.iterator] &#x3D; Array.prototype[Symbol.iterator];<br> &#x2F;&#x2F; 或者<br> NodeList.prototype[Symbol.iterator] &#x3D; [][Symbol.iterator];<br> […document.querySelectorAll(‘div’)] &#x2F;&#x2F; 可以执行了</p><p>下面是类似数组的对象调用数组的Symbol.iterator方法的例子。</p><p> let iterable &#x3D; {<br>  0: ‘a’,<br>  1: ‘b’,<br>  2: ‘c’,<br>  length: 3,<br>  [Symbol.iterator]: Array.prototype[Symbol.iterator]<br> };<br> for (let item of iterable) {<br>  console.log(item); &#x2F;&#x2F; ‘a’, ‘b’, ‘c’<br> }</p><p>注意，普通对象部署数组的Symbol.iterator方法，并无效果。</p><p> let iterable &#x3D; {<br>  a: ‘a’,<br>  b: ‘b’,<br>  c: ‘c’,<br>  length: 3,<br>  [Symbol.iterator]: Array.prototype[Symbol.iterator]<br> };<br> for (let item of iterable) {<br>  console.log(item); &#x2F;&#x2F; undefined, undefined, undefined<br> }</p><p>如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。</p><p> var obj &#x3D; {};<br> obj[Symbol.iterator] &#x3D; () &#x3D;&gt; 1;<br> […obj] &#x2F;&#x2F; TypeError: [] is not a function</p><p>上面代码中，变量obj的Symbol.iterator方法对应的不是遍历器生成函数，因此报错。<br>有了遍历器接口，数据结构就可以用for…of循环遍历（详见下文），也可以使用while循环遍历。</p><p> var $iterator &#x3D; ITERABLE<a href="">Symbol.iterator</a>;<br> var $result &#x3D; $iterator.next();<br> while (!$result.done) {<br>  var x &#x3D; $result.value;<br>  &#x2F;&#x2F; …<br>  $result &#x3D; $iterator.next();<br> }</p><p>上面代码中，ITERABLE代表某种可遍历的数据结构，$iterator是它的遍历器对象。遍历器对象每次移动指针（next方法），都检查一下返回值的done属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（next方法），不断循环。</p><h2 id="调用Iterator接口的场合"><a href="#调用Iterator接口的场合" class="headerlink" title="调用Iterator接口的场合"></a>调用Iterator接口的场合</h2><p>有一些场合会默认调用Iterator接口（即Symbol.iterator方法），除了下文会介绍的for…of循环，还有几个别的场合。</p><ol><li>解构赋值</li></ol><p> 对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。</p><p>  let set &#x3D; new Set().add(‘a’).add(‘b’).add(‘c’);<br>  let [x,y] &#x3D; set;<br>  &#x2F;&#x2F; x&#x3D;’a’; y&#x3D;’b’<br>  let [first, …rest] &#x3D; set;<br>  &#x2F;&#x2F; first&#x3D;’a’; rest&#x3D;[‘b’,’c’];</p><ol start="2"><li>扩展运算符</li></ol><p> 扩展运算符（…）也会调用默认的iterator接口。</p><p>  &#x2F;&#x2F; 例一<br>  var str &#x3D; ‘hello’;<br>  […str] &#x2F;&#x2F; [‘h’,’e’,’l’,’l’,’o’]<br>  &#x2F;&#x2F; 例二<br>  let arr &#x3D; [‘b’, ‘c’];<br>  [‘a’, …arr, ‘d’]<br>  &#x2F;&#x2F; [‘a’, ‘b’, ‘c’, ‘d’]</p><p> 上面代码的扩展运算符内部就调用Iterator接口。</p><p> 实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。</p><p>  let arr &#x3D; […iterable];</p><ol start="3"><li>yield*</li></ol><p> yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><p>  let generator &#x3D; function*() {<br>   yield 1;<br>   yield* [2,3,4];<br>   yield 5;<br>  };<br>  var iterator &#x3D; generator();<br>  iterator.next() &#x2F;&#x2F; { value: 1, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: 2, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: 3, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: 4, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: 5, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: undefined, done: true }</p><ol start="4"><li>其他场合</li></ol><p> 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。<br>  for…of<br>  Array.from()<br>  Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）<br>  Promise.all()<br>  Promise.race()</p><ol start="5"><li>字符串的Iterator接口</li></ol><p> 字符串是一个类似数组的对象，也原生具有Iterator接口。</p><p>  var someString &#x3D; “hi”;<br>  typeof someString[Symbol.iterator]<br>  &#x2F;&#x2F; “function”<br>  var iterator &#x3D; someString<a href="">Symbol.iterator</a>;<br>  iterator.next() &#x2F;&#x2F; { value: “h”, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: “i”, done: false }<br>  iterator.next() &#x2F;&#x2F; { value: undefined, done: true }</p><p>上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。</p><p>可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。</p><p>  var str &#x3D; new String(“hi”);<br>  […str] &#x2F;&#x2F; [“h”, “i”]<br>  str[Symbol.iterator] &#x3D; function() {<br>   return {<br>    next: function() {<br>     if (this._first) {<br>      this._first &#x3D; false;<br>      return { value: “bye”, done: false };<br>     } else {<br>      return { done: true };<br>     }<br>    },<br>    _first: true<br>   };<br>  };<br>  […str] &#x2F;&#x2F; [“bye”]<br>  str &#x2F;&#x2F; “hi”</p><p>上面代码中，字符串str的Symbol.iterator方法被修改了，所以扩展运算符（…）返回的值变成了bye，而字符串本身还是hi。</p><h2 id="Iterator接口与Generator函数"><a href="#Iterator接口与Generator函数" class="headerlink" title="Iterator接口与Generator函数"></a>Iterator接口与Generator函数</h2><p>Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。</p><p> var myIterable &#x3D; {};<br> myIterable[Symbol.iterator] &#x3D; function* () {<br>  yield 1;<br>  yield 2;<br>  yield 3;<br> };<br> […myIterable] &#x2F;&#x2F; [1, 2, 3]<br> &#x2F;&#x2F; 或者采用下面的简洁写法<br> let obj &#x3D; {</p><ul><li><a href="">Symbol.iterator</a> {<br>yield ‘hello’;<br>yield ‘world’;<br>}<br> };<br> for (let x of obj) {<br>console.log(x);<br> }<br> &#x2F;&#x2F; hello<br> &#x2F;&#x2F; world</li></ul><p>上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。</p><h2 id="遍历器对象的return-，throw"><a href="#遍历器对象的return-，throw" class="headerlink" title="遍历器对象的return()，throw()"></a>遍历器对象的return()，throw()</h2><p>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</p><p>return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。</p><p> function readLinesSync(file) {<br>  return {<br>   next() {<br>    if (file.isAtEndOfFile()) {<br>     file.close();<br>     return { done: true };<br>    }<br>   },<br>   return() {<br>    file.close();<br>    return { done: true };<br>   },<br>  };<br> }</p><p>上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面，我们让文件的遍历提前返回，这样就会触发执行return方法。</p><p> for (let line of readLinesSync(fileName)) {<br>  console.log(x);<br>  break;<br> }</p><p>注意，return方法必须返回一个对象，这是Generator规格决定的。</p><p>throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator函数》一章。</p><h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>ES6借鉴C++、Java、C#和Python语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的Symbol.iterator方法。</p><p>for…of循环可以使用的范围包括数组、Set和Map结构、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组原生具备iterator接口，for…of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。</p><p> const arr &#x3D; [‘red’, ‘green’, ‘blue’];<br> let iterator &#x3D; arr<a href="">Symbol.iterator</a>;<br> for(let v of arr) {<br>  console.log(v); &#x2F;&#x2F; red green blue<br> }<br> for(let v of iterator) {<br>  console.log(v); &#x2F;&#x2F; red green blue<br> }<br>上面代码的for…of循环的两种写法是等价的。</p><p>for…of循环可以代替数组实例的forEach方法。</p><p> const arr &#x3D; [‘red’, ‘green’, ‘blue’];<br> arr.forEach(function (element, index) {<br>  console.log(element); &#x2F;&#x2F; red green blue<br>  console.log(index); &#x2F;&#x2F; 0 1 2<br> });<br>JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。</p><p> var arr &#x3D; [‘a’, ‘b’, ‘c’, ‘d’];<br> for (let a in arr) {<br>  console.log(a); &#x2F;&#x2F; 0 1 2 3<br> }<br> for (let a of arr) {<br>  console.log(a); &#x2F;&#x2F; a b c d<br> }</p><p>上面代码表明，for…in循环读取键名，for…of循环读取键值。如果要通过for…of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。</p><p>for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for…in循环也不一样。</p><p> let arr &#x3D; [3, 5, 7];<br> arr.foo &#x3D; ‘hello’;<br> for (let i in arr) {<br>  console.log(i); &#x2F;&#x2F; “0”, “1”, “2”, “foo”<br> }<br> for (let i of arr) {<br>  console.log(i); &#x2F;&#x2F; “3”, “5”, “7”<br> }</p><p>上面代码中，for…of循环不会返回数组arr的foo属性。</p><h3 id="Set和Map结构"><a href="#Set和Map结构" class="headerlink" title="Set和Map结构"></a>Set和Map结构</h3><p>Set和Map结构也原生具有Iterator接口，可以直接使用for…of循环。</p><p> var engines &#x3D; new Set([“Gecko”, “Trident”, “Webkit”, “Webkit”]);<br> for (var e of engines) {<br>  console.log(e);<br> }<br> &#x2F;&#x2F; Gecko<br> &#x2F;&#x2F; Trident<br> &#x2F;&#x2F; Webkit<br> var es6 &#x3D; new Map();<br> es6.set(“edition”, 6);<br> es6.set(“committee”, “TC39”);<br> es6.set(“standard”, “ECMA-262”);<br> for (var [name, value] of es6) {<br>  console.log(name + “: “ + value);<br> }<br> &#x2F;&#x2F; edition: 6<br> &#x2F;&#x2F; committee: TC39<br> &#x2F;&#x2F; standard: ECMA-262</p><p>上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。</p><p> let map &#x3D; new Map().set(‘a’, 1).set(‘b’, 2);<br> for (let pair of map) {<br>  console.log(pair);<br> }<br> &#x2F;&#x2F; [‘a’, 1]<br> &#x2F;&#x2F; [‘b’, 2]<br> for (let [key, value] of map) {<br>  console.log(key + ‘ : ‘ + value);<br> }<br> &#x2F;&#x2F; a : 1<br> &#x2F;&#x2F; b : 2</p><h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。</p><p> entries()<br> 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法。<br> keys()<br> 返回一个遍历器对象，用来遍历所有的键名。<br> values()<br> 返回一个遍历器对象，用来遍历所有的键值。</p><p>这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。</p><p> let arr &#x3D; [‘a’, ‘b’, ‘c’];<br> for (let pair of arr.entries()) {<br>  console.log(pair);<br> }<br> &#x2F;&#x2F; [0, ‘a’]<br> &#x2F;&#x2F; [1, ‘b’]<br> &#x2F;&#x2F; [2, ‘c’]</p><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>类似数组的对象包括好几类。下面是for…of循环用于字符串、DOM NodeList对象、arguments对象的例子。</p><p> &#x2F;&#x2F; 字符串<br> let str &#x3D; “hello”;<br> for (let s of str) {<br>  console.log(s); &#x2F;&#x2F; h e l l o<br> }<br> &#x2F;&#x2F; DOM NodeList对象<br> let paras &#x3D; document.querySelectorAll(“p”);<br> for (let p of paras) {<br>  p.classList.add(“test”);<br> }<br> &#x2F;&#x2F; arguments对象<br> function printArgs() {<br>  for (let x of arguments) {<br>   console.log(x);<br>  }<br> }<br> printArgs(‘a’, ‘b’);<br> &#x2F;&#x2F; ‘a’<br> &#x2F;&#x2F; ‘b’<br> 对于字符串来说，for…of循环还有一个特点，就是会正确识别32位UTF-16字符。<br> for (let x of ‘a\uD83D\uDC0A’) {<br>  console.log(x);<br> }<br> &#x2F;&#x2F; ‘a’<br> &#x2F;&#x2F; ‘\uD83D\uDC0A’</p><p>并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</p><p> let arrayLike &#x3D; { length: 2, 0: ‘a’, 1: ‘b’ };<br> &#x2F;&#x2F; 报错<br> for (let x of arrayLike) {<br>  console.log(x);<br> }<br> &#x2F;&#x2F; 正确<br> for (let x of Array.from(arrayLike)) {<br>  console.log(x);<br> }</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。</p><p> var es6 &#x3D; {<br>  edition: 6,<br>  committee: “TC39”,<br>  standard: “ECMA-262”<br> };<br> for (e in es6) {<br>  console.log(e);<br> }<br> &#x2F;&#x2F; edition<br> &#x2F;&#x2F; committee<br> &#x2F;&#x2F; standard<br> for (e of es6) {<br>  console.log(e);<br> }<br> &#x2F;&#x2F; TypeError: es6 is not iterable</p><p>上面代码表示，对于普通的对象，for…in循环可以遍历键名，for…of循环会报错。</p><p>一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。</p><p> for (var key of Object.keys(someObject)) {<br>  console.log(key + “: “ + someObject[key]);<br> }</p><p>在对象上部署iterator接口的代码，参见本章前面部分。一个方便的方法是将数组的Symbol.iterator属性，直接赋值给其他对象的Symbol.iterator属性。比如，想要让for…of环遍历jQuery对象，只要加上下面这一行就可以了。</p><p> jQuery.prototype[Symbol.iterator] &#x3D;<br> Array.prototype[Symbol.iterator];</p><p>另一个方法是使用Generator函数将对象重新包装一下。</p><p> function* entries(obj) {<br>  for (let key of Object.keys(obj)) {<br>   yield [key, obj[key]];<br>  }<br> }<br> for (let [key, value] of entries(obj)) {<br>  console.log(key, “-&gt;”, value);<br> }<br> &#x2F;&#x2F; a -&gt; 1<br> &#x2F;&#x2F; b -&gt; 2<br> &#x2F;&#x2F; c -&gt; 3</p><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><p>以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。</p><p> for (var index &#x3D; 0; index &lt; myArray.length; index++) {<br>  console.log(myArray[index]);<br> }</p><p>这种写法比较麻烦，因此数组提供内置的forEach方法。</p><p> myArray.forEach(function (value) {<br>  console.log(value);<br> });</p><p>这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。</p><p> for…in循环可以遍历数组的键名。<br> for (var index in myArray) {<br>  console.log(myArray[index]);<br> }</p><h3 id="for…in循环有几个缺点。"><a href="#for…in循环有几个缺点。" class="headerlink" title="for…in循环有几个缺点。"></a><strong>for…in循环有几个缺点。</strong></h3><p>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</p><p>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</p><p>某些情况下，for…in循环会以任意顺序遍历键名。</p><p>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</p><p> for…of循环相比上面几种做法，有一些显著的优点。<br> for (let value of myArray) {<br>  console.log(value);<br> }</p><p>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</p><p>不同用于forEach方法，它可以与break、continue和return配合使用。</p><p>提供了遍历所有数据结构的统一操作接口。</p><p>下面是一个使用break语句，跳出for…of循环的例子。</p><p> for (var n of fibonacci) {<br>  if (n &gt; 1000)<br>   break;<br>  console.log(n);<br> }</p><p>上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for…of循环。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第十二章 二进制数组</title>
    <link href="/2022/06/24/ECAMScript-twelve-chart/"/>
    <url>/2022/06/24/ECAMScript-twelve-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h1><p>二进制数组（ArrayBuffer对象、TypedArray视图和DataView视图）是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格（2011年2月发布），ES6将它们纳入了ECMAScript规格，并且增加了新的方法。</p><p>这个接口的原始设计目的，与WebGL项目有关。所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。</p><p>二进制数组就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了JavaScript处理二进制数据的能力，使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信。</p><h3 id="二进制数组由三类对象组成"><a href="#二进制数组由三类对象组成" class="headerlink" title="二进制数组由三类对象组成"></a>二进制数组由三类对象组成</h3><ol><li><p>ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内<br>存。</p></li><li><p>TypedArray视图：共包括9种类型的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图,Float32Array（32位浮点数）数组视图等等。</p></li><li><p>DataView视图：可以自定义复合格式的视图，比如第一个字节是Uint8（无符号8位整数）、第二、三个字节是Int16（16位整数）、第四个字节开始是Float32（32位浮点数）等等，此外还可以自定义字节序。</p></li></ol><h5 id="注意，二进制数组并不是真正的数组，而是类似数组的对象。"><a href="#注意，二进制数组并不是真正的数组，而是类似数组的对象。" class="headerlink" title="注意，二进制数组并不是真正的数组，而是类似数组的对象。"></a><code>注意，二进制数组并不是真正的数组，而是类似数组的对象。</code></h5><p>TypedArray视图支持的数据类型一共有9种（DataView视图支持除Uint8C以外的其他8种）。</p><p> 数据类型  字节长度  含义        对应的C语言类型<br> Int8   1    8位带符号整数      signed char<br> Uint8   1    8位不带符号整数      unsigned char<br> Uint8C   1    8位不带符号整数（自动过滤溢出）  unsigned char<br> Int16    2    16位带符号整数      short<br> Uint16   2    16位不带符号整数      unsigned short<br> Int32    4    32位带符号整数      int<br> Uint32   4   32位不带符号的整数     unsigned int<br> Float32   4    32位浮点数       float<br> Float64   8    64位浮点数       double</p><h2 id="ArrayBuffer对象"><a href="#ArrayBuffer对象" class="headerlink" title="ArrayBuffer对象"></a>ArrayBuffer对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。</p><p>ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p><p> var buf &#x3D; new ArrayBuffer(32);<br>上面代码生成了一段32字节的内存区域，每个字节的值默认都是0。可以看到，ArrayBuffer构造函数的参数是所需要的内存大小（单位字节）。为了读写这段内容，需要为它指定视图。DataView视图的创建，需要提供ArrayBuffer对象实例作为参数。</p><p> var buf &#x3D; new ArrayBuffer(32);<br> var dataView &#x3D; new DataView(buf);<br> dataView.getUint8(0) &#x2F;&#x2F; 0</p><p>上面代码对一段32字节的内存，建立DataView视图，然后以不带符号的8位整数格式，读取第一个元素，结果得到0，因为原始内存的ArrayBuffer对象，默认所有位都是0。</p><h4 id="ArrayBufer-prototype-byteLength"><a href="#ArrayBufer-prototype-byteLength" class="headerlink" title="ArrayBufer.prototype.byteLength"></a>ArrayBufer.prototype.byteLength</h4><p>ArrayBuffer实例的byteLength属性，返回所分配的内存区域的字节长度。</p><p> var buffer &#x3D; new ArrayBuffer(32);<br> buffer.byteLength<br> &#x2F;&#x2F;32<br>如果要分配的内存区域很大，有可能分配失败(所以有必要检查是否分配成功)</p><p> if(buffer.byteLength &#x3D;&#x3D;&#x3D; n){<br>  &#x2F;&#x2F;成功<br> }else {<br>  &#x2F;&#x2F;失败<br> }</p><h4 id="ArrayBuffer-prototype-slice"><a href="#ArrayBuffer-prototype-slice" class="headerlink" title="ArrayBuffer.prototype.slice()"></a>ArrayBuffer.prototype.slice()</h4><p><code>ArrayBuffer</code>实例有一个slice方法，允许将内存区域的一部分，拷贝成一个新的ArrayBuffer对象。</p><p> var buffer &#x3D; new ArrayBuffer(8);<br> var newBuffer &#x3D; buffer.slice(0, 3);</p><p>上面代码拷贝buffer对象的前3个字节（从0开始，到第3个字节前面结束），生成一个新的ArrayBuffer对象。slice方法其实包含两步，第一步是先分配一段新内存，第二步是将原来那个ArrayBuffer对象拷贝过去。slice方法接受两个参数，第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。如果省略第二个参数，则默认到原ArrayBuffer对象的结尾。</p><p>除了slice方法，ArrayBuffer对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写。</p><h4 id="ArrayBuffer-isView"><a href="#ArrayBuffer-isView" class="headerlink" title="ArrayBuffer.isView()"></a>ArrayBuffer.isView()</h4><p>ArrayBuffer有一个静态方法isView，返回一个布尔值，表示参数是否为ArrayBuffer的视图实例。这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。</p><p> var buffer &#x3D; new ArrayBuffer(8);<br> ArrayBuffer.isView(buffer) &#x2F;&#x2F; false<br> var v &#x3D; new Int32Array(buffer);<br> ArrayBuffer.isView(v) &#x2F;&#x2F; true</p><h2 id="TypedArray视图"><a href="#TypedArray视图" class="headerlink" title="TypedArray视图"></a>TypedArray视图</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>ArrayBuffer对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer有两种视图，一种是TypedArray视图，另一种是DataView视图。</p><p>前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。目前，TypedArray视图一共包括9种类型，每一种视图都是一种构造函数。Int8Array：8位有符号整数，长度1个字节。</p><ul><li>Uint8Array：8位无符号整数，长度1个字节。</li><li>Uint8ClampedArray：8位无符号整数，长度1个字节，溢出处理不同。</li><li>Int16Array：16位有符号整数，长度2个字节。</li><li>Uint16Array：16位无符号整数，长度2个字节。</li><li>Int32Array：32位有符号整数，长度4个字节。</li><li>Uint32Array：32位无符号整数，长度4个字节。</li><li>Float32Array：32位浮点数，长度4个字节。</li><li>Float64Array：64位浮点数，长度8个字节。</li></ul><p>这9个构造函数生成的数组，统称为TypedArray视图。它们很像普通数组，都有length属性，都能用方括号运算符（[]）获取单个元素，所有数组的<br>方法，在它们上面都能使用。普通数组与TypedArray数组的差异主要在以下方面。</p><ul><li>TypedArray数组的所有成员，都是同一种类型。</li><li>TypedArray数组的成员是连续的，不会有空位。</li><li>TypedArray数组成员的默认值为0。比如，new Array(10)返回一个普通数组，里面没有任何成员，只是10个空位；new Uint8Array(10)返回一个</li><li>TypedArray数组，里面10个成员都是0。</li><li>TypedArray数组只是一层视图，本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>TypedArray数组提供9种构造函数，用来生成相应类型的数组实例。<br>构造函数有多种用法。</p><ol><li>TypedArray(buffer, byteOffset&#x3D;0, length?)</li></ol><p> 同一个ArrayBuffer对象之上，可以根据不同的数据类型，建立多个视图。</p><p>  &#x2F;&#x2F; 创建一个8字节的ArrayBuffer<br>  var b &#x3D; new ArrayBuffer(8);<br>  &#x2F;&#x2F; 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾<br>  var v1 &#x3D; new Int32Array(b);<br>  &#x2F;&#x2F; 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾<br>  var v2 &#x3D; new Uint8Array(b, 2);<br>  &#x2F;&#x2F; 创建一个指向b的Int16视图，开始于字节2，长度为2<br>  var v3 &#x3D; new Int16Array(b, 2, 2);<br>  上面代码在一段长度为8个字节的内存（b）之上，生成了三个视图：v1、v2和v3。</p><p> 视图的构造函数可以接受三个参数：</p><p> 第一个参数（必需）：视图对应的底层ArrayBuffer对象。</p><p> 第二个参数（可选）：视图开始的字节序号，默认从0开始。</p><p> 第三个参数（可选）：视图包含的数据个数，默认直到本段内存区域结束。</p><ol start="2"><li>TypedArray(length)</li></ol><p> 视图还可以不通过ArrayBuffer对象，直接分配内存而生成。</p><p>  var f64a &#x3D; new Float64Array(8);<br>  f64a[0] &#x3D; 10;<br>  f64a[1] &#x3D; 20;<br>  f64a[2] &#x3D; f64a[0] + f64a[1];</p><p> 上面代码生成一个8个成员的Float64Array数组（共64字节），然后依次对每个成员赋值。这时，视图构造函数的参数就是成员的个数。可以看到，视图数组的赋值操作与普通数组的操作毫无两样。</p><ol start="3"><li>TypedArray(typedArray)</li></ol><p> TypedArray数组的构造函数，可以接受另一个TypedArray实例作为参数。</p><p>  var typedArray &#x3D; new Int8Array(new Uint8Array(4));</p><p> 上面代码中，Int8Array构造函数接受一个Uint8Array实例作为参数。</p><p> 注意，此时生成的新数组，只是复制了参数数组的值，对应的底层内存是不一样的。新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图。</p><p>  var x &#x3D; new Int8Array([1, 1]);<br>  var y &#x3D; new Int8Array(x);<br>  x[0] &#x2F;&#x2F; 1<br>  y[0] &#x2F;&#x2F; 1<br>  x[0] &#x3D; 2;<br>  y[0] &#x2F;&#x2F; 1<br> 上面代码中，数组y是以数组x为模板而生成的，当x变动的时候，y并没有变动。<br> 如果想基于同一段内存，构造不同的视图，可以采用下面的写法。</p><p>  var x &#x3D; new Int8Array([1, 1]);<br>  var y &#x3D; new Int8Array(x.buffer);<br>  x[0] &#x2F;&#x2F; 1<br>  y[0] &#x2F;&#x2F; 1<br>  x[0] &#x3D; 2;<br>  y[0] &#x2F;&#x2F; 2</p><ol start="4"><li>TypedArray(arrayLikeObject)</li></ol><p> 构造函数的参数也可以是一个普通数组，然后直接生成TypedArray实例。</p><p>  var typedArray &#x3D; new Uint8Array([1, 2, 3, 4]);<br> 注意，这时TypedArray视图会重新开辟内存，不会在原数组的内存上建立视图。</p><p> 上面代码从一个普通的数组，生成一个8位无符号整数的TypedArray实例。<br> TypedArray数组也可以转换回普通数组。</p><p>  var normalArray &#x3D; Array.prototype.slice.call(typedArray);</p><h2 id="12-2-3-数组方法"><a href="#12-2-3-数组方法" class="headerlink" title="12.2.3 数组方法"></a>12.2.3 数组方法</h2><p>普通数组的操作方法和属性，对TypedArray数组完全适用。</p><ul><li>TypedArray.prototype.copyWithin(target, start[, end &#x3D; this.length])</li><li>TypedArray.prototype.entries()</li><li>TypedArray.prototype.every(callbackfn, thisArg?)</li><li>TypedArray.prototype.fill(value, start&#x3D;0, end&#x3D;this.length)</li><li>TypedArray.prototype.filter(callbackfn, thisArg?)</li><li>TypedArray.prototype.find(predicate, thisArg?)</li><li>TypedArray.prototype.findIndex(predicate, thisArg?)</li><li>TypedArray.prototype.forEach(callbackfn, thisArg?)</li><li>TypedArray.prototype.indexOf(searchElement, fromIndex&#x3D;0)</li><li>TypedArray.prototype.join(separator)</li><li>TypedArray.prototype.keys()</li><li>TypedArray.prototype.lastIndexOf(searchElement, fromIndex?)</li><li>TypedArray.prototype.map(callbackfn, thisArg?)</li><li>TypedArray.prototype.reduce(callbackfn, initialValue?)</li><li>TypedArray.prototype.reduceRight(callbackfn, initialValue?)</li><li>TypedArray.prototype.reverse()</li><li>TypedArray.prototype.slice(start&#x3D;0, end&#x3D;this.length)</li><li>TypedArray.prototype.some(callbackfn, thisArg?)</li><li>TypedArray.prototype.sort(comparefn)</li><li>TypedArray.prototype.toLocaleString(reserved1?, reserved2?)</li><li>TypedArray.prototype.toString()</li><li>TypedArray.prototype.values()</li><li></li></ul><p>上面所有方法的用法，请参阅数组方法的介绍，这里不再重复了。</p><p>注意，TypedArray数组没有concat方法。如果想要合并多个TypedArray数组，可以用下面这个函数。</p><p> function concatenate(resultConstructor, …arrays) {<br>  let totalLength &#x3D; 0;<br>  for (let arr of arrays) {<br>   totalLength +&#x3D; arr.length;<br>  }<br>  let result &#x3D; new resultConstructor(totalLength);<br>  let offset &#x3D; 0;<br>  for (let arr of arrays) {<br>   result.set(arr, offset);<br>   offset +&#x3D; arr.length;<br>  }<br>  return result;<br> }<br> concatenate(Uint8Array, Uint8Array.of(1, 2), Uint8Array.of(3, 4))<br> &#x2F;&#x2F; Uint8Array [1, 2, 3, 4]</p><p>另外，TypedArray数组与普通数组一样，部署了Iterator接口，所以可以被遍历。</p><p>let ui8 &#x3D; Uint8Array.of(0, 1, 2);<br> for (let byte of ui8) {<br>  console.log(byte);<br> }<br> &#x2F;&#x2F; 0<br> &#x2F;&#x2F; 1<br> &#x2F;&#x2F; 2</p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序指的是数值在内存中的表示方式。</p><p> var buffer &#x3D; new ArrayBuffer(16);<br> var int32View &#x3D; new Int32Array(buffer);<br> for (var i &#x3D; 0; i &lt; int32View.length; i++) {<br>  int32View[i] &#x3D; i * 2;<br> }</p><p>上面代码生成一个16字节的ArrayBuffer对象，然后在它的基础上，建立了一个32位整数的视图。由于每个32位整数占据4个字节，所以一共可以写入4个整数，依次为0，2，4，6。</p><p>如果在这段数据上接着建立一个16位整数的视图，则可以读出完全不一样的结果。</p><p> var int16View &#x3D; new Int16Array(buffer);<br> for (var i &#x3D; 0; i &lt; int16View.length; i++) {<br> console.log(“Entry “ + i + “: “ + int16View[i]);<br> }<br> &#x2F;&#x2F; Entry 0: 0<br> &#x2F;&#x2F; Entry 1: 0<br> &#x2F;&#x2F; Entry 2: 2<br> &#x2F;&#x2F; Entry 3: 0<br> &#x2F;&#x2F; Entry 4: 4<br> &#x2F;&#x2F; Entry 5: 0<br> &#x2F;&#x2F; Entry 6: 6<br> &#x2F;&#x2F; Entry 7: 0</p><p>由于每个16位整数占据2个字节，所以整个ArrayBuffer对象现在分成8段。然后，由于x86体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，所以就得到了上面的结果。</p><p>比如，一个占据四个字节的16进制数0x12345678，决定其大小的最重要的字节是“12”，最不重要的是“78”。小端字节序将最不重要的字节排在前面，储存顺序就是78563412；大端字节序则完全相反，将最重要的字节排在前面，储存顺序就是12345678。目前，所有个人电脑几乎都是小端字节序，所以TypedArray数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p><p>这并不意味大端字节序不重要，事实上，很多网络设备和特定的操作系统采用的是大端字节序。这就带来一个严重的问题：如果一段数据是大端字节序，TypedArray数组将无法正确解析，因为它只能处理小端字节序！为了解决这个问题，JavaScript引入DataView对象，可以设定字节序。</p><p> &#x2F;&#x2F; 假定某段buffer包含如下字节 [0x02, 0x01, 0x03, 0x07]<br> var buffer &#x3D; new ArrayBuffer(4);<br> var v1 &#x3D; new Uint8Array(buffer);<br> v1[0] &#x3D; 2;<br> v1[1] &#x3D; 1;<br> v1[2] &#x3D; 3;<br> v1[3] &#x3D; 7;<br> var uInt16View &#x3D; new Uint16Array(buffer);<br> &#x2F;&#x2F; 计算机采用小端字节序<br> &#x2F;&#x2F; 所以头两个字节等于258<br> if (uInt16View[0] &#x3D;&#x3D;&#x3D; 258) {<br>  console.log(‘OK’); &#x2F;&#x2F; “OK”<br> }<br> &#x2F;&#x2F; 赋值运算<br> uInt16View[0] &#x3D; 255; &#x2F;&#x2F; 字节变为[0xFF, 0x00, 0x03, 0x07]<br> uInt16View[0] &#x3D; 0xff05; &#x2F;&#x2F; 字节变为[0x05, 0xFF, 0x03, 0x07]<br> uInt16View[1] &#x3D; 0x0210; &#x2F;&#x2F; 字节变为[0x05, 0xFF, 0x10, 0x02]</p><p>下面的函数可以用来判断，当前视图是小端字节序，还是大端字节序。</p><p> const BIG_ENDIAN &#x3D; Symbol(‘BIG_ENDIAN’);<br> const LITTLE_ENDIAN &#x3D; Symbol(‘LITTLE_ENDIAN’);<br> function getPlatformEndianness() {<br>  let arr32 &#x3D; Uint32Array.of(0x12345678);<br>  let arr8 &#x3D; new Uint8Array(arr32.buffer);<br>  switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100) + (arr8[3])) {<br>   case 0x12345678:<br>   return BIG_ENDIAN;<br>   case 0x78563412:<br>   return LITTLE_ENDIAN;<br>   default:<br>   throw new Error(‘Unknown endianness’);<br>  }<br> }<br>总之，与普通数组相比，TypedArray数组的最大优点就是可以直接操作内存，不需要数据类型转换，所以速度快得多。</p><h3 id="BYTES-PER-ELEMENT属性"><a href="#BYTES-PER-ELEMENT属性" class="headerlink" title="BYTES_PER_ELEMENT属性"></a>BYTES_PER_ELEMENT属性</h3><p>每一种视图的构造函数，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数。</p><p> Int8Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 1<br> Uint8Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 1<br> Int16Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 2<br> Uint16Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 2<br> Int32Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 4<br> Uint32Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 4<br> Float32Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 4<br> Float64Array.BYTES_PER_ELEMENT &#x2F;&#x2F; 8</p><p>这个属性在TypedArray实例上也能获取，即有TypedArray.prototype.BYTES_PER_ELEMENT。</p><h3 id="ArrayBuffer与字符串的互相转换"><a href="#ArrayBuffer与字符串的互相转换" class="headerlink" title="ArrayBuffer与字符串的互相转换"></a>ArrayBuffer与字符串的互相转换</h3><p>ArrayBuffer转为字符串，或者字符串转为ArrayBuffer，有一个前提，即字符串的编码方法是确定的。假定字符串采用UTF-16编码（JavaScript的内部编码方式），可以自己编写转换函数。</p><p> &#x2F;&#x2F; ArrayBuffer转为字符串，参数为ArrayBuffer对象<br> function ab2str(buf) {<br>  return String.fromCharCode.apply(null, new Uint16Array(buf));<br> }<br> &#x2F;&#x2F; 字符串转为ArrayBuffer对象，参数为字符串<br> function str2ab(str) {<br>  var buf &#x3D; new ArrayBuffer(str.length * 2); &#x2F;&#x2F; 每个字符占用2个字节<br>  var bufView &#x3D; new Uint16Array(buf);<br>  for (var i &#x3D; 0, strLen &#x3D; str.length; i &lt; strLen; i++) {<br>   bufView[i] &#x3D; str.charCodeAt(i);<br>  }<br>  return buf;<br> }</p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>不同的视图类型，所能容纳的数值范围是确定的。超出这个范围，就会出现溢出。比如，8位视图只能容纳一个8位的二进制值，如果放入一个9位的值，就会溢出。</p><p>TypedArray数组的溢出处理规则，简单来说，就是抛弃溢出的位，然后按照视图类型进行解释。</p><p> var uint8 &#x3D; new Uint8Array(1);<br> uint8[0] &#x3D; 256;<br> uint8[0] &#x2F;&#x2F; 0<br> uint8[0] &#x3D; -1;<br> uint8[0] &#x2F;&#x2F; 255<br>上面代码中，uint8是一个8位视图，而256的二进制形式是一个9位的值100000000，这时就会发生溢出。根据规则，只会保留后8位，即00000000。uint8视图的解释规则是无符号的8位整数，所以00000000就是0。<br>负数在计算机内部采用“2的补码”表示，也就是说，将对应的正数值进行否运算，然后加1。比如，-1对应的正值是1，进行否运算以后，得到11111110，再加上1就是补码形式11111111。uint8按照无符号的8位整数解释11111111，返回结果就是255。</p><p>一个简单转换规则，可以这样表示。</p><p>正向溢出（overflow）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去1。</p><p>负向溢出（underflow）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值，再加上1。</p><p>请看下面的例子。</p><p> var int8 &#x3D; new Int8Array(1);<br> int8[0] &#x3D; 128;<br> int8[0] &#x2F;&#x2F; -128<br> int8[0] &#x3D; -129;<br> int8[0] &#x2F;&#x2F; 127</p><p>上面例子中，int8是一个带符号的8位整数视图，它的最大值是127，最小值是-128。输入值为128时，相当于正向溢出1，根据“最小值加上余值，再减去1”的规则，就会返回-128；输入值为-129时，相当于负向溢出1，根据“最大值减去余值，再加上1”的规则，就会返回127。</p><p>Uint8ClampedArray视图的溢出规则，与上面的规则不同。它规定，凡是发生正向溢出，该值一律等于当前数据类型的最大值，即255；如果发生负向溢出，该值一律等于当前数据类型的最小值，即0。</p><p> var uint8c &#x3D; new Uint8ClampedArray(1);<br> uint8c[0] &#x3D; 256;<br> uint8c[0] &#x2F;&#x2F; 255<br> uint8c[0] &#x3D; -1;<br> uint8c[0] &#x2F;&#x2F; 0</p><p>上面例子中，uint8C是一个Uint8ClampedArray视图，正向溢出时都返回255，负向溢出都返回0。</p><h3 id="TypedArray-prototype-buffer"><a href="#TypedArray-prototype-buffer" class="headerlink" title="TypedArray.prototype.buffer"></a>TypedArray.prototype.buffer</h3><p>TypedArray实例的buffer属性，返回整段内存区域对应的ArrayBuffer对象。该属性为只读属性。</p><p> var a &#x3D; new Float32Array(64);<br> var b &#x3D; new Uint8Array(a.buffer);<br>上面代码的a视图对象和b视图对象，对应同一个ArrayBuffer对象，即同一段内存。</p><h3 id="TypedArray-prototype-byteLength，TypedArray-prototype-byteOffset"><a href="#TypedArray-prototype-byteLength，TypedArray-prototype-byteOffset" class="headerlink" title="TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset"></a>TypedArray.prototype.byteLength，TypedArray.prototype.byteOffset</h3><p>byteLength属性返回TypedArray数组占据的内存长度，单位为字节。byteOffset属性返回TypedArray数组从底层ArrayBuffer对象的哪个字节开始。这两个属性都是只读属性。</p><p> var b &#x3D; new ArrayBuffer(8);<br> var v1 &#x3D; new Int32Array(b);<br> var v2 &#x3D; new Uint8Array(b, 2);<br> var v3 &#x3D; new Int16Array(b, 2, 2);<br> v1.byteLength &#x2F;&#x2F; 8<br> v2.byteLength &#x2F;&#x2F; 6<br> v3.byteLength &#x2F;&#x2F; 4<br> v1.byteOffset &#x2F;&#x2F; 0<br> v2.byteOffset &#x2F;&#x2F; 2<br> v3.byteOffset &#x2F;&#x2F; 2</p><h3 id="TypedArray-prototype-length"><a href="#TypedArray-prototype-length" class="headerlink" title="TypedArray.prototype.length"></a>TypedArray.prototype.length</h3><p>length属性表示TypedArray数组含有多少个成员。注意将byteLength属性和length属性区分，前者是字节长度，后者是成员长度。</p><p> var a &#x3D; new Int16Array(8);<br> a.length &#x2F;&#x2F; 8<br> a.byteLength &#x2F;&#x2F; 16</p><h4 id="TypedArray-prototype-set"><a href="#TypedArray-prototype-set" class="headerlink" title="TypedArray.prototype.set()"></a>TypedArray.prototype.set()</h4><p>TypedArray数组的set方法用于复制数组（普通数组或TypedArray数组），也就是将一段内容完全复制到另一段内存。</p><p> var a &#x3D; new Uint8Array(8);<br> var b &#x3D; new Uint8Array(8);<br> b.set(a);</p><p>上面代码复制a数组的内容到b数组，它是整段内存的复制，比一个个拷贝成员的那种复制快得多。</p><p>set方法还可以接受第二个参数，表示从b对象的哪一个成员开始复制a对象。</p><p> var a &#x3D; new Uint16Array(8);<br> var b &#x3D; new Uint16Array(10);<br> b.set(a, 2)</p><p>上面代码的b数组比a数组多两个成员，所以从b[2]开始复制。</p><h3 id="TypedArray-prototype-subarray"><a href="#TypedArray-prototype-subarray" class="headerlink" title="TypedArray.prototype.subarray()"></a>TypedArray.prototype.subarray()</h3><p>subarray方法是对于TypedArray数组的一部分，再建立一个新的视图。</p><p> var a &#x3D; new Uint16Array(8);<br> var b &#x3D; a.subarray(2,3);<br> a.byteLength &#x2F;&#x2F; 16<br> b.byteLength &#x2F;&#x2F; 2</p><p>subarray方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。所以，上面代码的a.subarray(2,3)，意味着b只包含a[2]一个成员，字节长度为2。</p><h4 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a>TypedArray.prototype.slice()</h4><p>TypeArray实例的slice方法，可以返回一个指定位置的新的TypedArray实例。</p><p> let ui8 &#x3D; Uint8Array.of(0, 1, 2);<br> ui8.slice(-1)<br> &#x2F;&#x2F; Uint8Array [ 2 ]</p><p>上面代码中，ui8是8位无符号整数数组视图的一个实例。它的slice方法可以从当前视图之中，返回一个新的视图实例。</p><p>slice方法的参数，表示原数组的具体位置，开始生成新数组。负值表示逆向的位置，即-1为倒数第一个位置，-2表示倒数第二个位置，以此类推。</p><h3 id="TypedArray-of"><a href="#TypedArray-of" class="headerlink" title="TypedArray.of()"></a>TypedArray.of()</h3><p>TypedArray数组的所有构造函数，都有一个静态方法of，用于将参数转为一个TypedArray实例。</p><p> Float32Array.of(0.151, -8, 3.7)<br> &#x2F;&#x2F; Float32Array [ 0.151, -8, 3.7 ]<br> 下面三种方法都会生成同样一个TypedArray数组。<br> &#x2F;&#x2F; 方法一<br> let tarr &#x3D; new Uint8Array([1,2,3]);<br> &#x2F;&#x2F; 方法二<br> let tarr &#x3D; Uint8Array.of(1,2,3);<br> &#x2F;&#x2F; 方法三<br> let tarr &#x3D; new Uint8Array(3);<br> tarr[0] &#x3D; 1;<br> tarr[1] &#x3D; 2;<br> tarr[2] &#x3D; 3;</p><h3 id="TypedArray-from"><a href="#TypedArray-from" class="headerlink" title="TypedArray.from()"></a>TypedArray.from()</h3><p>静态方法from接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的TypedArray实例。</p><p> Uint16Array.from([0, 1, 2])<br> &#x2F;&#x2F; Uint16Array [ 0, 1, 2 ]<br> 这个方法还可以将一种TypedArray实例，转为另一种。<br> var ui16 &#x3D; Uint16Array.from(Uint8Array.of(0, 1, 2));<br> ui16 instanceof Uint16Array &#x2F;&#x2F; true<br> from方法还可以接受一个函数，作为第二个参数，用来对每个元素进行遍历，功能类似map方法。<br> Int8Array.of(127, 126, 125).map(x &#x3D;&gt; 2 <em>x)<br> &#x2F;&#x2F; Int8Array [ -2, -4, -6 ]<br>Int16Array.from(Int8Array.of(127, 126, 125), x &#x3D;&gt; 2</em> x)<br> &#x2F;&#x2F; Int16Array [ 254, 252, 250 ]</p><p>上面的例子中，from方法没有发生溢出，这说明遍历不是针对原来的8位整数数组。也就是说，from会将第一个参数指定的TypedArray数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式。</p><h2 id="复合视图"><a href="#复合视图" class="headerlink" title="复合视图"></a>复合视图</h2><p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p><p> var buffer &#x3D; new ArrayBuffer(24);<br> var idView &#x3D; new Uint32Array(buffer, 0, 1);<br> var usernameView &#x3D; new Uint8Array(buffer, 4, 16);<br> var amountDueView &#x3D; new Float32Array(buffer, 20, 1);</p><p>上面代码将一个24字节长度的ArrayBuffer对象，分成三个部分：</p><p>字节0到字节3：1个32位无符号整数</p><p>字节4到字节19：16个8位整数</p><p>字节20到字节23：1个32位浮点数</p><p>这种数据结构可以用如下的C语言描述：</p><p> struct someStruct {<br>  unsigned long id;<br>  char username[16];<br>  float amountDue;<br> };</p><h2 id="DataView视图"><a href="#DataView视图" class="headerlink" title="DataView视图"></a>DataView视图</h2><p>如果一段数据包括多种类型（比如服务器传来的HTTP数据），这时除了建立ArrayBuffer对象的复合视图以外，还可以通过DataView视图进行操作。DataView视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，ArrayBuffer对象的各种TypedArray视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而DataView视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p><p>DataView视图本身也是构造函数，接受一个ArrayBuffer对象作为参数，生成视图。</p><p>DataView(ArrayBuffer buffer [, 字节起始位置 [, 长度]]);</p><p>下面是一个例子。</p><p> var buffer &#x3D; new ArrayBuffer(24);<br> var dv &#x3D; new DataView(buffer);<br> DataView实例有以下属性，含义与TypedArray实例的同名方法相同。<br> DataView.prototype.buffer：返回对应的ArrayBuffer对象<br> DataView.prototype.byteLength：返回占据的内存字节长度<br> DataView.prototype.byteOffset：返回当前视图从对应的ArrayBuffer对象的哪个字节开始<br> DataView实例提供8个方法读取内存。<br> getInt8：读取1个字节，返回一个8位整数。<br> getUint8：读取1个字节，返回一个无符号的8位整数。<br> getInt16：读取2个字节，返回一个16位整数。<br> getUint16：读取2个字节，返回一个无符号的16位整数。<br> getInt32：读取4个字节，返回一个32位整数。<br> getUint32：读取4个字节，返回一个无符号的32位整数。<br> getFloat32：读取4个字节，返回一个32位浮点数。<br> getFloat64：读取8个字节，返回一个64位浮点数。</p><p>这一系列get方法的参数都是一个字节序号（不能是负数，否则会报错），表示从哪个字节开始读取。</p><p> var buffer &#x3D; new ArrayBuffer(24);<br> var dv &#x3D; new DataView(buffer);<br> &#x2F;&#x2F; 从第1个字节读取一个8位无符号整数<br> var v1 &#x3D; dv.getUint8(0);<br> &#x2F;&#x2F; 从第2个字节读取一个16位无符号整数<br> var v2 &#x3D; dv.getUint16(1);<br> &#x2F;&#x2F; 从第4个字节读取一个16位无符号整数<br> var v3 &#x3D; dv.getUint16(3);</p><p>上面代码读取了ArrayBuffer对象的前5个字节，其中有一个8位整数和两个十六位整数。</p><p>如果一次读取两个或两个以上字节，就必须明确数据的存储方式，到底是小端字节序还是大端字节序。默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。</p><p> &#x2F;&#x2F; 小端字节序<br> var v1 &#x3D; dv.getUint16(1, true);<br> &#x2F;&#x2F; 大端字节序<br> var v2 &#x3D; dv.getUint16(3, false);<br> &#x2F;&#x2F; 大端字节序<br> var v3 &#x3D; dv.getUint16(3);<br> DataView视图提供8个方法写入内存。<br> setInt8：写入1个字节的8位整数。<br> setUint8：写入1个字节的8位无符号整数。<br> setInt16：写入2个字节的16位整数。<br> setUint16：写入2个字节的16位无符号整数。<br> setInt32：写入4个字节的32位整数。<br> setUint32：写入4个字节的32位无符号整数。<br> setFloat32：写入4个字节的32位浮点数。<br> setFloat64：写入8个字节的64位浮点数。</p><p>这一系列set方法，接受两个参数，第一个参数是字节序号，表示从哪个字节开始写入，第二个参数为写入的数据。对于那些写入两个或两个以上字节的方法，需要指定第三个参数，false或者undefined表示使用大端字节序写入，true表示使用小端字节序写入。</p><p> &#x2F;&#x2F; 在第1个字节，以大端字节序写入值为25的32位整数<br> dv.setInt32(0, 25, false);<br> &#x2F;&#x2F; 在第5个字节，以大端字节序写入值为25的32位整数<br> dv.setInt32(4, 25);<br> &#x2F;&#x2F; 在第9个字节，以小端字节序写入值为2.5的32位浮点数<br> dv.setFloat32(8, 2.5, true);<br> 如果不确定正在使用的计算机的字节序，可以采用下面的判断方式。<br> var littleEndian &#x3D; (function() {<br> var buffer &#x3D; new ArrayBuffer(2);<br> new DataView(buffer).setInt16(0, 256, true);<br> return new Int16Array<a href="0">buffer</a> &#x3D;&#x3D;&#x3D; 256;<br> })();</p><p>如果返回true，就是小端字节序；如果返回false，就是大端字节序。</p><h2 id="12-5-二进制数组的应用"><a href="#12-5-二进制数组的应用" class="headerlink" title="12.5 二进制数组的应用"></a>12.5 二进制数组的应用</h2><p>大量的Web API用到了ArrayBuffer对象和它的视图对象。</p><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>传统上，服务器通过AJAX操作只能返回文本数据，即responseType属性默认为text。XMLHttpRequest第二版XHR2允许服务器返回二进制数据，这时分成两种情况。如果明确知道返回的二进制数据类型，可以把返回类型（responseType）设为arraybuffer；如果不知道，就设为blob。</p><p> var xhr &#x3D; new XMLHttpRequest();<br> xhr.open(‘GET’, someUrl);<br> xhr.responseType &#x3D; ‘arraybuffer’;<br> xhr.onload &#x3D; function () {<br>  let arrayBuffer &#x3D; xhr.response;<br>  &#x2F;&#x2F; ···<br> };<br> xhr.send();</p><p>如果知道传回来的是32位整数，可以像下面这样处理。</p><p> xhr.onreadystatechange &#x3D; function () {<br>  if (req.readyState &#x3D;&#x3D;&#x3D; 4 ) {<br>   var arrayResponse &#x3D; xhr.response;<br>   var dataView &#x3D; new DataView(arrayResponse);<br>   var ints &#x3D; new Uint32Array(dataView.byteLength &#x2F; 4);<br>   xhrDiv.style.backgroundColor &#x3D; “#00FF00”;<br>   xhrDiv.innerText &#x3D; “Array is “ + ints.length + “uints long”;<br>  }<br> }</p><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>网页Canvas元素输出的二进制像素数据，就是TypedArray数组。</p><p> var canvas &#x3D; document.getElementById(‘myCanvas’);<br> var ctx &#x3D; canvas.getContext(‘2d’);<br> var imageData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height);<br> var uint8ClampedArray &#x3D; imageData.data;</p><p>需要注意的是，上面代码的uint8ClampedArray虽然是一个TypedArray数组，但是它的视图类型是一种针对Canvas元素的专有类型Uint8ClampedArray。<br>这个视图类型的特点，就是专门针对颜色，把每个字节解读为无符号的8位整数，即只能取值0～255，而且发生运算的时候自动过滤高位溢出。这为图像处理带来了巨大的方便。</p><p>举例来说，如果把像素的颜色值设为Uint8Array类型，那么乘以一个gamma值的时候，就必须这样计算：</p><p> u8[i] &#x3D; Math.min(255, Math.max(0, u8[i] * gamma));</p><p>因为Uint8Array类型对于大于255的运算结果（比如0xFF+1），会自动变为0x00，所以图像处理必须要像上面这样算。这样做很麻烦，而且影响性能。<br>如果将颜色值设为Uint8ClampedArray类型，计算就简化许多。</p><p> pixels[i] *&#x3D; gamma;</p><p>Uint8ClampedArray类型确保将小于0的值设为0，将大于255的值设为255。注意，IE 10不支持该类型。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket可以通过ArrayBuffer，发送或接收二进制数据。</p><p> var socket &#x3D; new WebSocket(‘ws:&#x2F;&#x2F;127.0.0.1:8081’);<br> socket.binaryType &#x3D; ‘arraybuffer’;<br>  &#x2F;&#x2F; Wait until socket is open<br> socket.addEventListener(‘open’, function (event) {<br>  &#x2F;&#x2F; Send binary data<br>  var typedArray &#x3D; new Uint8Array(4);<br>  socket.send(typedArray.buffer);<br> });<br> &#x2F;&#x2F; Receive binary data<br> socket.addEventListener(‘message’, function (event) {<br>  var arrayBuffer &#x3D; event.data;<br>  &#x2F;&#x2F; ···<br> });</p><h3 id="Fetch-API"><a href="#Fetch-API" class="headerlink" title="Fetch API"></a>Fetch API</h3><p>Fetch API取回的数据，就是ArrayBuffer对象。</p><p> fetch(url)<br>  .then(function(request){<br>  return request.arrayBuffer()<br> })<br>  .then(function(arrayBuffer){<br>  &#x2F;&#x2F; …<br> });</p><h3 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h3><p>如果知道一个文件的二进制数据类型，也可以将这个文件读取为ArrayBuffer对象。</p><p> var fileInput &#x3D; document.getElementById(‘fileInput’);<br> var file &#x3D; fileInput.files[0];<br> var reader &#x3D; new FileReader();<br> reader.readAsArrayBuffer(file);<br> reader.onload &#x3D; function () {<br>  var arrayBuffer &#x3D; reader.result;<br>  &#x2F;&#x2F; ···<br> };<br>下面以处理bmp文件为例。假定file变量是一个指向bmp文件的文件对象，首先读取文件。</p><p> var reader &#x3D; new FileReader();<br> reader.addEventListener(“load”, processimage, false);<br> reader.readAsArrayBuffer(file);</p><p>然后，定义处理图像的回调函数：先在二进制数据之上建立一个DataView视图，再建立一个bitmap对象，用于存放处理后的数据，最后将图像展示在Canvas元素之中。</p><p> function processimage(e) {<br> var buffer &#x3D; e.target.result;<br> var datav &#x3D; new DataView(buffer);<br> var bitmap &#x3D; {};<br>  &#x2F;&#x2F; 具体的处理步骤<br> }<br>具体处理图像数据时，先处理bmp的文件头。具体每个文件头的格式和定义，请参阅有关资料。</p><p> bitmap.fileheader &#x3D; {};<br> bitmap.fileheader.bfType &#x3D; datav.getUint16(0, true);<br> bitmap.fileheader.bfSize &#x3D; datav.getUint32(2, true);<br> bitmap.fileheader.bfReserved1 &#x3D; datav.getUint16(6, true);<br> bitmap.fileheader.bfReserved2 &#x3D; datav.getUint16(8, true);<br> bitmap.fileheader.bfOffBits &#x3D; datav.getUint32(10, true);</p><p>接着处理图像元信息部分。</p><p> bitmap.infoheader &#x3D; {};<br> bitmap.infoheader.biSize &#x3D; datav.getUint32(14, true);<br> bitmap.infoheader.biWidth &#x3D; datav.getUint32(18, true);<br> bitmap.infoheader.biHeight &#x3D; datav.getUint32(22, true);<br> bitmap.infoheader.biPlanes &#x3D; datav.getUint16(26, true);<br> bitmap.infoheader.biBitCount &#x3D; datav.getUint16(28, true);<br> bitmap.infoheader.biCompression &#x3D; datav.getUint32(30, true);<br> bitmap.infoheader.biSizeImage &#x3D; datav.getUint32(34, true);<br> bitmap.infoheader.biXPelsPerMeter &#x3D; datav.getUint32(38, true);<br> bitmap.infoheader.biYPelsPerMeter &#x3D; datav.getUint32(42, true);<br> bitmap.infoheader.biClrUsed &#x3D; datav.getUint32(46, true);<br> bitmap.infoheader.biClrImportant &#x3D; datav.getUint32(50, true);</p><p>最后处理图像本身的像素信息。</p><p> var start &#x3D; bitmap.fileheader.bfOffBits;<br> bitmap.pixels &#x3D; new Uint8Array(buffer, start);</p><p>至此，图像文件的数据全部处理完成。下一步，可以根据需要，进行图像变形，或者转换格式，或者展示在Canvas网页元素之中。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6 第十三章 Set和Map数据结构</title>
    <link href="/2022/06/22/ECAMScript-thirteenfourteen-chart/"/>
    <url>/2022/06/22/ECAMScript-thirteenfourteen-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6-第十三章-Set和Map数据结构"><a href="#ES6-第十三章-Set和Map数据结构" class="headerlink" title="ES6 第十三章 Set和Map数据结构"></a>ES6 第十三章 Set和Map数据结构</h1><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成Set数据结构。</p><p> var s &#x3D; new Set();<br> [2, 3, 5, 4, 5, 2, 2].map(x &#x3D;&gt; s.add(x));<br>  for (let i of s) {<br>  console.log(i);<br> }<br> &#x2F;&#x2F; 2 3 5 4</p><p>上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。</p><p>Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p><p> &#x2F;&#x2F; 例一<br> var set &#x3D; new Set([1, 2, 3, 4, 4]);<br> […set]<br> &#x2F;&#x2F; [1, 2, 3, 4]<br> &#x2F;&#x2F; 例二<br> var items &#x3D; new Set([1, 2, 3, 4, 5, 5, 5, 5]);<br> items.size &#x2F;&#x2F; 5<br> &#x2F;&#x2F; 例三<br> function divs () {<br>  return […document.querySelectorAll(‘div’)];<br> }<br> var set &#x3D; new Set(divs());<br> set.size &#x2F;&#x2F; 56<br> &#x2F;&#x2F; 类似于<br> divs().forEach(div &#x3D;&gt; set.add(div));<br> set.size &#x2F;&#x2F; 56</p><p>上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码中，也展示了一种去除数组重复成员的方法。</p><p> &#x2F;&#x2F; 去除数组的重复成员<br> […new Set(array)]<br>向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（&#x3D;&#x3D;&#x3D;），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p><p> let set &#x3D; new Set();<br> let a &#x3D; NaN;<br> let b &#x3D; NaN;<br> set.add(a);<br> set.add(b);<br> set &#x2F;&#x2F; Set {NaN}<br>上面代码向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。</p><p> let set &#x3D; new Set();<br> set.add({});<br> set.size &#x2F;&#x2F; 1<br> set.add({});<br> set.size &#x2F;&#x2F; 2</p><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="Set实例的属性和方法"></a>Set实例的属性和方法</h3><p>Set结构的实例有以下属性。<br> Set.prototype.constructor：构造函数，默认就是Set函数。<br> Set.prototype.size：返回Set实例的成员总数。<br>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><p> add(value)：添加某个值，返回Set结构本身。<br> delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br> has(value)：返回一个布尔值，表示该值是否为Set的成员。<br> clear()：清除所有成员，没有返回值。</p><p>上面这些属性和方法的实例如下。</p><p> s.add(1).add(2).add(2);<br> &#x2F;&#x2F; 注意2被加入了两次<br> s.size &#x2F;&#x2F; 2<br> s.has(1) &#x2F;&#x2F; true<br> s.has(2) &#x2F;&#x2F; true<br> s.has(3) &#x2F;&#x2F; false<br> s.delete(2);<br> s.has(2) &#x2F;&#x2F; false</p><p>下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。</p><p> &#x2F;&#x2F; 对象的写法<br> var properties &#x3D; {<br>  ‘width’: 1,<br>  ‘height’: 1<br> };<br> if (properties[someName]) {<br>  &#x2F;&#x2F; do something<br> }<br> &#x2F;&#x2F; Set的写法<br> var properties &#x3D; new Set();<br> properties.add(‘width’);<br> properties.add(‘height’);<br> if (properties.has(someName)) {<br>  &#x2F;&#x2F; do something<br> }<br> Array.from方法可以将Set结构转为数组。<br> var items &#x3D; new Set([1, 2, 3, 4, 5]);<br> var array &#x3D; Array.from(items);<br>这就提供了去除数组重复成员的另一种方法。</p><p> function dedupe(array) {<br>  return Array.from(new Set(array));<br> }<br> dedupe([1, 1, 2, 3]) &#x2F;&#x2F; [1, 2, 3]</p><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p><p> keys()：返回键名的遍历器<br> values()：返回键值的遍历器<br> entries()：返回键值对的遍历器<br> forEach()：使用回调函数遍历每个成员</p><p>需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><h4 id="keys-，values-，entries"><a href="#keys-，values-，entries" class="headerlink" title="keys()，values()，entries()"></a>keys()，values()，entries()</h4><p>key方法、value方法、entries方法返回的都是遍历器对象（详见《Iterator对象》一章）。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。</p><p> let set &#x3D; new Set([‘red’, ‘green’, ‘blue’]);<br> for (let item of set.keys()) {<br>  console.log(item);<br> }<br> &#x2F;&#x2F; red<br> &#x2F;&#x2F; green<br> &#x2F;&#x2F; blue<br> for (let item of set.values()) {<br>  console.log(item);<br> }<br> &#x2F;&#x2F; red<br> &#x2F;&#x2F; green<br> &#x2F;&#x2F; blue<br> for (let item of set.entries()) {<br>  console.log(item);<br> }<br> &#x2F;&#x2F; [“red”, “red”]<br> &#x2F;&#x2F; [“green”, “green”]<br> &#x2F;&#x2F; [“blue”, “blue”]<br>上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。<br> Set.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; Set.prototype.values<br> &#x2F;&#x2F; true<br>这意味着，可以省略values方法，直接用for…of循环遍历Set。<br> let set &#x3D; new Set([‘red’, ‘green’, ‘blue’]);<br> for (let x of set) {<br> console.log(x);<br> }<br> &#x2F;&#x2F; red<br> &#x2F;&#x2F; green<br> &#x2F;&#x2F; blue</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。</p><p> let set &#x3D; new Set([1, 2, 3]);<br> set.forEach((value, key) &#x3D;&gt; console.log(value * 2) )<br> &#x2F;&#x2F; 2<br> &#x2F;&#x2F; 4<br> &#x2F;&#x2F; 6</p><p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。</p><h3 id="遍历的应用"><a href="#遍历的应用" class="headerlink" title="遍历的应用"></a>遍历的应用</h3><p>扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构。</p><p> let set &#x3D; new Set([‘red’, ‘green’, ‘blue’]);<br> let arr &#x3D; […set];<br> &#x2F;&#x2F; [‘red’, ‘green’, ‘blue’]</p><p>扩展运算符和Set结构相结合，就可以去除数组的重复成员。</p><p> let arr &#x3D; [3, 5, 2, 2, 5, 5];<br> let unique &#x3D; […new Set(arr)];<br> &#x2F;&#x2F; [3, 5, 2]</p><p>而且，数组的map和filter方法也可以用于Set了。</p><p> let set &#x3D; new Set([1, 2, 3]);<br> set &#x3D; new Set([…set].map(x &#x3D;&gt; x * 2));<br> &#x2F;&#x2F; 返回Set结构：{2, 4, 6}<br> let set &#x3D; new Set([1, 2, 3, 4, 5]);<br> set &#x3D; new Set([…set].filter(x &#x3D;&gt; (x % 2) &#x3D;&#x3D; 0));<br> &#x2F;&#x2F; 返回Set结构：{2, 4}</p><p>因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><p> let a &#x3D; new Set([1, 2, 3]);<br> let b &#x3D; new Set([4, 3, 2]);<br> &#x2F;&#x2F; 并集<br> let union &#x3D; new Set([…a, …b]);<br> &#x2F;&#x2F; Set {1, 2, 3, 4}<br> &#x2F;&#x2F; 交集<br> let intersect &#x3D; new Set([…a].filter(x &#x3D;&gt; b.has(x)));<br> &#x2F;&#x2F; set {2, 3}<br> &#x2F;&#x2F; 差集<br> let difference &#x3D; new Set([…a].filter(x &#x3D;&gt; !b.has(x)));<br> &#x2F;&#x2F; Set {1}</p><p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。</p><p> &#x2F;&#x2F; 方法一<br> let set &#x3D; new Set([1, 2, 3]);<br> set &#x3D; new Set([…set].map(val &#x3D;&gt; val <em>2));<br> &#x2F;&#x2F; set的值是2, 4, 6<br> &#x2F;&#x2F; 方法二<br> let set &#x3D; new Set([1, 2, 3]);<br>set &#x3D; new Set(Array.from(set, val &#x3D;&gt; val</em> 2));<br> &#x2F;&#x2F; set的值是2, 4, 6</p><p>上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p><p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p><p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。</p><p>这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p><p> var ws &#x3D; new WeakSet();<br> ws.add(1)<br> &#x2F;&#x2F; TypeError: Invalid value used in weak set<br> ws.add(Symbol())<br> &#x2F;&#x2F; TypeError: invalid value used in weak set</p><p>上面代码试图向WeakSet添加一个数值和Symbol值，结果报错，因为WeakSet只能放置对象。</p><p>WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。</p><p> var ws &#x3D; new WeakSet();</p><p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。</p><p> var a &#x3D; [[1,2], [3,4]];<br> var ws &#x3D; new WeakSet(a);</p><p>上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。</p><p>注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。</p><p> var b &#x3D; [3, 4];<br> var ws &#x3D; new WeakSet(b);<br> &#x2F;&#x2F; Uncaught TypeError: Invalid value used in weak set(…)<br>上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。</p><p>WeakSet结构有以下三个方法。</p><p> WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。<br> WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。<br> WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。</p><p>下面是一个例子。</p><p> var ws &#x3D; new WeakSet();<br> var obj &#x3D; {};<br> var foo &#x3D; {};<br> ws.add(window);<br> ws.add(obj);<br> ws.has(window); &#x2F;&#x2F; true<br> ws.has(foo); &#x2F;&#x2F; false<br> ws.delete(window);<br> ws.has(window); &#x2F;&#x2F; false<br> WeakSet没有size属性，没有办法遍历它的成员。<br> ws.size &#x2F;&#x2F; undefined<br> ws.forEach &#x2F;&#x2F; undefined<br> ws.forEach(function(item){ console.log(‘WeakSet has ‘ + item)})<br> &#x2F;&#x2F; TypeError: undefined is not a function</p><p>上面代码试图获取size和forEach属性，结果都不能成功。<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p><p>下面是WeakSet的另一个例子。</p><p> const foos &#x3D; new WeakSet()<br> class Foo {<br>  constructor() {<br>    foos.add(this)<br>   }<br>  method () {<br>   if (!foos.has(this)) {<br>    throw new TypeError(‘Foo.prototype.method 只能在Foo的实例上调用！’);<br>   }<br>  }<br> }<br>上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="Map结构的目的和基本用法"><a href="#Map结构的目的和基本用法" class="headerlink" title="Map结构的目的和基本用法"></a>Map结构的目的和基本用法</h3><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><p> var data &#x3D; {};<br> var element &#x3D; document.getElementById(‘myDiv’);<br> data[element] &#x3D; ‘metadata’;<br> data[‘[object HTMLDivElement]’] &#x2F;&#x2F; “metadata”</p><p>上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。</p><p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p><p> var m &#x3D; new Map();<br> var o &#x3D; {p: ‘Hello World’};<br> m.set(o, ‘content’)<br> m.get(o) &#x2F;&#x2F; “content”<br> m.has(o) &#x2F;&#x2F; true<br> m.delete(o) &#x2F;&#x2F; true<br> m.has(o) &#x2F;&#x2F; false</p><p>上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。</p><p>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><p> var map &#x3D; new Map([<br> [‘name’, ‘张三’],<br> [‘title’, ‘Author’]<br> ]);<br> map.size &#x2F;&#x2F; 2<br> map.has(‘name’) &#x2F;&#x2F; true<br> map.get(‘name’) &#x2F;&#x2F; “张三”<br> map.has(‘title’) &#x2F;&#x2F; true<br> map.get(‘title’) &#x2F;&#x2F; “Author”</p><p>上面代码在新建Map实例时，就指定了两个键name和title。</p><p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。</p><p> var items &#x3D; [<br> [‘name’, ‘张三’],<br> [‘title’, ‘Author’]<br> ];<br> var map &#x3D; new Map();<br> items.forEach(([key, value]) &#x3D;&gt; map.set(key, value));</p><p>下面的例子中，字符串true和布尔值true是两个不同的键。</p><p> var m &#x3D; new Map([<br> [true, ‘foo’],<br> [‘true’, ‘bar’]<br> ]);<br> m.get(true) &#x2F;&#x2F; ‘foo’<br> m.get(‘true’) &#x2F;&#x2F; ‘bar’</p><p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p><p> let map &#x3D; new Map();<br> map<br> .set(1, ‘aaa’)<br> .set(1, ‘bbb’);<br> map.get(1) &#x2F;&#x2F; “bbb”<br>上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。</p><p>如果读取一个未知的键，则返回undefined。</p><p> new Map().get(‘asfddfsasadf’)<br> &#x2F;&#x2F; undefined</p><p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p><p> var map &#x3D; new Map();<br> map.set([‘a’], 555);<br> map.get([‘a’]) &#x2F;&#x2F; undefined</p><p>上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。</p><p>同理，同样的值的两个实例，在Map结构中被视为两个键。</p><p> var map &#x3D; new Map();<br> var k1 &#x3D; [‘a’];<br> var k2 &#x3D; [‘a’];<br> map<br> .set(k1, 111)<br> .set(k2, 222);<br> map.get(k1) &#x2F;&#x2F; 111<br> map.get(k2) &#x2F;&#x2F; 222</p><p>上面代码中，变量k1和k2的值是一样的，但是它们在Map结构中被视为两个键。</p><p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</p><p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</p><p> let map &#x3D; new Map();<br> map.set(NaN, 123);<br> map.get(NaN) &#x2F;&#x2F; 123<br> map.set(-0, 123);<br> map.get(+0) &#x2F;&#x2F; 123</p><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p>Map结构的实例有以下属性和操作方法。</p><ul><li>size属性</li></ul><p> size属性返回Map结构的成员总数。</p><p>  let map &#x3D; new Map();<br>  map.set(‘foo’, true);<br>  map.set(‘bar’, false);<br>  map.size &#x2F;&#x2F; 2</p><ul><li>set(key, value)</li></ul><p> set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</p><p>  var m &#x3D; new Map();<br>  m.set(“edition”, 6) &#x2F;&#x2F; 键是字符串<br>  m.set(262, “standard”) &#x2F;&#x2F; 键是数值<br>  m.set(undefined, “nah”) &#x2F;&#x2F; 键是undefined<br>  set方法返回的是Map本身，因此可以采用链式写法。<br>  let map &#x3D; new Map()<br>  .set(1, ‘a’)<br>  .set(2, ‘b’)<br>  .set(3, ‘c’);</p><ul><li>get(key)</li></ul><p> get方法读取key对应的键值，如果找不到key，返回undefined。</p><p>  var m &#x3D; new Map();<br>  var hello &#x3D; function() {console.log(“hello”);}<br>  m.set(hello, “Hello ES6!”) &#x2F;&#x2F; 键是函数<br>  m.get(hello) &#x2F;&#x2F; Hello ES6!</p><ul><li>has(key)</li></ul><p> has方法返回一个布尔值，表示某个键是否在Map数据结构中。</p><p>  var m &#x3D; new Map();<br>  m.set(“edition”, 6);<br>  m.set(262, “standard”);<br>  m.set(undefined, “nah”);<br>  m.has(“edition”) &#x2F;&#x2F; true<br>  m.has(“years”) &#x2F;&#x2F; false<br>  m.has(262) &#x2F;&#x2F; true<br>  m.has(undefined) &#x2F;&#x2F; true</p><ul><li>delete(key)</li></ul><p> delete方法删除某个键，返回true。如果删除失败，返回false。</p><p>  var m &#x3D; new Map();<br>  m.set(undefined, “nah”);<br>  m.has(undefined) &#x2F;&#x2F; true<br>  m.delete(undefined)<br>  m.has(undefined) &#x2F;&#x2F; false</p><ul><li>clear()</li></ul><p> clear方法清除所有成员，没有返回值。</p><p>  let map &#x3D; new Map();<br>  map.set(‘foo’, true);<br>  map.set(‘bar’, false);<br>  map.size &#x2F;&#x2F; 2<br>  map.clear()<br>  map.size &#x2F;&#x2F; 0</p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p><p> keys()：返回键名的遍历器。<br> values()：返回键值的遍历器。<br> entries()：返回所有成员的遍历器。<br> forEach()：遍历Map的所有成员。</p><p>需要特别注意的是，Map的遍历顺序就是插入顺序。</p><p>下面是使用实例。</p><p> let map &#x3D; new Map([<br>  [‘F’, ‘no’],<br>  [‘T’, ‘yes’],<br> ]);<br> for (let key of map.keys()) {<br>  console.log(key);<br> }<br> &#x2F;&#x2F; “F”<br> &#x2F;&#x2F; “T”<br> for (let value of map.values()) {<br>  console.log(value);<br> }<br> &#x2F;&#x2F; “no”<br> &#x2F;&#x2F; “yes”<br> for (let item of map.entries()) {<br>  console.log(item[0], item[1]);<br> }<br> &#x2F;&#x2F; “F” “no”<br> &#x2F;&#x2F; “T” “yes”<br> &#x2F;&#x2F; 或者<br> for (let [key, value] of map.entries()) {<br>  console.log(key, value);<br> }<br> &#x2F;&#x2F; 等同于使用map.entries()<br> for (let [key, value] of map) {<br>  console.log(key, value);<br> }</p><p>上面代码最后的那个例子，表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。</p><p> map[Symbol.iterator] &#x3D;&#x3D;&#x3D; map.entries<br> &#x2F;&#x2F; true<br> Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。<br> let map &#x3D; new Map([<br>  [1, ‘one’],<br>  [2, ‘two’],<br>  [3, ‘three’],<br> ]);<br> […map.keys()]<br> &#x2F;&#x2F; [1, 2, 3]<br> […map.values()]<br> &#x2F;&#x2F; [‘one’, ‘two’, ‘three’]<br> […map.entries()]<br> &#x2F;&#x2F; [[1,’one’], [2, ‘two’], [3, ‘three’]]<br> […map]<br> &#x2F;&#x2F; [[1,’one’], [2, ‘two’], [3, ‘three’]]</p><p>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。</p><p> let map0 &#x3D; new Map()<br> .set(1, ‘a’)<br> .set(2, ‘b’)<br> .set(3, ‘c’);<br> let map1 &#x3D; new Map(<br>  […map0].filter(([k, v]) &#x3D;&gt; k &lt; 3)<br> );<br> &#x2F;&#x2F; 产生Map结构 {1 &#x3D;&gt; ‘a’, 2 &#x3D;&gt; ‘b’}<br> let map2 &#x3D; new Map(<br> […map0].map(([k, v]) &#x3D;&gt; [k * 2, ‘_’ + v])<br> );<br> &#x2F;&#x2F; 产生Map结构 {2 &#x3D;&gt; ‘_a’, 4 &#x3D;&gt; ‘_b’, 6 &#x3D;&gt; ‘_c’}</p><p>此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。</p><p> map.forEach(function(value, key, map) {<br> console.log(“Key: %s, Value: %s”, key, value);<br> });<br>forEach方法还可以接受第二个参数，用来绑定this。</p><p> var reporter &#x3D; {<br>  report: function(key, value) {<br>   console.log(“Key: %s, Value: %s”, key, value);<br>  }<br> };<br> map.forEach(function(value, key, map) {<br>  this.report(key, value);<br> }, reporter);</p><p>上面代码中，forEach方法的回调函数的this，就指向reporter。</p><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><ol><li>Map转为数组</li></ol><p> 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p><p>  let myMap &#x3D; new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>  […myMap]<br>  &#x2F;&#x2F; [ [ true, 7 ], [ { foo: 3 }, [ ‘abc’ ] ] ]<br>2. 数组转为Map</p><p> 将数组转入Map构造函数，就可以转为Map。</p><p>  new Map([[true, 7], [{foo: 3}, [‘abc’]]])<br>  &#x2F;&#x2F; Map {true &#x3D;&gt; 7, Object {foo: 3} &#x3D;&gt; [‘abc’]}<br>3. Map转为对象</p><p> 如果所有Map的键都是字符串，它可以转为对象。<br>  function strMapToObj(strMap) {<br>   let obj &#x3D; Object.create(null);<br>   for (let [k,v] of strMap) {<br>    obj[k] &#x3D; v;<br>   }<br>   return obj;<br>  }<br>  let myMap &#x3D; new Map().set(‘yes’, true).set(‘no’, false);<br>  strMapToObj(myMap)<br>  &#x2F;&#x2F; { yes: true, no: false }</p><ol start="4"><li>对象转为Map</li></ol><p>  function objToStrMap(obj) {<br>  let strMap &#x3D; new Map();<br>  for (let k of Object.keys(obj)) {<br>  strMap.set(k, obj[k]);<br>  }<br>  return strMap;<br>  }<br>  objToStrMap({yes: true, no: false})<br>  &#x2F;&#x2F; [ [ ‘yes’, true ], [ ‘no’, false ] ]<br>5. Map转为JSON</p><p> Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。</p><p>  function strMapToJson(strMap) {<br>  return JSON.stringify(strMapToObj(strMap));<br>  }<br>  let myMap &#x3D; new Map().set(‘yes’, true).set(‘no’, false);<br>  strMapToJson(myMap)<br>  &#x2F;&#x2F; ‘{“yes”:true,”no”:false}’<br> 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。</p><p>  function mapToArrayJson(map) {<br>  return JSON.stringify([…map]);<br>  }<br>  let myMap &#x3D; new Map().set(true, 7).set({foo: 3}, [‘abc’]);<br>  mapToArrayJson(myMap)<br>  &#x2F;&#x2F; ‘[[true,7],[{“foo”:3},[“abc”]]]’</p><ol start="6"><li>JSON转为Map</li></ol><p> JSON转为Map，正常情况下，所有键名都是字符串。</p><p>  function jsonToStrMap(jsonStr) {<br>   return objToStrMap(JSON.parse(jsonStr));<br>  }<br>  jsonToStrMap(‘{“yes”:true,”no”:false}’)<br>  &#x2F;&#x2F; Map {‘yes’ &#x3D;&gt; true, ‘no’ &#x3D;&gt; false}</p><p> 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。</p><p>  function jsonToMap(jsonStr) {<br>   return new Map(JSON.parse(jsonStr));<br>  }<br>  jsonToMap(‘[[true,7],[{“foo”:3},[“abc”]]]’)<br>  &#x2F;&#x2F; Map {true &#x3D;&gt; 7, Object {foo: 3} &#x3D;&gt; [‘abc’]}</p><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p><p> var map &#x3D; new WeakMap()<br> map.set(1, 2)<br> &#x2F;&#x2F; TypeError: 1 is not an object!<br> map.set(Symbol(), 2)<br> &#x2F;&#x2F; TypeError: Invalid value used as weak map key</p><p>上面代码中，如果将1和Symbol作为WeakMap的键名，都会报错。</p><p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p><p>下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。</p><p> var wm &#x3D; new WeakMap();<br> var element &#x3D; document.querySelector(“.element”);<br> wm.set(element, “Original”);<br> wm.get(element) &#x2F;&#x2F; “Original”<br> element.parentNode.removeChild(element);<br> element &#x3D; null;<br> wm.get(element) &#x2F;&#x2F; undefined</p><p>上面代码中，变量wm是一个WeakMap实例，我们将一个DOM节点element作为键名，然后销毁这个节点，element对应的键就自动消失了，再引用这个键名就返回undefined。</p><p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p><p> var wm &#x3D; new WeakMap();<br> wm.size<br> &#x2F;&#x2F; undefined<br> wm.forEach<br> &#x2F;&#x2F; undefined<br> 前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。<br> let myElement &#x3D; document.getElementById(‘logo’);<br> let myWeakmap &#x3D; new WeakMap();<br> myWeakmap.set(myElement, {timesClicked: 0});<br> myElement.addEventListener(‘click’, function() {<br>  let logoData &#x3D; myWeakmap.get(myElement);<br>  logoData.timesClicked++;<br>  myWeakmap.set(myElement, logoData);<br> }, false);</p><p>上面代码中，myElement是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是myElement。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。</p><p>WeakMap的另一个用处是部署私有属性。</p><p> let _counter &#x3D; new WeakMap();<br>let_action &#x3D; new WeakMap();<br> class Countdown {<br>  constructor(counter, action) {<br>   _counter.set(this, counter);<br>   _action.set(this, action);<br>  }<br>  dec() {<br>   let counter &#x3D; _counter.get(this);<br>   if (counter &lt; 1) return;<br>    counter–;<br>   _counter.set(this, counter);<br>   if (counter &#x3D;&#x3D;&#x3D; 0) {<br>    _action.get(this)();<br>   }<br>  }<br> }<br> let c &#x3D; new Countdown(2, () &#x3D;&gt; console.log(‘DONE’));<br> c.dec()<br> c.dec()<br> &#x2F;&#x2F; DONE</p><p>上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第九章 对象的扩展</title>
    <link href="/2022/06/14/ECAMScript-nine-chart/"/>
    <url>/2022/06/14/ECAMScript-nine-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><p> var foo &#x3D; ‘bar’;<br> var baz &#x3D; {foo};<br> baz &#x2F;&#x2F;{foo:’bar’}</p><p> &#x2F;&#x2F;等同于<br> var baz &#x3D; {foo:foo};<br>说明，ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量，下面是另一个例子。</p><p> function f(x,y){<br>  return {x,y}<br> }<br> &#x2F;&#x2F;等同于</p><p> function f(x,y){<br>  return {x:x,y:y};<br> }</p><p> f(1,2) &#x2F;&#x2F;Object{x:1,y:2}<br>除了属性简写，方法也可以简写</p><p> var 0 &#x3D;{<br>  method(){<br>   return “Hello!”;<br>  }<br> };</p><p> &#x2F;&#x2F;等同于</p><p> var 0 &#x3D; {<br>  method: function(){<br>   return “Hello!”;<br>  }<br> };<br>下面是一个实例的例子。</p><p> var birth &#x3D; ‘2000&#x2F;01&#x2F;01’;</p><p> var Person &#x3D;{<br>  name:’张三’,<br>  birth,<br>  &#x2F;&#x2F;等同于调用birth:birth,</p><p>  &#x2F;&#x2F;等同于hello:function()…<br>  hello(){ console.log(‘我的名字是’,this.name);}<br> }<br>这种写法用于函数的返回值，将会非常方便。</p><p> function getPoint(){<br>  var x &#x3D;1;<br>  var y &#x3D;10;<br>  return {x,y};<br> }</p><p> getPoint();<br> &#x2F;&#x2F;{x:1,y:10}<br>CommonJS模块输出变量，就非常合适使用简洁写法。</p><p> var ms &#x3D; {};</p><p> function getItem (key){<br>  return key in ms ? ms[key] :null;<br> }</p><p> function setItem (key,value){<br>  ms[key] &#x3D; value;<br> }</p><p> function clear(){<br>  ms &#x3D; {};<br> }</p><p> module.exports &#x3D;{<br>  getItem:getItem,<br>  setItem:setItem,<br>  clear:clear<br> };<br>属性的赋值器(setter)和取值器(getter)，都是采用这种写法</p><p> var cart &#x3D;{<br>  _wheels :4,</p><p>  get wheels(){<br>   return this._wheels;<br>  },</p><p>  set wheels(value){<br>   if(value &lt;this._wheels){<br>    throw new Error(‘数值太小了！’);<br>   }<br>   this._wheels &#x3D; value;<br>  }<br> }</p><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript语言定义对象的属性，有两种方法。</p><p> &#x2F;&#x2F;方法一<br> obj.foo &#x3D; true;</p><p> &#x2F;&#x2F;方法二<br> obj[‘a’ + ‘bc’] &#x3D; 123;<br>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要表达式放在方括号之内。<br>但是，如果使用字面量方式定义对象(使用大括号)，在ES6中只能使用方法一(标示符)定义属性</p><p> var obj &#x3D; {<br>  foo:true,<br>  abc:123<br> };<br>ES6允许字面量定义对象时，用方法二(表达式)作为对象的属性名，即把对象表达式放在方括号内。</p><p> let propKey &#x3D; ‘foo’;</p><p> let obj &#x3D; {<br>  [propKey]:true,<br>  [‘a’ +  ‘bc’] :123<br> };</p><p>下面是另一个例子。</p><p> var lastWord &#x3D; ‘last word’;</p><p> var a &#x3D; {<br>  ‘first word’ : ‘hello’,<br>  [lastWord] :’world’<br> };<br> a[‘first word’] &#x2F;&#x2F;“hello”<br> a[lastWord] &#x2F;&#x2F;“world”<br> a[‘last word’] &#x2F;&#x2F;“world”</p><p>表达式还可以用于定义方法名。</p><p> let  obj  &#x3D; {<br>  <a href="">‘h’ + ‘ello’</a>{<br>   return ‘hi’;<br>  }<br> };<br> object.hello() &#x2F;&#x2F;hi</p><p>注意：属性名表达式与简洁表示法，不能同时使用，会报错</p><p> &#x2F;&#x2F;报错<br> var foo &#x3D; ‘bar’;<br> var bar &#x3D; ‘abc’;<br> var baz &#x3D; {[foo]};</p><p> &#x2F;&#x2F;正确<br> var foo &#x3D; ‘bar’;<br> var baz &#x3D; {[foo]:’abc’}</p><h2 id="方法的anem属性"><a href="#方法的anem属性" class="headerlink" title="方法的anem属性"></a>方法的anem属性</h2><p>函数的name属性，返回函数名，对象方法也是函数，因此也有name属性</p><p> var person &#x3D; {<br>  sayName(){<br>   console.log(this.name);<br>  },<br>  get firstName(){<br>   return “Nicholas”;<br>  }<br> };<br> person.sayName.name &#x2F;&#x2F; “sayName”<br> pserson.firstName.name &#x2F;&#x2F; “get firstName”<br>方法的name属性返回函数名(即方法名)，如果使用了取值函数，则会在方法名前加上get。如果是存执函数，方法名前会加上set。</p><p>有两种特殊情况:bind方法创造的函数，name属性返回的”bound”加上原函数的名字：Function构造函数创造的函数，name属性返回”anonymous”。</p><p> (new Function()).name &#x2F;&#x2F;“anonymous”</p><p> var doSomething &#x3D; function(){<br>  &#x2F;&#x2F;…<br> };<br> doSometthing.bind().name &#x2F;&#x2F;“bound doSomething”</p><p>如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述</p><p> const key1 &#x3D; Symbol(‘description’);<br> const key2 &#x3D; Symbol();<br> let obj &#x3D; {<br>  <a href="">key1</a>{},<br>  <a href="">key2</a>{},<br> };<br> obj[key1].name &#x2F;&#x2F;“[description]”<br> obj[key2].name &#x2F;&#x2F;“”<br>上面代码中，key1对应的Symbol值有描述，key2没有</p><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5比较两个值是否相等，只有两个运算符：相等运算符(&#x3D;&#x3D;)和严格相等运算符(&#x3D;&#x3D;&#x3D;)。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0.JavaScript缺乏一种运算，在所有环境中，只有两个值是一样的，它们就应该相等。</p><p>ES6提出”Same-value equality”(同值相等)算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符(&#x3D;&#x3D;&#x3D;)的行为基本一致。</p><p> Object.is(‘foo’,’foo’)<br> &#x2F;&#x2F;true<br> Object.is({},{})<br> &#x2F;&#x2F;false<br>不同之处只有两个：一是+0不等于-0，而是NaN等于自身。</p><p> +0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;true<br> NaN &#x3D;&#x3D;&#x3D; NaN&#x2F;&#x2F;false<br> Object.is(+0,-0) &#x2F;&#x2F;false<br> Object.is(NaN,NaN) &#x2F;&#x2F;true</p><p>ES5可以通过下面的代码，部署Object.is。</p><p> Object.defineProperty(Object,’is’,{<br>  value:function(x,y){<br>   if(x &#x3D;&#x3D;&#x3D; y){<br>    &#x2F;&#x2F;针对+0不等于-0的情况<br>    return x !&#x3D;&#x3D; 0 || 1&#x2F;x &#x3D;&#x3D;&#x3D; 1&#x2F;y;<br>   }<br>   &#x2F;&#x2F;针对NaN的情况<br>   return x !&#x3D;&#x3D; x &amp;&amp; y !&#x3D;&#x3D;y;<br>  },<br>  configurable :true,<br>  enumerable: false,<br>  writable.true<br> });</p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>Object.assign方法用于对象的合并，将源对象(source)的所有可枚举属性，赋值到目标对象(target)。</p><p> var target &#x3D; {a:1};</p><p> var source1 &#x3D; {b:2};</p><p> var source2 &#x3D; {c:3};</p><p> Object.assign(target,source1,source2);<br> target &#x2F;&#x2F;{a:1,b:2,c:3}<br>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><p> var target &#x3D; {a:1,b:1};</p><p> var source1 &#x3D; {b:2,c:2};<br> var source2 &#x3D; {c;3};</p><p> Object.assign(target,source,sources2);<br> target &#x2F;&#x2F;{a:1,b:2,c:3}<br>如果只有一个参数，Object.assign会直接返回该参数。</p><p> var obj &#x3D;{a;1};<br> Object.assign(obj) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F;true</p><p>如果该参数不是对象，则会先转成对象，然后返回</p><p> typeof Object.assign(2) &#x2F;&#x2F;“object”<br>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错</p><p> Object.assign(undefined)&#x2F;&#x2F;报错<br> Object.assign(null)&#x2F;&#x2F;报错<br>如果非对象参数出现在源对象的位置(即非首参数),那么处理规则有所不同，首先这些参数都会转成对象，如果无法转成对象，就会跳过，这意味着，如果undefined和null不在首参数，就不会报错。</p><p> let obj &#x3D; {a;1};<br> Object.assign(obj,undefined) &#x3D;&#x3D;&#x3D;obj &#x2F;&#x2F;true<br> Object.assign(obj,null) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F;true<br>其他类型的值(即数值、字符串和布尔值)不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p><p> var v1 &#x3D; ‘abc’;<br> var v2 &#x3D; true;<br> var v3 &#x3D; 10;</p><p> var obj &#x3D; Object.assign({},v1,v2,v3);<br> console.log(obj);  &#x2F;&#x2F;{‘0’:’a’,’1’:’b’,’2’:’c’}<br>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果字符串合入目标对象(以字符数组的形式)，数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p><p> Object(true) &#x2F;&#x2F;{[[PrimitiveValue]]:true}<br> Object(10)   &#x2F;&#x2F;{[[PrimitiveValue]]:10}<br> Object(‘abc’) &#x2F;&#x2F;{0:’a’,’1’:”b”,2:”c”,length:3,[[PrimitiveValue]]:”abc”}<br>布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的，只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p><p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性(不拷贝继承属性)，也不拷贝不可枚举的属性(enumerable:fasle)。</p><p> Object.assign({b:’c’},<br>  Object.defineProperty({},’invisible’,{<br>   enumerable:false,<br>   value:’hello’<br>  })<br> )<br> &#x2F;&#x2F;{b:’c’}<br>上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。</p><p>属性名为Symbol值的属性，也会被object.assign拷贝。</p><p> Object.assign({a:’b’},{ [Symbol(‘c’)]: ‘d’ })<br> &#x2F;&#x2F;{a:’b’,Symbol(c):’d’}</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><p> var obj1  &#x3D; {a:{b:1}};<br> var obj2 &#x3D; Object.assign({},obj1);</p><p> obj1.a.b &#x3D; 2;<br> obj2.a.b &#x2F;&#x2F;2<br>上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。</p><p>一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</p><p> var target &#x3D; {a:{b:’c’,d:’e’}}<br> var source &#x3D; {a:{b:’hello’}}<br> Object.assign(target,source)<br> &#x2F;&#x2F;{a:{b:’hello’}}<br>上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{a:{b:’hello’,d:’e’}}的结果。这通常不是开发者想要的，需要特别小心</p><p>有一些函数提供object.assign的定制版本，可以解决浅拷贝的问题，得到身拷贝的合并。</p><p>注意，Object.assign同样可以用来处理数组，但是是把数组看做对象来合并</p><p> Object.assign([1,2,3],[4,5])<br> &#x2F;&#x2F;[4,5,3]</p><h3 id="Object-assign的用途"><a href="#Object-assign的用途" class="headerlink" title="Object.assign的用途"></a>Object.assign的用途</h3><ol><li>为对对象添加属性</li></ol><p> class Point {<br>  constructor(x,y){<br>   Object.assign(this,{x,y});<br>  }<br> }<br>通过Object.assign方法，将x属性和y属性添加到Point类对象实例。</p><ol start="2"><li>为对象添加方法</li></ol><p> Object.assign(SomeClass.propertype,{<br>  someMethod(arg1,arg2){<br>   …<br>  },<br>  anotherMethod(){<br>   …<br>  }<br> });<br> &#x2F;&#x2F;等同于下面的写法<br> SomeClass.prototype.someMethod &#x3D; function (arg1,arg2){<br>  …<br> };<br> SomeClass.propertype.anotherMethod &#x3D; function (){<br>  …<br> };<br>对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p><ol start="3"><li>克隆对象</li></ol><p> function clone(origin){<br>  return Object.assign({},origin);<br> }<br>采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p><p> function clone(origin){<br>  let originProto &#x3D; Object.getPrototypeOf(origin);<br>  return Object.assign(Object.create(originProto),origin);<br> }</p><ol start="4"><li>合并多个对象<br>将多个对象合并到某个对象。</li></ol><p> const merge &#x3D; (target,…sources) &#x3D;&gt; Object.assign(target,…sources);<br>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p><p> const merger &#x3D; (…sources) &#x3D;&gt; Object.assign({},…sources);</p><ol start="5"><li>为属性指定默认值</li></ol><p> const DEFAULTS &#x3D;{<br>  logLevel:0,<br>  outputFormat:’html’<br> };</p><p> function processContent(options){<br>  let options &#x3D; Object.assign({},DEFAULTS,options);<br> }<br>上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULT和options合并成一个对象。否则，将导致DEFAULTS对象的该属性不起作用</p><h2 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h2><p>对象的每个属性都有一个描述对象(Descriptor)，用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</p><p>  let obj &#x3D; {foo:123};<br>  Object.getOwnPropertyDescriptor(obj,’foo’)<br>  &#x2F;&#x2F;{<br>  &#x2F;&#x2F; value:123,<br>  &#x2F;&#x2F; writable:true,<br>  &#x2F;&#x2F;  enumerable:true,<br>  &#x2F;&#x2F;  configurable:true<br>  &#x2F;&#x2F;}<br>描述对象的enumerable属性，称为”可枚举性”，如果该属性为 false，就表示某些操作会忽略当前属性。</p><p>ES5有三个操作会忽略enumerable为false的属性。</p><ul><li><p>for … in循环：只遍历对象自身和继承的可枚举属性</p></li><li><p>Object.kleys():返回对象自身的所有可枚举的属性的键名</p></li><li><p>JSON.stringify();只串行化对象自身的可枚举属性</p></li><li><p>ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。<br>这四个操作中，只有for …in 会返回继承的属性，实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for… in操作，比如对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for…in遍历到。</p></li></ul><p> Object.getOwnPropertyDescriptor(Object.prototype,’toString’).enumerable<br> &#x2F;false</p><p> Object.getOwnPropertyDescriptor([],’length’).enumerable<br> &#x2F;&#x2F;false<br>上面代码中，toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。</p><p>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</p><p> Object.getOwnPropertyDescriptor(class{foo(){}}.prototype,’foo’).enumerable<br> &#x2F;&#x2F;false<br>总的来说，操作中引入继承的属性会让问题复杂化，多数时候，我们只关心对象自身的属性。所以，尽量不要用for …in 循环，而是用Object.keys()代替。</p><h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><p>ES6一共提供了五种遍历对象属性的方法</p><ol><li>for…in</li></ol><p> for…in循环遍历对象自身的和继承的可枚举属性(不含Symbol属性)<br>2. Object.keys(obj)</p><p> Object.keys返回一个数组，包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性)</p><ol start="3"><li>Object.getOwnPropertyNames(obj)</li></ol><p> Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性(不含Symbol属性，但是包括不可枚举属性)。</p><ol start="4"><li>Object.getOwnPropertySymbols(obj)</li></ol><p> Object.getOwnPropertySymbols返回一个数组，包含自身的所有Symbol属性</p><ol start="5"><li>Reflect.ownKeys(obj)</li></ol><p> Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。</p><p>以上5种方法便来对象的属性，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有属性名为数值的属性，按照数字排序。</li><li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li><li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序</li></ul><h2 id="proto-属性，Object-setPrototypeOf-Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-Object-getPrototypeOf" class="headerlink" title="_proto_属性，Object.setPrototypeOf(),Object.getPrototypeOf()"></a>_proto_属性，Object.setPrototypeOf(),Object.getPrototypeOf()</h2><ol><li>__proto__属性</li></ol><p> __proto__属性(前后各两个下划线),用来读取或设置当前对象的prototype对象。目前，所有浏览器(包括IE11)都部署了这个属性。</p><p>  &#x2F;&#x2F;es6的写法<br>  var obj &#x3D; {<br>   method:function(){…}<br>  };<br>  obj.<strong>proto</strong> &#x3D; someOtherObje;</p><p>  &#x2F;&#x2F;es5的写法<br>  var obj &#x3D; Object.create(someOtherObj);<br>  obj.method &#x3D; function(){…};<br> 该属性没有写入ES6的正文，而是写入附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入ES6。只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最后认为这个属性是不存在的。所以，无论是从语义的角度，还是兼容性都不要使用这个属性。而是使用Object.setPropertypeOf()(写操作)、Obejct.getPrototypeOf()(读操作)、Object.create(生成操作)代替。</p><ol start="2"><li>Object.setPrototypeOf()</li></ol><p> Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p><p>  &#x2F;&#x2F;格式<br>  Object.setPrototypeOf(object,prototype)</p><p>  &#x2F;&#x2F;用法<br>  var o &#x3D; Object.setPrototypeOf({},null);<br> 该方法等同于这样的一个函数</p><p>  function (obj,proto){<br>   obj.<strong>proto</strong> &#x3D; proto;<br>   return obj;<br>  }<br> 下面是一个例子</p><p>  let proto &#x3D; {};<br>  let obj &#x3D; {x:10};<br>  Object.setPrototypeOf(obj,proto);</p><p>  proto.y &#x3D;20;<br>  proto.z &#x3D;40;</p><p>  obj.x &#x2F;&#x2F;10<br>  obj.y &#x2F;&#x2F;20<br>  obj.z &#x2F;&#x2F;40<br> 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</p><ol start="3"><li>Object.getPrototypeOf()</li></ol><p> 该方法与setPrototypeOf()方法配套，用于读取一个对象的prototype对象。</p><p>  Object.getPrototypeOf(obj);<br> 例子</p><p>  function Rectangle(){<br>  }<br>  var rec &#x3D; new Rectangle();</p><p>  object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype<br>  &#x2F;&#x2F;true</p><p>  Object.setPrototypeOf(rec,Object.prototype);<br>  Object.getPrototypeOf(rec) &#x3D;&#x3D;&#x3D; Rectangle.prototype<br>  &#x2F;&#x2F;false</p><h2 id="Object-values-Object-entries"><a href="#Object-values-Object-entries" class="headerlink" title="Object.values(),Object.entries()"></a>Object.values(),Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的(不含继承的)所有可能遍历(enumerable)属性的键名。</p><p> var obj &#x3D; { foo:”bar”,baz:42};<br> Object.keys(obj)<br> &#x2F;&#x2F;[“foo”,”baz”]<br>目前ES7又有提案，就是引入Object.values()和Object.entries()和Object.keys配套</p><p> let {keys,value,entries} &#x3D; object;<br> let obj &#x3D; {a:1,b:2,c:3};</p><p> for (let key of keys(obj)){<br>  console.log(key) &#x2F;&#x2F;‘a’,’b’,’c’<br> }</p><p> for (let value of values(obj)){<br>  console.log(value);&#x2F;&#x2F;1,2,3<br> }</p><p> for (let [key,value] of entries(obj)){<br>  console.log([key,value]);&#x2F;&#x2F;[‘a’,1],[‘b’,2],[‘c’,3]<br> }</p><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p>Object.values返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历 (enumerable)属性的键值。</p><p> var obj &#x3D; {foo:”bar”,baz:42 };<br> Object.values(obj)<br> &#x2F;&#x2F;[“bar”,42]</p><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍排列规则一致。</p><p> var obj &#x3D; {100:’a’,2:’b’,7:’c’};<br> Object.values(obj) &#x2F;&#x2F;[‘b’,’c’,’a’]<br>Object.avlue只返回对象自身可遍历的属性</p><p> var obj &#x3D; object.create({},{p:{value:42}});<br> Object.values(obj) &#x2F;&#x2F;[]<br>上面，Object.create方法的第二个参数添加的对象属性(属性p),如果不显式声明，默认不可遍历的。Object.values不会返回这个属性。Object.values会过滤属性名为Symbol值的属性。</p><p>Object.values会过滤属性名为Symbol值的属性。</p><p> Object.values({[Symbol()]:123,foo:’abc’});<br> &#x2F;&#x2F;[‘abc’]<br>如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。</p><p> Object.values(‘foo’)<br> &#x2F;&#x2F;[‘f’,’o’,’o’]<br>上面代码中，字符串会先转成一个类似数组的对象，字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。</p><p>如果参数不是对象，object.value会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，object.values会返回空数组。</p><p> Object.values(42) &#x2F;&#x2F;[]<br> Object.values(true) &#x2F;&#x2F;[]</p><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p>Object.entries方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)属性的键值对数组。</p><p> var obj &#x3D; {foo:’bar’,baz:42};<br> Object.entries(obj)<br> &#x2F;&#x2F;[[“foo”,”bar”],[“baz”,42]]<br>返回值不一样，该方法的行为与Object.values基本一致。<br>如果原对象的属性名是一个Symbol值，该属性会被省略。</p><p> Object.entries({[Symbol()]:123,foo:’abc’});<br> &#x2F;&#x2F;[[‘foo’,’abc’]]<br>上面代码中，原对象有两个属性，Object.entries只输出属性名非Symbol值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。</p><p>Object.entries的基本用途是遍历对象的属性。</p><p> let obj &#x3D; {one:1,two:2};<br> for (let [k,v] of Obejct.entries(obj)){<br>  console.log(<code>$&#123;JSON.stringify(k)&#125;:$&#123;JSON.stringify(v)&#125;</code>);<br> }<br> &#x2F;&#x2F;“one”:1<br> &#x2F;&#x2F;“two”:2<br>Object.entries方法的一个用处是，将对象转为真正的Map结构。</p><p> var obj &#x3D; {foo:’bar’,baz:42 };<br> var map &#x3D; new Map(Object.entries(obj));<br> map &#x2F;&#x2F;Map{foo:”bar”,baz:42}<br>自己实现Object.entries方法，非常简单</p><p> &#x2F;&#x2F;Generator函数的版本<br> function* entries(obj){<br>  for (let key of Object.keys(obj)){<br>   yield [key,obj[key]];<br>  }<br> }<br> &#x2F;&#x2F;非Generator函数的版本<br> function entries(obj){<br>  let arr &#x3D;[];<br>  for (let key of Object.keys(obj)){<br>   arr.push([key,obj[key]]);<br>  }<br>  return arr;<br> }</p><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>目前，ES7有一个提案，将Rest解构赋值&#x2F;扩展运算符(…)引入对象。Babel转码器已经支持这个项功能。</p><ol><li>Rest解构赋值</li></ol><p> 对象的Rest解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上。</p><p>  let {x,y,…z} &#x3D; {x:1,y:2,a:3,b:4};<br>  x&#x2F;&#x2F;1<br>  y&#x2F;&#x2F;2<br>  z&#x2F;&#x2F;{a:3,b:4}<br> 上面代码中，变量z是Rest解构赋值所在的对象。它获取符号右边的所有尚未读取的键(a和b),将它们和它们的值拷贝过来。</p><p> 由于Rest解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。</p><p>  let {x,y,…z} &#x3D; null;&#x2F;&#x2F;运行时报错<br>  let {x,y,…z} &#x3D; undefined;&#x2F;&#x2F;运行时报错<br> Rest解构赋值必须是最后一个参数，否则会报错。</p><p>  let {…x,y,z} &#x3D; obj;&#x2F;&#x2F;句法错误<br>  let {x,…y,…z} &#x3D; obj; &#x2F;&#x2F;句法错误<br> 上面代码中，Rest解构赋值不是最后一个参数，所以会报错。</p><p> 注意，Rest解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值(数组、对象、函数)、那么Rest解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p><p>  let obj &#x3D; {a:{b:1}};<br>  let {…x} &#x3D; obj;<br>  obj.a.b &#x3D; 2;<br>  x.a.b &#x2F;&#x2F;2<br> 上面 代码中，x是Rest解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到Rest解构赋值对它的引用。<br> 另外，Rest解构赋值不会拷贝继承自原型对象的属性。</p><p>  let o1 &#x3D; {a:1};<br>  let 02 &#x3D; {b:2};<br>  o2.<strong>proto</strong> &#x3D;o1;<br>  let o3 &#x3D; {…o2};<br>  o3 &#x2F;&#x2F;{b:2}<br> 对象o3是o2的拷贝，但是只复制了o2自身的属性，没有赋值它的原型对象o1的属性。</p><p> Rest解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p><p>  function baseFunction({a,b}){<br>   &#x2F;&#x2F;…<br>  }<br>  function wrapperFunction({x,y,…restConfig}){<br>   &#x2F;&#x2F;使用x和y参数进行操作<br>   &#x2F;&#x2F;其余参数传给原始函数<br>   return baseFunction(restConfig);<br>  }<br> 原始函数baseFunction结构a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p><ol start="2"><li>扩展运算符</li></ol><p> 扩展运算符(…)用于去除参数对象的所有可遍历属性。拷贝到当前对象之中。</p><p>  let z &#x3D; {a:3,b:4};<br>  let n &#x3D; {…z};<br>  n &#x2F;&#x2F;{a:3,b:4}<br> 这等同于使用Object.assign方法。</p><p>  let aClone &#x3D;{…a};<br>  &#x2F;&#x2F;等同于<br>  let aClone &#x3D; Object.assign ({},a);<br> 扩展运算符可以用于合并两个对象。</p><p>  let ab &#x3D; {…a,…b};<br>  &#x2F;&#x2F;等同于<br>  let ab &#x3D; Object.assign({},a,b);<br> 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><p>  let aWithOverRides &#x3D; {…a,x:1,y:2};<br>  &#x2F;&#x2F;等同于<br>  let aWithOverrides &#x3D; {…a,…{x:1,y:2}};<br>  &#x2F;&#x2F;等同于<br>  let x &#x3D;1,y &#x3D;  2, aWithOverrides &#x3D; {…a,x,y};<br>  &#x2F;&#x2F;等同于<br>  let aWithOverrides &#x3D; Object.assign({},a,{x:1,y:2});<br> a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。者用来修改现有对象部分的部分属性就很方便了</p><p>  let newVersion &#x3D; {<br>   …previousVersion,<br>   name:”New Name” &#x2F;&#x2F;Override the name property<br>  }<br> newVersion对象定义了name属性，其他属性全部复制自previousVersion对象。<br> 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p><p>  let aWithDefaults &#x3D; {x:1,y:2,…a};<br>  &#x2F;&#x2F;等同于<br>  let aWithDefaults &#x3D; object.assign({},{x:1,y:2},a);<br>  &#x2F;&#x2F;等同于<br>  let aWithDefaults &#x3D; Object.assign({x:1,y:2},a);<br> 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p><p>  &#x2F;&#x2F;并不会抛出错误，因为x属性只是被定义，但没有执行<br>  let aWithXGetter &#x3D; {<br>   …a,<br>   get x(){<br>    throws new Error(‘not thrown yet’);<br>   }<br>  };</p><p>  &#x2F;&#x2F;会抛出错误，因为x属性被执行了<br>  let runtimeError &#x3D; {<br>   …a,<br>   …{<br>    get x(){<br>     throws new Error(‘thrown now’);<br>    }<br>   }<br>  };<br> 如果扩展运算符参数是null或者undefined，这两个值会被忽略，不会报错</p><p>  let emptyObject &#x3D; {…null,…undefined};&#x2F;&#x2F;不报错</p><h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象(descriptor)。</p><p> var obj &#x3D; {p:’a’};</p><p> Object.getOwnPropertyDescriptor(obj,’p’)<br> &#x2F;&#x2F;Object{ value :”a”,<br> &#x2F;&#x2F; writable:true,<br> &#x2F;&#x2F; enumerable:true,<br> &#x2F;&#x2F; configurable:true<br> &#x2F;&#x2F;}<br>ES7有一个提案，提出了Object.getOwnPropertyDescriptor方法，返回指定对象所有自身属性(非继承属性)的描述对象。</p><p> const obj &#x3D; {<br>  foo:123,<br>  get bar() { return ‘abc’}<br> };</p><p> Object.getOwnPropertyDescriptors(obj)<br> &#x2F;&#x2F;{ foo:<br> &#x2F;&#x2F;  { value:123,<br> &#x2F;&#x2F;    writable:true,<br> &#x2F;&#x2F;    enumerable:true,<br> &#x2F;&#x2F;    configurable:true},<br> &#x2F;&#x2F;<br> &#x2F;&#x2F; bar:<br> &#x2F;&#x2F;  {   get :[Function:bar],<br> &#x2F;&#x2F;   set : undefined,<br> &#x2F;&#x2F;   enumerable:true,<br> &#x2F;&#x2F;   configurable:true<br> &#x2F;&#x2F;  }<br> &#x2F;&#x2F;}<br>Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值是该属性的描述对象。该方法的实现非常日容易。</p><p> function getOwnPropertyDescriptors(obj){<br>  const result &#x3D; {};<br>  for (let key of Reflect.ownKeys(obj)){<br>   result[key] &#x3D; Object.getOwnPropertyDescriptor(obj,key);<br>  }<br>  return result;<br> }<br>该方法主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p><p> const source &#x3D; {<br>  set foo(value){<br>   console.log(value);<br>  }<br> };</p><p> const target1 &#x3D; {};<br> Object.assign(target1,source);</p><p> Object.getOwnPropertyDescriptor(target1,’foo’)</p><p> &#x2F;&#x2F;{ valuse : undefined,<br> &#x2F;&#x2F; writable:true,<br> &#x2F;&#x2F; enumerable:true,<br> &#x2F;&#x2F; configurable:true }<br>Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p><p> function getOwnPropertyDescriptors(obj){<br>  const result &#x3D;{};<br>  for (let key of Reflect.ownKeys(obj)){<br>   result[key] &#x3D; Object.getOwnPropertyDescriptor(obj,key);<br>  }<br>  return result;<br> }<br>该方法的提出是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p><p> const source &#x3D;{<br>  set foo(value){<br>   console.log(value);<br>  }<br> };<br> const target1 &#x3D; {};<br> Object.assign(target1,source);</p><p> Object.getOwnPropertyDescriptor(target1,’foo’)<br> &#x2F;&#x2F;{ value:undefined,<br> &#x2F;&#x2F; writable:true,<br> &#x2F;&#x2F; enumerable:true,<br> &#x2F;&#x2F; configurable:true<br> &#x2F;&#x2F; }<br>上面的代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Obejct.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p><p>这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正常拷贝。</p><p> const source &#x3D; {<br>  set foo(value){<br>   console.log(value);<br>  }<br> };</p><p> const target2 &#x3D; {};<br> Object.defineProperties(target2,Object.getOwnPropertyDescriptors(source));<br> Object.getOwnPropertyDescriptor(target2,’foo’)<br> &#x2F;&#x2F;{ get: undefined,<br> &#x2F;&#x2F; set:[Function:foo],<br> &#x2F;&#x2F; enumerable:true,<br> &#x2F;&#x2F; configurable:true<br> &#x2F;&#x2F;}<br>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p><p> const shallowMerge &#x3D; (target,source) &#x3D;&gt; Object.defineProperties(<br>  target,<br>  Object.getOwnPropertyDescriptors(source)<br> );<br>Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆岛一个新对象。着属于浅拷贝。</p><p> const clone &#x3D; Object.create(Object.getPrototupeOf(obj),<br>  Object.getOwnPropertyDescriptors(obj));<br>  &#x2F;&#x2F;或者<br>  const shallowClone &#x3D; (obj) &#x3D;&gt; Object.create(<br>   Object.getPrototypeOf(obj),<br>   Object.getOwnPropertyDescriptors(obj)<br>  );<br>上面代码会克隆对象obj。</p><p>另外，Object.getOwnPropertyDescriptors方法可以实现，一个对象继承另一个对象。以前，继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p><p> const obj &#x3D; {<br>  <strong>proto</strong> : prot,<br>  foo:123,<br> };<br>ES6规定__proto__只有浏览器部署，其他环境不用部署，如果去除__proto__，上面代码就要改成下面这样。</p><p> const obj &#x3D; Object.create(prot);<br> obj.foo &#x3D; 123 ;<br> &#x2F;&#x2F;或者<br> const obj &#x3D; Object.assign(<br>  Object.create(prot),<br>  {<br>   foo:123,<br>  }<br> );<br>有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。</p><p> const obj &#x3D; Object.create(<br>  prot,<br>  Object.getOwnPropertyDescriptors({<br>   foo:123,<br>  })<br> );<br>Object.getOwnPropertyDescriptors也可以用来实现Mixin(混入)模式。</p><p> let min &#x3D; (object) &#x3D;&gt; ({<br>  with : (…mixins) &#x3D;&gt; mixins.reduce(<br>   (c,mixin) &#x3D;&gt; Object.create(<br>    c,Object.getOwnPropertyDescriptors(mixin)<br>   ),object)<br> });</p><p> &#x2F;&#x2F;multiple mixins example<br> let a &#x3D; {a:’a’};<br> let b &#x3D; {b:’b’};<br> let c &#x3D; {c:’c’};<br> let d &#x3D; min(c).with(a,b);<br>对象a和b被混入了c对象</p><p>处于完成性的考虑，Obejct.getOwnPropertyDescriptors进入标准以后，还会有Reflect.getOwnPropertyDescriptors方法。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第八章 函数的扩展</title>
    <link href="/2022/06/13/ECAMScript-eight-chart/"/>
    <url>/2022/06/13/ECAMScript-eight-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法</p><p> function log(x,y){<br>  y &#x3D; y|| ‘World’;<br>  console.log(x,y);<br> }<br> log(‘Hello’); &#x2F;&#x2F;Hello World<br> log(‘Hello’,’China’) &#x2F;&#x2F;Hello China<br> log(‘Helllo’,’’) &#x2F;&#x2F;Hello World<br>上面代码检查函数log的参数有没有赋值，如果没有，则指定默认值World，这种写法的缺点在于，如果没有参数y赋值了，但是对应的布尔值为false，则赋值不起作用，就像上面的代码最后一行，参数y等于空字符，结构被改为默认值。</p><p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值</p><p> if(typeof y &#x3D;&#x3D;&#x3D; ‘undefined’){<br>  y &#x3D; ‘World’;<br> }</p><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><p> function log(x,y &#x3D; ‘World’){<br>  console.log(x,y);<br> }<br> log(‘Hello’);<br> log(‘Hello’,’China’) &#x2F;&#x2F;Hello China<br> log(‘Hello’,’’) &#x2F;&#x2F;Hello</p><p>ES6的写法比ES5简介许多，而且非常自然</p><p>除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立即意识到哪些参数是可以省略的，不用查看函数体或文档，其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p><p>参数变量的默认申明的，所以不能用let或const再次声明</p><p> function foo(x &#x3D; 5){<br>  let x &#x3D;1;&#x2F;&#x2F;error<br>  const x &#x3D;2;&#x2F;&#x2F;error<br> }</p><h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><p>参数默认值可以与结构赋值的默认值，结合起来使用</p><p> function foo({x,y&#x3D;5}){<br>  console.log(x,y);<br> }<br> foo({}); &#x2F;&#x2F;undefined,5<br> foo({x:1}); &#x2F;&#x2F;1,5<br> foo({x:1,y:2}) &#x2F;&#x2F;1,2<br> foo() &#x2F;&#x2F;TypeError:Cannot read property ‘x’ of undefined</p><p>另一个对象的结构赋值默认的例子</p><p> function fetch(url,{body &#x3D; ‘’,method &#x3D; ‘GET’,headers &#x3D;{} }){<br>  console.log(method);<br> }</p><p> fetch(‘<a href="http://example.com&/#39;,{}">http://example.com&#39;,{}</a>)<br> &#x2F;&#x2F;“GET”</p><p> fetch(‘<a href="http://example.com/">http://example.com</a>‘)<br> &#x2F;&#x2F;报错</p><p>比较下面两种写法的区别</p><p> &#x2F;&#x2F;写法一<br> function m1({x &#x3D; 0,y &#x3D; 0} &#x3D; {}){<br>  return [x,y];<br> }</p><p> &#x2F;&#x2F;写法二<br> function me({x,y} &#x3D; {x:0,y:0}){<br>  return [x,y];<br> }<br>写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值</p><p>写法而函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p><p> &#x2F;&#x2F;函数没有参数的情况<br> m1()   &#x2F;&#x2F;[0,0]<br> m2()   &#x2F;&#x2F;[0,0]</p><p> &#x2F;&#x2F;x和y都有值的情况<br> m1({x:3,y:8})   &#x2F;&#x2F;[3,8]<br> m2({x:3,y:8})  &#x2F;&#x2F;[3,8]</p><p> &#x2F;&#x2F;x有值，y无值的情况<br> m1({x:3})    &#x2F;&#x2F;[3,0]<br> m2({x:3})    &#x2F;&#x2F;[3,undefined]</p><p> &#x2F;&#x2F;x和y都无值的情况<br> m1({})   &#x2F;&#x2F;[0,0]<br> me({})   &#x2F;&#x2F;[undefined,undefined]</p><p> m1({z:3})  &#x2F;&#x2F;[0,0]<br> me({z:3})  &#x2F;&#x2F;[undefined,undefined]</p><h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数，因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p><p> &#x2F;&#x2F;例一<br> function f(x &#x3D; 1,y){<br>  return [x,y];<br> }</p><p> f()  &#x2F;&#x2F;[1,undefined]<br> f(2) &#x2F;&#x2F;[2,undefined]<br> f(,1) &#x2F;&#x2F;报错<br> f(undefined,1)  &#x2F;&#x2F;[1,1]</p><p> &#x2F;&#x2F;例二<br> function f(x,y &#x3D; 5,z){<br>  return [x,y,z];<br> }<br> f()  &#x2F;&#x2F;[undefined,5,undefined]<br> f(1)  &#x2F;&#x2F;[1,5,undefined]<br> f(1,2)  &#x2F;&#x2F;报错<br> f(1,undefined,2)  &#x2F;&#x2F;[1,5,2]<br>这里有默认值的参数不是尾参数，这时，无法只省略该参数，而不是省略它后面的参数，除非显式输入undefined。</p><p>如果传入undefined，将触发参数等于默认值，null则没有这个效果</p><p> function foo(x&#x3D;5,y&#x3D;6){<br>  console.log(x,y);<br> }</p><p> foo(undefined,null)<br> &#x2F;&#x2F;5 null</p><p>x参数对用undefined,结果触发了默认值，y参数等于null，就没有触发默认值。</p><h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h3><p>指定默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值以后，length属性将失真。</p><p> (function (a){}).length &#x2F;&#x2F;1<br> (function (a &#x3D; 5){}).length &#x2F;&#x2F;0<br> (function (a,b,c &#x3D; 5){}).length &#x2F;&#x2F;2</p><p>length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p><p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。</p><p> (function(…args) {}).length &#x2F;&#x2F;0</p><p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了</p><p> (function (a &#x3D; 0,b,c){}).length &#x2F;&#x2F;0<br> (function (a,b &#x3D; 1,c){}).length &#x2F;&#x2F;1</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。</p><p> var x &#x3D; 1;<br> function f(x,y &#x3D; x){<br>  console.log(y);<br> }<br> f(2)  &#x2F;&#x2F;2<br>上面代码中，参数y的默认值等于x。调用时，由于函数作用域内部的变量x已经生成，所以y等于参数x，而不是全局变量x。如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。</p><p> let x  &#x3D; 1;</p><p> function f(y &#x3D; x){<br>  let x &#x3D;2;<br>  console.log(y)<br> }<br> f() &#x2F;&#x2F;1<br>函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量</p><p> function f(y &#x3D; x){<br>  let x &#x3D;2;<br>  console.log(y);<br> }<br> f() &#x2F;&#x2F;ReferenceError : x is not defined</p><p>这样写也会报错<br> var x &#x3D;1;<br> function foo(x &#x3D; x){<br>  &#x2F;&#x2F;…<br> }<br> foo() &#x2F;&#x2F;ReferenceError : x is not defined<br>函数foo的参数x的默认值也是x。这时，默认值x的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量x，但是默认值在x赋值之前就执行了，所以这时属于暂时性死区，任何对x的报错都会报错。</p><p> let foo &#x3D; ‘outer’;<br> function bar(func &#x3D; x &#x3D;&gt; foo){<br>  ley foo &#x3D;  “inner”;<br>  console.log(func()); &#x2F;&#x2F;outer<br> }<br> bar();<br>函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。</p><p> function bar(func &#x3D;() &#x3D;&gt; foo){<br>  let foo &#x3D; ‘inner’;<br>  console.log(func());<br> }</p><p> bar() &#x2F;&#x2F;ReferenceError: foo is not defined<br>匿名函数里面的foo指向函数外层，但是函数外层并没有声明foo，所以就报错了。</p><p>这有一个更复杂的例子</p><p> var x &#x3D; 1;<br> function foo (x,y &#x3D; function(){ x &#x3D; 2;}){<br>  var x &#x3D; 3;<br>  y();<br>  console.log(x);<br> }<br> foo() &#x2F;&#x2F;3<br>函数foo的参数y的默认值是一个匿名函数，函数foo调用时，它的参数x的值为undefined，所以y函数内部一开始是undefined，后来被重新赋值为2.但是，函数foo内部重新声明了一个x，值为3，这两个x是不一样的，互相不产生影响，因此最后输出3。</p><p>如果将var x &#x3D; 3的var去掉，两个x就是一样的了，最后输出就是2。</p><p> var x &#x3D;1 ;<br> function foo(x,y &#x3D; function(){x &#x3D;2;}){<br>  x &#x3D; 3;<br>  y();<br>  console.log(x);<br> }<br> foo() &#x2F;&#x2F;2</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><p> function throwIfMissing(){<br>  throw new Error(‘Missing parameter’);<br> }<br> function foo(mustBeProvided &#x3D; throwIfMissing()){<br>  return mustBeProvided;<br> }<br> foo();<br> &#x2F;&#x2F;Error: Missing parameter</p><p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出错误。</p><h2 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h2><p>ES6引入rest参数(形式为”…变量名”)，用于获取函数的多余参数，这样就不需要使用argument对象了。rest参数搭配的变量是数组，该变量将多余的参数放入数组中。</p><p> function add(…values){<br>  let sum &#x3D; 0;</p><p>  for(var val of values){<br>   sum +&#x3D; val;<br>  }</p><p>  return sum;<br> }<br> add(2,5,3) &#x2F;&#x2F;10<br>上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数</p><p>下面是一个rest参数替代arguments变量的例子</p><p> &#x2F;&#x2F;arguments变量的写法<br> function sortNumbers(){<br>  return Array.prototype.slice.call(arguments).sort();<br> }</p><p> &#x2F;&#x2F;rest参数的写法<br> const sortNumbers &#x3D; {…numbers} &#x3D;&gt; numbers.sort();<br>可以发现rest参数的写法更加自然也更加简洁</p><p>rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push的例子。</p><p> function push(array, …items){<br>  items.forEach(function(item){<br>   array.push(item);<br>   console.log(item);<br>  });<br> }</p><p> var a &#x3D; [];<br> push(a,1,2,3);<br>注意，rest参数之后不能再有其他参数(即只能是最后一个参数)，否则会报错。</p><p> &#x2F;&#x2F;报错<br> function f(a, …b,c){<br>  &#x2F;&#x2F;…<br> }<br>函数的length属性，不包含rest参数</p><p> (function(a){}).length &#x2F;&#x2F;1<br> (function(…a){}).length &#x2F;&#x2F;0<br> (function(a, …b){}).length &#x2F;&#x2F;1</p><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>扩展运算符(spread)是三个点(…)。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><p> console.log(…[1,2,3])<br> &#x2F;&#x2F;1 2 3</p><p> console.log(1,…[2,3,4],5)<br> &#x2F;&#x2F;1 2 3 4 5</p><p> […document.querySelectorAll(‘div’)]<br> &#x2F;&#x2F;[<div>,<div>,<div>]</p><p>该运算只要用于函数调用。</p><p> function push(array,…items){<br>  array.push(…items);<br> }</p><p> function add(x,y){<br>  return x+y;<br> }</p><p> var numbers &#x3D; [4,38];<br> add(…numbers) &#x2F;&#x2F;42<br>array.push(…items)和add(…numbers)都是函数的调用，都使用了扩展运算符将一个数组变为参数序列</p><p>扩展运算符，可以结合正常函数参数使用，非常灵活</p><h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="替代数组的apply方法"></a>替代数组的apply方法</h3><p>由于扩展运算符可以展开数组，所以不再需要啊apply方法，将数组转为函数的参数了。</p><p> &#x2F;&#x2F;ES5的写法<br> function f(x,y,z){<br>  &#x2F;&#x2F;…<br> }<br> var args &#x3D; [0,1,2];<br> f.apply(null,args);</p><p> &#x2F;&#x2F;ES6的写法<br> function f(x,y,z){<br>  &#x2F;&#x2F; …<br> }</p><p> var args &#x3D; [0,1,2];<br> f(…args);</p><p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。<br> &#x2F;&#x2F;ES5的写法<br> Math.max.apply(null,[14,3,77])</p><p> &#x2F;&#x2F;ES6的写法<br> Math.max(…[14,3,77])</p><p> &#x2F;&#x2F;等同于<br> Math.max(14,3,77)<br>JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值，有了扩展运算符以后，就可以只直接使用Math.max了。</p><p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p><p>  &#x2F;&#x2F;ES5的写法<br> var arr1 &#x3D; [0,1,2];<br> var arr2 &#x3D; [3,4,5];<br> Array.prototype.push.apply(arr1,arr2);</p><p> &#x2F;&#x2F;ES6的写法<br> var arr1 &#x3D; [0,1,2];<br> var arr2 &#x3D; [3,4,5];<br> arr1.push(…arr2);<br>push方法的参数不能是数组，所以只好通过applay方法变通使用push。有了扩展运算符，就可以直接将数组传入push方法。</p><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><ol><li>合并数组</li></ol><p> 扩展运算符提供了数组合并的新写法。</p><p>  &#x2F;&#x2F;ES5<br>  [1,2].concat(more)<br>  &#x2F;&#x2F;ES6<br>  [1,2,…more]</p><p>  var arr1 &#x3D; [‘a’,’b’];<br>  var arr2 &#x3D; [‘c’];<br>  var arr3 &#x3D; [‘d’,’e’];</p><p>  &#x2F;&#x2F;ES5的合并数组<br>  arr1.concat(arr2,arr3);<br>  &#x2F;&#x2F;[‘a’,’b’,’c’,’d’,’e’]<br>2. 与解构赋值结合</p><p>  const[first,…rest] &#x3D; [1,2,3,4,5];<br>  &#x2F;&#x2F;first &#x2F;&#x2F;1<br>  &#x2F;&#x2F;rest  &#x2F;&#x2F;[2,3,4,5]</p><p>  const[first,…rest] &#x3D; [];<br>  first &#x2F;&#x2F;undefined<br>  rest &#x2F;&#x2F;[];</p><p>  const [first,…rest] &#x3D; [“foo”];<br>  &#x2F;&#x2F;first &#x2F;&#x2F;“foo”<br>  &#x2F;&#x2F; rest &#x2F;&#x2F;[]<br> 如果扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><p>  const […butLat,last] &#x3D; [1,2,3,4,5];<br>  &#x2F;&#x2F;报错<br>  const [first,…middle,last] &#x3D; [1,2,3,4,5];<br>  &#x2F;&#x2F;报错</p><ol start="3"><li>函数的返回值</li></ol><p> JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。</p><p>  var dateFields &#x3D; readDateFields(database);<br>  var d &#x3D; new Date(…dateFields);<br> 上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date</p><ol start="4"><li>字符串</li></ol><p> 扩展运算符还可以将字符串转为真正的数组。</p><p>  […’hello’]<br>  &#x2F;&#x2F;[“h”,”e”,”l”,”l”,”o”]<br> 这样写，有一个好处就是，能正确识别32位的Unicode字符</p><p>  ‘x\uD83D\uDE89y’.length &#x2F;&#x2F;4<br>  […’x\uD83D\uDE89y’].length &#x2F;&#x2F;3<br> JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题，因此，正确返回字符串长度的函数，可以这样写</p><p>  function length(str){<br>   return […str].length;<br>  }<br>  length(‘x\uD83D\uDE80y’) &#x2F;&#x2F;3<br> 凡是涉及操作32位Unicode字符的函数，都有这个问题，因此，最好都用扩展运算符改写。</p><p> let str &#x3D; ‘x\uD83D\uDE80y’;</p><p> str.split(‘’).reverse().join(‘’);<br> &#x2F;&#x2F;‘y\uDE80\uD83Dx’</p><p> […str].reverse().join(‘’)<br> &#x2F;&#x2F;‘y\uDE80\uD83Dx’<br>5. 实现Iterator接口的对象</p><p> 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p><p>  var nodeList &#x3D; document.querySelectorAll(‘div’);<br>  var array &#x3D; […nodeList];<br> querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口</p><p> 对于那些没有部署Iterator接口的类似数组对象，扩展运算符就无法将其转为真正的数组。</p><p>  let arrayLike &#x3D; {<br>   ‘0’:’a’,<br>   ‘1’:’b’,<br>   ‘2’:’c’,<br>   length:3<br>  };<br>  &#x2F;&#x2F;TypeError:Cannot spread non-iterable object.<br> let arr &#x3D; […arrayLike];</p><p> 上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错，这时，可以改为使用Array.from方法将arrayLike转为正真的数组。<br>6. Map和Set结构，Generator函数<br> 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。</p><p>  let map &#x3D; new Map([<br>   [1,’one’],<br>   [2,’two’],<br>   [3,’three’],<br>  ])<br>  let arr &#x3D; […map.keys()];&#x2F;&#x2F;[1,2,3]<br> Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p><p>  var go &#x3D; function(){<br>   yield 1 ;<br>   yield 2;<br>   yield 3;<br>  };<br>  […go()]&#x2F;&#x2F;[1,2,3]<br> 变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p><p> 如果对没有iterator接口的对象，使用扩展运算符，将会报错。</p><p> var obj &#x3D; {a:1,b:2};<br> let arr &#x3D; […obj]; &#x2F;&#x2F;TypeError: Cannot spread non-iterable object</p><h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p>函数的name属性，返回该函数的函数名。</p><p> function foo(){}<br> fo.name &#x2F;&#x2F;“foo”<br>这个属性早就被浏览器广泛支持，但是直到es6，才将其写入标准。</p><p>需要注意的是，ES6对这个属性的行为作出了一些修改。如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名。</p><p> var func1 &#x3D; function (){}</p><p> &#x2F;&#x2F;ES5<br> func1.name &#x2F;&#x2F;“”</p><p> &#x2F;&#x2F;ES6<br> func1.name &#x2F;&#x2F;“func1”<br>func1等于一个匿名函数，ES5和ES6的name属性返回值不一样。<br>如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。</p><p> const bar &#x3D; function baz(){}</p><p> &#x2F;&#x2F;ES5<br> bar.name &#x2F;&#x2F;“baz”</p><p> &#x2F;&#x2F;ES6<br> bar.name &#x2F;&#x2F;“baz”<br>Function构造函数返回的函数实例，name属性值为”anonymous”。</p><p> (new Function).name &#x2F;&#x2F;“anonymous”<br>binde返回的函数，name属性值会加上”bound”前缀。</p><p> function foo(){}<br> foo.bind({}).name &#x2F;&#x2F;“bound foo”</p><p> (function(){}).bind({}).name  &#x2F;&#x2F;“bound”</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6允许使用”箭头”(&#x3D;&gt;)定义函数。</p><p> var f &#x3D; v &#x3D;&gt; v;<br>上面的箭头函数等同于；</p><p> var f &#x3D; function (v){<br>  return v;<br> }</p><p>如果箭头函数不需要参数或需要多个参数，就是用一个圆括号代表参数部分。</p><p> var f &#x3D; () &#x3D;&gt; 5;<br> &#x2F;&#x2F;等同于<br> var f &#x3D; function () {return 5};</p><p> var sum &#x3D; (num1,num2) &#x3D;&gt; num1 + num2;<br> &#x2F;&#x2F;等同于<br> var sum &#x3D; function(num1,num2){<br>  return num1 + num2;<br> }<br>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回</p><p> var sum &#x3D; (num1,num2) &#x3D;&gt; {return num1 + num2;}<br>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p><p> var getTempItem &#x3D; id &#x3D;&gt; ({id:id,name:”Temp”});<br>箭头函数可以与变量解构结合使用。</p><p> const full &#x3D; ({first,last}) &#x3D;&gt; first + ‘ ‘ +last;</p><p> &#x2F;&#x2F;等同于<br> function full(person){<br>  return person.first + ‘’ +person.last;<br> }<br>箭头函数使得表达更加简洁</p><p> const isEven &#x3D; n &#x3D;&gt; n%2 &#x3D;&#x3D; 0;<br> const square &#x3D; n &#x3D;&gt; n*n;<br>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p><p>箭头函数的一个用处是简化回调函数。</p><p> &#x2F;&#x2F;正常函数写法<br> [1,2,3].map(function (x){<br>  return x * x;<br> });<br> &#x2F;&#x2F;箭头函数写法<br> [1,2,3].map(x &#x3D;&gt; x*x);</p><p> &#x2F;&#x2F;正常函数写法<br> var result &#x3D; values.sort(function (a,b){<br>  return a - b;<br> });<br> &#x2F;&#x2F;箭头函数写法<br> var result &#x3D; values.sort((a,b) &#x3D;&gt; a-b);<br>同样，rest参数与箭头函数也可以混合使用</p><p> const numbers &#x3D; (…nums) &#x3D;&gt; nums;</p><p> numbers(1,2,3,4,5)<br> &#x2F;&#x2F;[1,2,3,4,5]</p><p> const headAndTail &#x3D; (head, …tail) &#x3D;&gt; [head,taill];</p><p> headAndTail(1,2,3,4,5)<br> &#x2F;&#x2F;[1,[2,3,4,5]]</p><h3 id="箭头函数使用注意点"><a href="#箭头函数使用注意点" class="headerlink" title="箭头函数使用注意点"></a>箭头函数使用注意点</h3><ol><li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体中不存在，如果要用，使用Rest参数代替</li><li>不可以使用yield命令，因此箭头函数不能用作Generator函数</li></ol><p>第一点尤其值得注意，this对象的指向是可变的，但是在箭头函数内，它是固定的</p><p> function foo(){<br>  setTimeout(() &#x3D;&gt; {<br>   console.log(‘id’,this.id);<br>  },100);<br> }<br> var id &#x3D; 21;</p><p> foo.call({id:42});<br> &#x2F;&#x2F;id:42<br>setTimeout的参数是一个箭头函数，这个箭头函数的定义生效在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这是应该输出21.但是，箭头导致this总是指向函数定义生效时所在的对象，所以输出的是42。</p><p>箭头函数可以让setTimeout里面的this，绑定定义时所在作用域，而不是指向运行时坐在的作用域。</p><p> function Timer(){<br>  this.s1 &#x3D;0;<br>  this.s2 &#x3D;0;<br>  &#x2F;&#x2F;箭头函数<br>  setInterval(() &#x3D;&gt; this.s1++,1000);</p><p>  &#x2F;&#x2F;普通函数<br>  setInterval(function(){<br>   this.s2++;<br>  },1000);<br> }</p><p> var timer new Timer();</p><p> setTimeout(() &#x3D;&gt; console.log(‘s1:’,timer.s1),3100);<br> setTimeout(() &#x3D;&gt; console.log(‘s2:’,timer.s2),3100);<br> &#x2F;&#x2F;s1:3<br> &#x2F;&#x2F;s2:0<br>Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域(即Timer函数)，后者的this指向运行时所在的作用域(全局对象)。所以，3100毫秒之后，timer.s1被更新了三次，而timer.s2一次都没有更新。</p><p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。</p><p> var handler &#x3D; {<br>  id:’123456’,</p><p>  init:function(){<br>   document.addEventListener(‘click’,<br>   event &#x3D;&gt; this.doSomething(event.type),false);<br>  },</p><p>  doSomething: function(type){<br>   console.log(‘Handling’ + type + ‘for’ + this.id);<br>  }<br> };<br>init方法中使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p><p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正因为它没有this，所以也就不能用作构造函数。</p><p>所以，箭头函数转成ES5的代码如下</p><p> &#x2F;&#x2F;ES6<br> function foo(){<br>  setTimeout(() &#x3D;&gt; {<br>   console.log(‘id:’,this.id);<br>  },100);<br> };</p><p> &#x2F;&#x2F;ES5<br> function foo(){<br>  var _this &#x3D; this;</p><p>  setTimeout(function (){<br>   console.log(“id:”,_this.id);<br>  },100);<br> };<br>请问下面的代码之中有几个this?</p><p> function foo(){<br>  return () &#x3D;&gt;{<br>   return () &#x3D;&gt; {<br>    return () &#x3D;&gt;{<br>     console.log(‘id:’,this.id);<br>    };<br>   };<br>  };<br> }<br> var f &#x3D; foo.call({id:1});</p><p> var t1 &#x3D; f.call({id:2})()();  &#x2F;&#x2F;id:1<br> var t2 &#x3D; f().call({id:3})(); &#x2F;&#x2F;id:1<br> var t3 &#x3D; f()().call({id:4}); &#x2F;&#x2F;id: 1<br>上面代码，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果，因为所有内层函数都是箭头函数，都没有自己的this，它们的this都是最外层foo函数的this。</p><p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p><p> function foo(){<br>  setTimeout(() &#x3D;&gt;{<br>   console.log(‘args:’,arguments);<br>  },100);<br> }</p><p> foo(2,4,6,8)<br> &#x2F;&#x2F;args:[2,4,6,8]<br>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p><p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法改变this的指向</p><p> (function(){<br>  return[<br>   (() &#x3D;&gt; this.x).bind({x:’inner’})()<br>  ];<br> }).call({x:’outer’});<br> &#x2F;&#x2F;[‘outer’]<br>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。<br>长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this,很大程度上解决了这个困扰。</p><h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</p><p> function ionsert(value){<br>  return {into:function (array){<br>   return {after: function (afterValue){<br>    array.splice(array.indexOf(afterValue) + 1,0,value);<br>    return array;<br>   }};<br>  }};<br> }<br> insert(2).into([1,3]).after.(1);&#x2F;&#x2F;[1,2,3]<br>上面这个函数，可以使用箭头函数改写。</p><p> let insert &#x3D; (value) &#x3D;&gt; ({into:(array) &#x3D;&gt; ({after:(afterValue) &#x3D;&gt;{<br>   array.splice(array.indexOf(afterValue) + 1, 0,value);<br>   return array;<br>  }})<br> });<br> insert(2).into([1,3]).after(1);&#x2F;&#x2F;[1,2,3];</p><p>下面是一个部署管道机制(pipeline)的例子，即前一个函数的输出是后一个函数的输入。</p><p> const pipeline &#x3D;(…funcs) &#x3D;&gt;<br>  varl &#x3D;&gt; funcs.reduce((a,b) &#x3D;&gt; b(a),val);<br> const plus1 &#x3D; a &#x3D;&gt; a + 1;<br> const mult2 &#x3D; a &#x3D;&gt; a * 2;<br> const addThenMult &#x3D; pipeline(plus1,mult2);</p><p> addThenMult(5);<br> &#x2F;&#x2F;12<br>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><p> const plus1 &#x3D; a &#x3D;&gt; a +1;<br> const mult2 &#x3D; a &#x3D;&gt; a *2;</p><p> mult2(plus1(5))<br> &#x2F;&#x2F;12</p><h2 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h2><p>箭头函数可以绑定this对象，大大减少了显示绑定this对象的写法(call、apply、bind)。但是，箭头函数并不适用于所有场合，所以ES7提出了”函数绑定”(function bind)运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p><p>函数绑定运算符是并排的两个双冒号(::),双冒号左边是一个对象，右边是一个函数。该运算会自动将左边的对象，作为上下文环境(即this对象)，绑定到右边的函数上面。</p><p> foo::bar;<br> &#x2F;&#x2F;等同于<br> bar.bind(foo);</p><p> foo::bar(…arguments);<br> &#x2F;&#x2F;等同于<br> bar.apply(foo,arguments);</p><p> const hasOwnProperty &#x3D; Object.prototype.hasOwnProperty;<br> function hasOwn(obj,key){<br>  return obj::hasOwnProperty(key);<br> }<br>如果双冒号左边为空，右边是一个对象方法，则等于将该对象绑定在该对象上面。</p><p> var method &#x3D; obj :: obj.foo;<br> &#x2F;&#x2F;等同于</p><p> var method &#x3D; ::obj.foo;</p><p> let log &#x3D; :: console.log;<br> &#x2F;&#x2F;等同于<br> var log &#x3D; console.log.bind(console);<br>由于双冒号运算符返回的还是原对象，因此，可以采用链式写法。</p><p> &#x2F;&#x2F;例一<br> import {map,takeWhile,forEach } form “iterlib”;</p><p> getPlayers()</p><p> ::map(x &#x3D;&gt; x.character())<br> ::takeWhile(x &#x3D;&gt; x.strength &gt;100)<br> ::forEach(x &#x3D;&gt; console.log(x));</p><p> &#x2F;&#x2F;例二<br> let {find,html} &#x3D; jake;</p><p> document.querySelectorAll(“div.myClass”);<br> ::find(“p”)<br> ::html(“hahaha”);</p><h2 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h2><h3 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h3><p>尾调用(Tail Call) 是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某一个函数的最后一步是调用另一个函数。</p><p> function f(x){<br>  return g(x);<br> }<br>函数f的最后一步是调用函数g，这就叫尾调用。</p><p> &#x2F;&#x2F;情况一<br> function f(x){<br>  let y &#x3D; g(x);<br>  return y;<br> }<br> &#x2F;&#x2F;情况二<br> function f(x){<br>  return g(x) +1;<br> }<br> &#x2F;&#x2F;情况三<br> function f(x){<br>  g(x);<br> }<br>上面这三种情况都不是尾调用，情况一是电泳函数g之后，还有赋值操作，所以不属于尾调用。情况二属于调用后还有操作。<br>情况三同</p><p> function f(x){<br>  g(x);<br>  return undefined;<br> }<br>所以也不是尾调用。</p><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><p> function f(x){<br>  if (x &gt; 0){<br>   return m(x)<br>  }<br>  return n(x);<br> }<br>函数m和n都属于尾调用，因为它们都是函数f的最后一步操作</p><h3 id="尾调用优化-1"><a href="#尾调用优化-1" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”(call frame),保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个”调用栈”(call stack)。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><p> function f(){<br>  let m &#x3D;1;<br>  let n &#x3D;2;<br>  return g(m + n);<br> }<br> f();</p><p> &#x2F;&#x2F;等同于<br> function f(){<br>  return g(3);<br> }<br> f();</p><p> &#x2F;&#x2F;等同于<br> g(3);<br>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧。只保留g(3)的调用帧。</p><p>这就叫做”尾调用优化”(Tail call optimization)，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这既是”尾调用优化”的意义</p><p>注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行”尾调用优化”。</p><p> function addOne(a){<br>  var one &#x3D;1;<br>  function inner(b){<br>   return b + one;<br>  }<br>  return inner(a);<br> }<br>上面的函数不会进行尾调用优化，因为内层函数(inner)用到了外层addOne的内部变量one。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<br>递归非常耗内存，因为需要同时保存成千上万个调用帧，很容易发生”栈溢出”错误(stack overflow)。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生”栈溢出”错误</p><p> functioon factorial(n){<br>  if(n &#x3D;&#x3D;&#x3D;1) return 1;<br>  return n * factorial(n - 1);<br> }<br> factorial(5) &#x2F;&#x2F;120<br>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度O(n)。</p><p>如果改成尾递归，只保留一个调用记录，复杂度为O(1)。</p><p> function factorial(n,total){<br>  if (n &#x3D;&#x3D;&#x3D; 1) return total;<br>  return factorial(n -1 ,n * tatal);<br> }<br> factorial(5,1) &#x2F;&#x2F;120</p><p>还有一个比较著名的例子，就是计算fibonacci数列，也能充分说明尾递归优化的重要性，如果是非尾递归的fibonacci递归方法</p><p> function Fibonacci (n){<br>  if (n &lt;&#x3D; 1){<br>   return 1;<br>  }<br>  return Fibonacci(n -1) +Fibonacci(n -2);<br> }<br> Fibonacci(10);&#x2F;&#x2F;  89<br> &#x2F;&#x2F;Fibonacci(100)<br> &#x2F;&#x2F;Finbonacc(500)<br> &#x2F;&#x2F;堆栈溢出了<br>如果我们使用尾递归优化过的fibonacci递归算法</p><p> function Finbonacci2(n ,ac1 &#x3D;1,ac2 &#x3D; 1){<br>  if(n &lt;&#x3D; 1){ return ac2};</p><p>  return Fibonacci2(n-1,ac2,ac1 + ac2);<br> }<br> Fibonacci2(100) &#x2F;&#x2F;573147844013817200000<br> Fibonacci2(1000) &#x2F;&#x2F;7.0330367711422765e+208<br> Fibonacci2(10000) &#x2F;&#x2F;Infinity<br>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程与雅安将其写入语言规格。ES6也是如此，所有ECMAScript的实现，都必须部署”尾调用优化”。这就是说，ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数factorial需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p><p> function tailFactorial(n,total){<br>  if (n &#x3D;&#x3D;&#x3D; 1)<br>   return total;<br>  return tailFactorial(n-1,n *total);<br> }</p><p>   function factorial(n){<br>  return tailFactorial(n,1);<br> }<br> factorial(5); &#x2F;&#x2F;120<br>上面代码通过一个正常形式的阶乘函数factorial,调用尾递归函数tailFactorial，看起来就正常多了。</p><p>函数式编程有一个概念，叫做柯里化(currying),意思是将多参数的函数转化成单参数的形式。这里也可以使用柯里化。</p><p> function currying(fn,n){<br>  return function (m){<br>   return fn.call(this,m,n);<br>  }<br> }</p><p> function tailFactorial(n,total){<br>  if (n &#x3D;&#x3D;&#x3D; 1) return total;<br>  return tailFactorial(n-1,n*total);<br> }</p><p> const factorial &#x3D; currying(tailFactor,1);</p><p> factorial(5) &#x2F;&#x2F;120<br>上面代码通过柯里化，将尾递归函数tailFactorial变为只接受1个参数的factorial。</p><p>第二种方法就简单多了，就是采用ES6的函数默认值</p><p> function factorial(n,total &#x3D; 1){<br>  if (n &#x3D;&#x3D;&#x3D; 1)<br>   return total;<br>  return factorial(n-1,n * total);<br> }<br> factorial(5) &#x2F;&#x2F;120<br>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p><p>总结一下，递归本质上是一个循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6的尾调用优化只在严格模式下开启，正常模式是无效的</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>func.arguments:返回调用时函数的参数</li><li>func.caller：返回调用当前函数 的那个函数</li></ul><p>尾调用优化发生时，函数调用栈会改写，因此上面两个变量会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效</p><p> function restricted(){<br>  “use strict”;<br>  restructed.caller;&#x2F;&#x2F;报错<br>  restricted.arguments;&#x2F;&#x2F;报错<br> }<br> restricted();</p><h2 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h2><p>ES7有一个提案，允许函数的最后一个参数有尾逗号</p><p>目前，函数定义和调用时，都不允许有参数的尾逗号</p><p> function clownsEverywhere(param1,param2){<br>  &#x2F;&#x2F;…<br> }<br> clownsEverywhere(‘foo’,’bar’);<br>如果以后要遭函数的定义之中添加参数，就势必还要添加一个逗号，这对版本管理系统来说，就会显示，添加逗号的哪一行也发生了变动。这看上去有点冗余，因此，新提案允许定义和调用时，尾部直接有一个逗号。</p><p> function clownsEverywhere(param1,param2,){}</p><p> clownsEverywhere(‘foo’,’bar’,);</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jquery.validate.js插件的使用心得</title>
    <link href="/2022/06/13/jquery-validate/"/>
    <url>/2022/06/13/jquery-validate/</url>
    
    <content type="html"><![CDATA[<h1 id="jquery-validate-js的表单验证使用心得"><a href="#jquery-validate-js的表单验证使用心得" class="headerlink" title="jquery.validate.js的表单验证使用心得"></a>jquery.validate.js的表单验证使用心得</h1><p>最近又是有一个项目，需求用户提交表单，却足足有65个字段需要提交，其中包括必填项和选填项。包括手机、固话、邮件、时间选择器、图片上传、验证码等。</p><h2 id="什么是表单验证"><a href="#什么是表单验证" class="headerlink" title="什么是表单验证"></a>什么是表单验证</h2><h3 id="默认校验规则"><a href="#默认校验规则" class="headerlink" title="默认校验规则"></a>默认校验规则</h3><p> (1)required:true               必输字段<br> (2)remote:”check.php”          使用ajax方法调用check.php验证输入值<br> (3)email:true                  必须输入正确格式的电子邮件<br> (4)url:true                    必须输入正确格式的网址<br> (5)date:true                   必须输入正确格式的日期<br> (6)dateISO:true                必须输入正确格式的日期(ISO)，例如：2009-06-23，1998&#x2F;01&#x2F;22 只验证格式，不验证有效性<br> (7)number:true                 必须输入合法的数字(负数，小数)<br> (8)digits:true                 必须输入整数<br> (9)creditcard:                 必须输入合法的信用卡号<br> (10)equalTo:”#field”           输入值必须和#field相同<br> (11)accept:                    输入拥有合法后缀名的字符串（上传文件的后缀）<br> (12)maxlength:5                输入长度最多是5的字符串(汉字算一个字符)<br> (13)minlength:10               输入长度最小是10的字符串(汉字算一个字符)<br> (14)rangelength:[5,10]         输入长度必须介于 5 和 10 之间的字符串”)(汉字算一个字符)<br> (15)range:[5,10]               输入值必须介于 5 和 10 之间<br> (16)max:5                      输入值不能大于5<br> (17)min:10                     输入值不能小于10</p><h3 id="默认的提示"><a href="#默认的提示" class="headerlink" title="默认的提示"></a>默认的提示</h3><p> messages: {<br>     required: “This field is required.”,<br>     remote: “Please fix this field.”,<br>     email: “Please enter a valid email address.”,<br>     url: “Please enter a valid URL.”,<br>     date: “Please enter a valid date.”,<br>     dateISO: “Please enter a valid date (ISO).”,<br>     dateDE: “Bitte geben Sie ein gltiges Datum ein.”,<br>     number: “Please enter a valid number.”,<br>     numberDE: “Bitte geben Sie eine Nummer ein.”,<br>     digits: “Please enter only digits”,<br>     creditcard: “Please enter a valid credit card number.”,<br>     equalTo: “Please enter the same value again.”,<br>     accept: “Please enter a value with a valid extension.”,<br>     maxlength: $.validator.format(“Please enter no more than {0} characters.”),<br>     minlength: $.validator.format(“Please enter at least {0} characters.”),<br>     rangelength: $.validator.format(“Please enter a value between {0} and {1} characters long.”),<br>     range: $.validator.format(“Please enter a value between {0} and {1}.”),<br>     max: $.validator.format(“Please enter a value less than or equal to {0}.”),<br>     min: $.validator.format(“Please enter a value greater than or equal to {0}.”)<br> }</p><h3 id="Jquery-Validate-自定义验证规则"><a href="#Jquery-Validate-自定义验证规则" class="headerlink" title="Jquery Validate 自定义验证规则"></a>Jquery Validate 自定义验证规则</h3><p>addMethod(name,method,message)方法：</p><p>参数name 是添加的方法的名字</p><p>参数method是一个函数,接收三个参数(value,element,param) value 是元素的值,element是元素本身<br>param是参数,我们可以用addMethod 来添加除built-in Validation methods 之外的验证方法</p><p>比如有一个字段,只能输一个字母,范围是a-f,写法如下:</p><p> $.validator.addMethod(“af”,function(value,element,params){<br>  if(value.length&gt;1){<br>   return false;<br>  }<br>  if(value&gt;&#x3D;params[0] &amp;&amp; value&lt;&#x3D;params[1]){<br>   return true;<br>  }else{<br>   return false;<br>  }<br> },”必须是一个字母,且a-f”);</p><h2 id="Demo及使用方法"><a href="#Demo及使用方法" class="headerlink" title="Demo及使用方法"></a>Demo及使用方法</h2><h3 id="将校验规则写到控件中"><a href="#将校验规则写到控件中" class="headerlink" title="将校验规则写到控件中"></a>将校验规则写到控件中</h3><p>导入js文件</p> <script src="../js/jquery.js" type="text/javascript"></script>   <script src="../js/jquery.validate.js" type="text/javascript"></script>   <script src="./js/jquery.metadata.js" type="text/javascript"></script>   <script src="../js/messages_cn.js" type="text/javascript"></script>  //这是单独放一个文件夹的情况<h3 id="HTML代码"><a href="#HTML代码" class="headerlink" title="HTML代码"></a>HTML代码</h3> <form id="supplierForm" action="">  <p>  …</p> </form><h3 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h3><p> &#x2F;&#x2F;补充自定义的验证方法。<br>   &#x2F;&#x2F; 联系电话(手机&#x2F;电话皆可)验证<br>    jQuery.validator.addMethod(“isPhone”,function(value,element) {<br>        var length &#x3D; value.length;<br>        var mobile &#x3D; &#x2F;^1(3|4|5|7|8)\d{9}$&#x2F;;<br>        var tel &#x3D; &#x2F;^((0\d{2,3})-)(\d{7,8})(-(\d{3,}))?$&#x2F;;<br>        return this.optional(element) || (tel.test(value) || mobile.test(value));<br>    }, “请正确填写电话”);<br>    jQuery.validator.addMethod(“isSpecialChar”, function(value, element) {<br>        var pattern &#x3D; new RegExp(“[&#96;~#$^&amp;<em>&#x3D;|{}&#x2F;?~@#￥……&amp;</em>|【】+&quot;\\]”);<br>        var specialStr &#x3D; “”;<br>        for(var i&#x3D;0;i&lt;value.length;i++){<br>             specialStr +&#x3D; value.substr(i, 1).replace(pattern, ‘’);<br>        }<br>        if( specialStr &#x3D;&#x3D; value){<br>            return true;<br>        }<br>        return false;<br>    }, “不能包含特殊字符”);</p><h3 id="开始验证"><a href="#开始验证" class="headerlink" title="开始验证"></a>开始验证</h3><p> $(“#supplierForm”).validate({</p><p>  onfocusout: function(element) { $(element).valid();},<br>  &#x2F;&#x2F;这一段的作用是使得表单变成失去焦点验证<br>     rules:{<br>         telephone:{<br>             required:true,<br>             isSpecialChar:true,<br>             isPhone:true<br>         }<br>     },<br>    messages: {<br>         telephone:{<br>             required:”请输入公司电话(固话或移动电话)”<br>         }<br>    },<br> submitHandler: function(){<br>     &#x2F;&#x2F;优先验证验证码<br>  $(“#captcha”).removeClass(“red”);<br>  var captcha &#x3D; $.trim($(“#captcha”).val().toLowerCase());<br>     if (captcha &#x3D;&#x3D; “”) {<br>      layer.alert(“验证码还没填写！”, {<br>      icon: 2,<br>      skin: ‘layer-ext-moon’<br>    });<br>         return;<br>     }<br>  if(businesslicence.val() &#x3D;&#x3D; “”){<br>   layer.alert(“营业执照附件未上传!”, {<br>      icon: 2,<br>      skin: ‘layer-ext-moon’<br>    });<br>   return;<br>  }<br>  &#x2F;&#x2F;发送ajax请求<br>  $.ajax({<br>   url : ‘${base}&#x2F;supplierSave.jspx’,<br>   type : ‘post’,<br>   dataType : ‘json’,<br>   data : $(“#supplierForm”).serializeArray(),<br>   type : “post”, &#x2F;&#x2F;请求方式<br>   success : function(data) {<br>    …<br>   },<br>   error : function(data) {<br>    …<br>   }<br>  });<br>  }<br> }) ;</p><p>附录，一些常用的验证规则补充在validate的方法里的:</p><p> &#x2F;&#x2F; 字符验证<br> jQuery.validator.addMethod(“stringCheck”, function(value, element) {<br>  return this.optional(element) || &#x2F;^[u0391-uFFE5w]+$&#x2F;.test(value);<br> }, ”只能包括中文字、英文字母、数字和下划线”);</p><p> &#x2F;&#x2F; 中文字两个字节<br> jQuery.validator.addMethod(“byteRangeLength”, function(value, element, param) {<br>  var length &#x3D; value.length;<br>  for(var i &#x3D; 0; i &lt; value.length; i++){<br>   if(value.charCodeAt(i) &gt; 127){<br>    length++;<br>   }<br>  }<br>  return this.optional(element) || ( length &gt;&#x3D; param[0]&amp;&amp;length &lt;&#x3D; param[1] );<br> }, ”请确保输入的值在3-15个字节之间(一个中文字算2个字节)”);</p><p> &#x2F;&#x2F; 身份证号码验证<br> jQuery.validator.addMethod(“isIdCardNo”, function(value, element) {<br>  return this.optional(element) || isIdCardNo(value);<br> }, ”请正确输入您的身份证号码”);</p><p> &#x2F;&#x2F; 手机号码验证<br> jQuery.validator.addMethod(“isMobile”, function(value, element) {<br>  var length &#x3D; value.length;<br>  var mobile &#x3D; &#x2F;^(((13[0-9]{1})|(15[0-9]{1}))+d{8})$&#x2F;;<br>  return this.optional(element) || (length &#x3D;&#x3D; 11 &amp;&amp; mobile.test(value));<br> }, ”请正确填写您的手机号码”);</p><p> &#x2F;&#x2F; 电话号码验证<br> jQuery.validator.addMethod(“isTel”, function(value, element) {<br>  var tel &#x3D; &#x2F;^d{3,4}-?d{7,9}$&#x2F;; &#x2F;&#x2F;电话号码格式010-12345678<br>  return this.optional(element) || (tel.test(value));<br> }, ”请正确填写您的电话号码”);</p><p> &#x2F;&#x2F; 联系电话(手机&#x2F;电话皆可)验证<br> jQuery.validator.addMethod(“isPhone”, function(value,element) {<br>  var length &#x3D; value.length;<br>  var mobile &#x3D; &#x2F;^(((13[0-9]{1})|(15[0-9]{1}))+d{8})$&#x2F;;<br>  var tel &#x3D; &#x2F;^d{3,4}-?d{7,9}$&#x2F;;<br>  return this.optional(element) || (tel.test(value) || mobile.test(value));</p><p> }, ”请正确填写您的联系电话”);</p><p> &#x2F;&#x2F; 邮政编码验证<br> jQuery.validator.addMethod(“isZipCode”, function(value, element) {<br>  var tel &#x3D; &#x2F;^[0-9]{6}$&#x2F;;<br>  return this.optional(element) || (tel.test(value));<br> }, ”请正确填写您的邮政编码”);</p><p> &#x2F;&#x2F;字母数字<br> jQuery.validator.addMethod(“alnum”, function(value, element) {<br>  return this.optional(element) || &#x2F;^[a-zA-Z0-9]+$&#x2F;.test(value);<br> }, “只能包括英文字母和数字”);</p><p> &#x2F;&#x2F; 邮政编码验证<br> jQuery.validator.addMethod(“zipcode”, function(value, element) {<br>  var tel &#x3D; &#x2F;^[0-9]{6}$&#x2F;;<br>  return this.optional(element) || (tel.test(value));<br> }, “请正确填写邮政编码”);</p><p> &#x2F;&#x2F; 汉字<br> jQuery.validator.addMethod(“chcharacter”, function(value, element) {<br>  var tel &#x3D; &#x2F;^[u4e00-u9fa5]+$&#x2F;;<br>  return this.optional(element) || (tel.test(value));<br> }, “请输入汉字”);</p><p> &#x2F;&#x2F; 字符最小长度验证（一个中文字符长度为2）<br> jQuery.validator.addMethod(“stringMinLength”, function(value, element, param) {<br>  var length &#x3D; value.length;<br>  for ( var i &#x3D; 0; i &lt; value.length; i++) {<br>  if (value.charCodeAt(i) &gt; 127) {<br>   length++;<br>  }<br> }<br> return this.optional(element) || (length &gt;&#x3D; param);<br> }, $.validator.format(“长度不能小于{0}!”));</p><p> &#x2F;&#x2F; 字符最大长度验证（一个中文字符长度为2）<br> jQuery.validator.addMethod(“stringMaxLength”, function(value, element, param) {<br>  var length &#x3D; value.length;<br>  for ( var i &#x3D; 0; i &lt; value.length; i++) {<br>   if (value.charCodeAt(i) &gt; 127) {<br>    length++;<br>   }<br>  }<br>  return this.optional(element) || (length &lt;&#x3D; param);<br> }, $.validator.format(“长度不能大于{0}!”));</p><p> &#x2F;&#x2F; 字符验证<br> jQuery.validator.addMethod(“string”, function(value, element) {<br>  return this.optional(element) || &#x2F;^[u0391-uFFE5w]+$&#x2F;.test(value);<br> }, “不允许包含特殊符号!”);</p><p> &#x2F;&#x2F; 手机号码验证<br> jQuery.validator.addMethod(“mobile”, function(value, element) {<br>  var length &#x3D; value.length;<br>  return this.optional(element) || (length &#x3D;&#x3D; 11 &amp;&amp; &#x2F;^(((13[0-9]{1})|(15[0-9]{1}))+d{8})$&#x2F;.test(value));<br> }, “手机号码格式错误!”);</p><p> &#x2F;&#x2F; 电话号码验证<br> jQuery.validator.addMethod(“phone”, function(value, element) {<br>  var tel &#x3D; &#x2F;^(d{3,4}-?)?d{7,9}$&#x2F;g;<br>  return this.optional(element) || (tel.test(value));<br> }, “电话号码格式错误!”);</p><p> &#x2F;&#x2F; 邮政编码验证<br> jQuery.validator.addMethod(“zipCode”, function(value, element) {<br>  var tel &#x3D; &#x2F;^[0-9]{6}$&#x2F;;<br>  return this.optional(element) || (tel.test(value));<br> }, “邮政编码格式错误!”);</p><p> &#x2F;&#x2F; 必须以特定字符串开头验证<br> jQuery.validator.addMethod(“begin”, function(value, element, param) {<br>  var begin &#x3D; new RegExp(“^” + param);<br>  return this.optional(element) || (begin.test(value));<br> }, $.validator.format(“必须以 {0} 开头!”));</p><p> &#x2F;&#x2F; 验证两次输入值是否不相同<br> jQuery.validator.addMethod(“notEqualTo”, function(value, element, param) {<br>  return value !&#x3D; $(param).val();<br> }, $.validator.format(“两次输入不能相同!”));</p><p> &#x2F;&#x2F; 验证值不允许与特定值等于<br> jQuery.validator.addMethod(“notEqual”, function(value, element, param) {<br>  return value !&#x3D; param;<br> }, $.validator.format(“输入值不允许为{0}!”));</p><p> &#x2F;&#x2F; 验证值必须大于特定值(不能等于)<br> jQuery.validator.addMethod(“gt”, function(value, element, param) {<br>  return value &gt; param;<br> }, $.validator.format(“输入值必须大于{0}!”));</p>]]></content>
    
    
    <categories>
      
      <category>Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第七章 数组的扩展</title>
    <link href="/2022/06/12/ECAMScript-seven-chart/"/>
    <url>/2022/06/12/ECAMScript-seven-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象(array-like object)和可遍历(iterable)的对象(包括ES6新增的数据结构Set和Map)。</p><p>下面是一个类似数组的对象，Array.from将它转为真正的数组</p><p> let arrayLike &#x3D; {<br>  ‘0’:’a’,<br>  ‘1’:’b’,<br>  ‘2’:’c’,<br>  length:3<br> };<br> &#x2F;&#x2F;ES5的写法<br> var arr1 &#x3D; [].slice.call(arrayLike);&#x2F;&#x2F;[‘a’,’b’,’c’]</p><p> &#x2F;&#x2F;ES6的写法<br> let arr2 &#x3D; Array.from(arrayLike); &#x2F;&#x2F;[‘a’,’b’,’c’]<br>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p><p> &#x2F;&#x2F;NodeList对象<br> let ps &#x3D; document.querySelectorAll(“p”);<br> Array.from(ps).forEach(function(p){<br>  console.log(p);<br> });</p><p> &#x2F;&#x2F;arguments对象<br> function foo(){<br>  var args &#x3D; Array.from(arguments);<br>  &#x2F;&#x2F;…<br> }<br>querySelectorAll()方法返回的是一个类数组对象，只有将这个对象转为真正的数组，才能使用forEach方法。<br>只要是部署了iterator接口的数据结构，Array.from都能将其转为数组。</p><p> Array.from(‘hello’)<br> &#x2F;&#x2F;[‘h’,’e’,’l’,’l’,’o’]<br> let namesSet &#x3D; new set([‘a’,’b’])<br> Array.from(namesSet); &#x2F;&#x2F;[‘a’,’b’]<br>字符串和Set结构都具有Iterator接口，因此，可以被Array.from转为真正的数组。</p><p>如果参数是一个真正的数组，则返回一个一模一样的数组</p><p> Array.from([1,2,3])<br> &#x2F;&#x2F;[1,2,3]<br>注意：扩展运算符(…)也可以将某些数据结构转化为数组</p><p> &#x2F;&#x2F;arguments对象<br> function foo(){<br>  var args &#x3D; […argumenta];<br> }</p><p> &#x2F;&#x2F;NodeList对象<br> [… document.querySelectorAll(‘div’)]<br>扩展运算符背后，调用的是遍历器接口(Symbol.iterator)，如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。所谓的类似数组的对象，本质特征只有一点，即必须有length属性。因为，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算就无法转换</p><p> Array.from({length:3});<br> &#x2F;&#x2F;[undefined,undefined,unddefined ]<br>对于还没有部署改方法的浏览器，可用Array.prototype.slice方法替代。</p><p> const toArray &#x3D; (()&#x3D;&gt;<br>  Array.from ?  Array.from : obj &#x3D;&gt;[].slice.call(obj)<br> )();<br>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><p> Array.from(arrayLike,x &#x3D;&gt; x<em>x);<br> &#x2F;&#x2F;等同于<br> Array.from(arrayLike).map(x &#x3D;&gt; x</em>x);</p><p> Array.from([1,2,3],(x) &#x3D;&gt; x*x);<br> &#x2F;&#x2F;[1,4,9]<br>下面是取出一组DOM节点的文本内容。</p><p> let spans &#x3D; document.querySelectorAll(‘span.name’);</p><p> &#x2F;&#x2F;map()<br> let names1 &#x3D; Array.prototype.map.call(spans, s &#x3D;&gt; s.textContent);</p><p> &#x2F;&#x2F;Array.from()<br> let name2 &#x3D; Array.from(spans,s &#x3D;&gt; s.textContent)<br>下面是将数组中布尔值为false的成员转成0</p><p> Array.from([1,,2,,3],(n) &#x3D;&gt;  n  ||0)<br> &#x2F;&#x2F;[1,0,2,0,3]</p><p>这是返回各数据的类型</p><p> function typeOf(){<br>  return Array.from(arguments,value &#x3D;&gt; typeof value)<br> }<br> typeOf(null,[],NaN)<br> &#x2F;&#x2F;[‘object’,’object’,’number’]<br>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</p><p>Array.from()可以将各种值转文真正的数组，并提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p><p> Array.from({length:2},() &#x3D;&gt; ‘jack’)<br> &#x2F;&#x2F;[‘jack’,’jack’]<br>Array.from()的另一个应用就是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理Unicode字符，可以避免JavaScript大于\uFFFF的Unicode字符，算作两个字符的bug。</p><p> function countSymbols(string){<br>  return Array.from(string).length;<br> }</p><h2 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h2><p>Array.of方法用于将一组值，转换为数组。</p><p> Array.of(3,11,8) &#x2F;&#x2F;[3,11,8]<br> Array.of(3) &#x2F;&#x2F;[3]<br> Array.of(3).length &#x2F;&#x2F;1<br>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p><p> Array() &#x2F;&#x2F;[]<br> Array(3) &#x2F;&#x2F;[,,,]<br> Array(3,11,6) &#x2F;&#x2F;[3,11,8]</p><p>Array方法没有参数，一个参数，三个参数时，返回的结果都不一样。只有当参数个数不小于2时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><p>Array.of基本上，可以用来替代Array()或new Array(),并且不存在由于参数不同而导致的重载，它的行为非常统一。</p><p> Array.of()  &#x2F;&#x2F;[]<br> Array.of(undefined) &#x2F;&#x2F;[undefined]<br> Array.of(1) &#x2F;&#x2F;[1]<br> Array.of(1,2) &#x2F;&#x2F;[1,2]<br>Array.of方法可以用下面的代码模拟实现</p><p> function Arrayof(){<br>  return [].slice.call(agruments);<br> }</p><h2 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h2><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置(会覆盖原有成员)，然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p><p> Array.prototype.copyWithin(target,start &#x3D; 0,end &#x3D; this.length)</p><p>它接受三个参数。</p><ul><li>target（必需）:  从该位置开始替换数据。</li><li>start (可选) ： 从该位置开始读取数据，默认为0，如果为负值，表示倒数。</li><li>end （可选） : 到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul><p>这三个参数都应该是数值，如果不是，会自动转为数值。</p><p> [1,2,3,4,5].copyWithin(0,3)<br> &#x2F;&#x2F;[4,5,3,4,5]<br>将从3号位直到数组结束的成员(4和5)，复制到从0号位开始的位置，结果覆盖了原来的1和2。</p><p> &#x2F;&#x2F;将3号位复制到0号位<br> [1,2,3,4,5].copyWithin(0,3,4)<br> &#x2F;&#x2F;[4,2,3,4,5]</p><p> &#x2F;&#x2F;-2相当于3号位，-1相当于4号位<br> [1,2,3,4,5]&#x2F;copyWithin(0,-2,-1)<br> &#x2F;&#x2F;[4,2,3,4,5]</p><p> &#x2F;&#x2F;将3号位复制到0号位<br> [].copyWithin.call({length:5,3:1},0,3)<br> &#x2F;&#x2F;{0:1,3:1,length:5}</p><p> &#x2F;&#x2F;将2号位到数组结束，复制到0号位<br> var i32a &#x3D; new Int32Array([1,2,3,4,5]);<br> i32a.copyWithin(0,2);<br> &#x2F;&#x2F;Int32Array[3,4,5,4,5]</p><p> &#x2F;&#x2F;对于没有部署TypedArray的copyWithin方法的平台<br> &#x2F;&#x2F;需要采用下面的写法<br> [].copyWithin.call(new Int32Array([1,2,3,4,5]),0,3,4);<br> &#x2F;&#x2F;Int32Array[4,2,3,4,5]</p><h2 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h2><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p><p> [1,4,-5,10].find((n) &#x3D;&gt;n &lt;0)<br> &#x2F;&#x2F;-5<br>找出数组中小于0的成员</p><p> [1,5,10,15].find(function(value,index,arr){<br>  return value &gt;9;</p><p> })&#x2F;&#x2F;10</p><p>find方法的回调函数可以接受三个参数，依次是当前值、当前的位置和原数组。</p><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员位置，如果所有成员都不符合，则安徽-1。</p><p> [1,5,10,15].findIndex(function(value,index,arr){<br>  return value &gt;9;<br> })&#x2F;&#x2F;2</p><p>以上两个方法都可以接受第二个参数，用来绑定回调函数this对象。<br>另外，这两个方法都可以发现NaN,弥补了数组的Indexof方法的不足。</p><p> [NaN].indexOf(NaN)<br> &#x2F;&#x2F;-1</p><p> [NaN].findIndex(y &#x3D;&gt; object.is(NaN,y))<br> &#x2F;&#x2F;0<br>总结，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Obejct.is方法做到</p><h2 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h2><p>fill方法使用给定值，填充一个数组</p><p> [‘a’,’b’,’c’].fill(7)<br> &#x2F;&#x2F;[7,7,7]</p><p> new Array(3).fill(7)<br> &#x2F;&#x2F;[7,7,7]<br>fill方法用于空数组的初始化非常方便，数组红已有的元素会全部抹去。</p><p>fill方法还可以接受第二和第三个参数，用于指定填充的起始位置和结束位置。</p><p> [‘a’,’b’,’c’].fill(7,1,2)<br> &#x2F;&#x2F;[‘a’,7,’c’]</p><h2 id="数组实例的entries-，key-和values"><a href="#数组实例的entries-，key-和values" class="headerlink" title="数组实例的entries()，key()和values()"></a>数组实例的entries()，key()和values()</h2><p>ES6提供三个新的方法——entries(),keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p><p> for (let index of [‘a’,’b’].keys()){<br>  console.log(index);<br> }<br> &#x2F;&#x2F;0<br> &#x2F;&#x2F;1</p><p> for (let elem of [‘a’,’b’].values()){<br>  console.log(elem);<br> }<br> &#x2F;&#x2F;‘a’<br> &#x2F;&#x2F;‘b’</p><p> for (let [index,elem] of [‘a’,’b’].entries()){<br>  console.log(index,elem);<br> }<br> &#x2F;&#x2F;0 “a”<br> &#x2F;&#x2F;1 “b”</p><h2 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h2><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。</p><p> [1,2,3].includes(2);  &#x2F;&#x2F;true<br> [1,2,3].includes(4); &#x2F;&#x2F;false<br> [1,2,NaN].includes(NaN); &#x2F;&#x2F;true<br>该方法的第二个参数表示搜索的起始位置，默认为0.如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度(比如第二个参数为-4，但数组长度为3)，则会重置为从0开始。</p><p> [1,2,3].includes(3,3);&#x2F;&#x2F; false<br> [1,2,3].includes(3,-1);&#x2F;&#x2F;true<br>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p><p> if (arr.indexOf(el) ! &#x3D;&#x3D; -1){<br>  &#x2F;&#x2F; …<br> }<br>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。而是，它内部使用严格相当运算符(&#x3D;&#x3D;&#x3D;)进行判断，这会导致对NaN的误判。</p><p> [NaN].indexOf(NaN)<br> &#x2F;&#x2F;-1<br>includes使用的是不一样的判断算法，就没有这个问题。<br> [NaN].includes(NaN)<br> &#x2F;&#x2F;true</p><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p><p> const contains &#x3D; (() &#x3D;&gt;<br>  Array.prototype.includes<br>  ? (arr,value) &#x3D;&gt; arr.includes(value)<br>  : (arr,value) &#x3D;&gt; arr.some(el &#x3D;&gt;el &#x3D;&#x3D;&#x3D; value)<br> )();</p><p> contains([“foo”,”bar”],”baz”);&#x2F;&#x2F;false</p><p>另外，Map和Set数据结构有一个has方法，需要注意与includes区分</p><ul><li><p>Map结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、weakMap.prototype.has(key)、Reflect.has(target,propertykey)。</p></li><li><p>Set结构的has方法，是用来查找值的，比如Set.prototype.has(value),weakMap.prototype.has(value)</p></li></ul><h2 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h2><p>数组的空位指，数组的某一位置没有任何值，比如Array构造函数返回的数组都是空位</p><p> Array(3) &#x2F;&#x2F;[,,,]<br>注意，空位不是undefined，一个空位的值等于undefined，依然是有值的，空位置是没有任何值，in运算符可以说明这一点。</p><p> 0 in [undefined,undefined,undefined] &#x2F;&#x2F;true<br> 0 in [,,,] &#x2F;&#x2F;false</p><p>上面代码说明，第一个数组的0号位是有值的，第二个数组的0号位是没有值的</p><p>ES5对空位的处理，已经很不一致了，大多数情况会忽略空位。</p><ul><li><p>forEach方法,filter()，every()和some()都会跳过空位。</p></li><li><p>map()会跳过空位，但会保留这个值</p></li><li><p>join()和toString()会将空位视为undefined而undefined和null会被处理成空字符串</p><p>&#x2F;&#x2F;forEach方法<br>[,’a’].forEach((x,i) &#x3D;&gt; console.log(i));&#x2F;&#x2F;1</p><p>&#x2F;&#x2F;filter方法<br>[‘a’,,’b’].filter(x &#x3D;&gt; true) &#x2F;&#x2F;[‘a’,’b’]</p><p>&#x2F;&#x2F;every方法<br>[,’a’].every(x &#x3D;&gt; x &#x3D;&#x3D;&#x3D; ‘a’) &#x2F;&#x2F;true</p><p>&#x2F;&#x2F;some方法<br>[,’a’].some(x &#x3D;&gt; x !&#x3D;&#x3D; ‘a’) &#x2F;&#x2F;false</p><p>&#x2F;&#x2F;map方法<br>[,’a’,undefined,null].join(‘#’) &#x2F;&#x2F;“#a##”</p><p>&#x2F;&#x2F;toString 方法<br>[,’a’,undefined,null].toString() &#x2F;&#x2F;“,a,,”</p></li></ul><p>ES6则是明确将空位转为undefined</p><p>Array.from方法会将数组的空位转为undefined，也即是说，这个方法不会忽略空位。</p><p> Array.from([‘a’,,’b’])<br> &#x2F;&#x2F;[“a”,undefined,”b”]</p><p>扩展运算[…]也会将空位转为undefined</p><p> […[‘a’,,’b’]]<br> &#x2F;&#x2F;[“a”,undefined,”b”]</p><p>copyWithin()会连空位一起拷贝</p><p> [,’a’,’b’,,].copyWithin(2,0) &#x2F;&#x2F;[,”a”,,”a”]</p><p>fill()会将空位视为正常数组位置。</p><p> new Array(3).fill(‘a’) &#x2F;&#x2F;[“a”,”a”,”a”]<br>for … of 循环也会遍历空位。</p><p> let arr &#x3D; [,,]<br> for (let i of  arr){<br>  console.log(1)<br> }<br> &#x2F;&#x2F;1<br> &#x2F;&#x2F;1</p><p>entries()、key()、values()、find()和findIndex()也会将空位处理成undefined</p><p> &#x2F;&#x2F;entries()<br> […[,’a’].entries()]  &#x2F;&#x2F;[[0,undefined],[1,’a’]]</p><p> &#x2F;&#x2F;keys()<br> […[,’a’].keys()]  &#x2F;&#x2F;[0,1]</p><p> &#x2F;&#x2F;values()<br> […[,’a’].values()] &#x2F;&#x2F;[undefined,”a”]</p><p> &#x2F;&#x2F;find()<br> [,’a’].find(x &#x3D;&gt; true)  &#x2F;&#x2F;undefined</p><p> &#x2F;&#x2F;findIndex()<br> [,’a’].findIndex(x &#x3D;&gt; true) &#x2F;&#x2F;0<br>由于空位的处理规则非常不统一，所以建议尽量避免出现空位</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第六章 数值的扩展</title>
    <link href="/2022/06/11/ECMAScript-six-chart/"/>
    <url>/2022/06/11/ECMAScript-six-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h3 id="二进制和八进制标示符"><a href="#二进制和八进制标示符" class="headerlink" title="二进制和八进制标示符"></a>二进制和八进制标示符</h3><p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示</p><p> 0b111110111 &#x3D;&#x3D;&#x3D; 503 &#x2F;&#x2F;true<br> &#x2F;&#x2F;二进制计算规则<br> 1<em>2^0+1</em>2^1+1<em>2^2+0</em>2^3 + 1<em>2^4 +1</em>2^5+ 1<em>2^6 +1</em>2^7 +1*2^8<br> &#x3D;1+2+4+0+16+32+64+128+256<br> &#x3D;503</p><p> 0o767 &#x3D;&#x3D;&#x3D; 503 &#x2F;&#x2F;true<br> &#x2F;&#x2F;八进制的计算规则<br> 7+8^0 +6<em>8^1 +7</em>8^2<br> &#x3D;7+48+228<br> &#x3D;503</p><p>从ES5开始，在严格模式中，八进制就不再允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示。</p><p> &#x2F;&#x2F;非严格模式<br> (function(){<br>  console.log(0o11 &#x3D;&#x3D;&#x3D; o11);<br> })()&#x2F;&#x2F;true</p><p> &#x2F;&#x2F;严格模式<br> (function(){<br>  ‘use strict’;<br>  console.log(0o11 &#x3D;&#x3D;&#x3D; o11);<br> })()&#x2F;&#x2F;Uncaught SyntaxError :Octal literals are not allowed in strict mode.</p><p>将0b和0o前缀的字符串数值转换为十进制，要使用Number方法</p><p> Number(‘0b111’) &#x2F;&#x2F;7<br> Number(‘0o10’) &#x2F;&#x2F;8</p><h2 id="Number-isFinite-Number-isNaN"><a href="#Number-isFinite-Number-isNaN" class="headerlink" title="Number.isFinite(),Number.isNaN()"></a>Number.isFinite(),Number.isNaN()</h2><p>ES6在Number对象上，提供了Number.isFinite()和Number.isNaN()两个方法</p><h3 id="Number-isFinite-用来检查数值是否是有限的-finite"><a href="#Number-isFinite-用来检查数值是否是有限的-finite" class="headerlink" title="Number.isFinite()用来检查数值是否是有限的(finite)"></a>Number.isFinite()用来检查数值是否是有限的(finite)</h3><p> Number.isFinite(15); &#x2F;&#x2F;true<br> Number.isFinite(0.8); &#x2F;&#x2F;true<br> Number.isFinite(NaN); &#x2F;&#x2F;false<br> Number.isFinite(Infinity); &#x2F;&#x2F;false<br> Number.isFinite(-Infinity); &#x2F;&#x2F;false<br> Number.isFinite(‘foo’); &#x2F;&#x2F;false<br> Number.isFinite(‘15’); &#x2F;&#x2F;false<br> Number.isFinite(true);&#x2F;&#x2F;false<br>ES5可以通过以下方法来部署<strong>Number.isFinite</strong>方法</p><p> (function(globa){<br>  var global_isFinite &#x3D; global.isFinite;</p><p>  Object.defineProperty(Number,’isFinite’,{<br>   value:function isFinite(value){<br>    return typeof value &#x3D;&#x3D;&#x3D; ‘number’ &amp;&amp; global_isFinite(value);<br>   },<br>   configurable:true,<br>   enumerable:false,<br>   writable:true<br>  });<br> })(this)</p><h3 id="Number-isNaN-用来检查一个值是否为NaN"><a href="#Number-isNaN-用来检查一个值是否为NaN" class="headerlink" title="Number.isNaN()用来检查一个值是否为NaN"></a>Number.isNaN()用来检查一个值是否为NaN</h3><p> Number.isNaN(NaN);&#x2F;&#x2F;true<br> Number.isNaN(15); &#x2F;&#x2F;false<br> Number.isNaN(‘15’); &#x2F;&#x2F;false<br> Number.isNaN(true); &#x2F;&#x2F;true<br> Number.isNaN(9&#x2F;NaN); &#x2F;&#x2F;true<br> Number.isNaN(‘true’&#x2F;0);&#x2F;&#x2F;true<br> Number.isNaN(“true”&#x2F;“true”);&#x2F;&#x2F;true</p><p>ES5通过下面的代码可以部署Number.isNaN()方法</p><p> (function (global){<br>  bar global_isNaN &#x3D; global.isNaN;</p><p>  Object.defineProperty(Number,’isNaN’,{<br>   value : function isNaN(value){<br>    return type value &#x3D;&#x3D;&#x3D; ‘number’ &amp;&amp; global_isNaN(value);<br>   },<br>   configurable:true,<br>   enumerable:false,<br>   writable:true<br>  });<br> })(this)</p><p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</p><p> isFinite(25) &#x2F;&#x2F;true<br> isFinite(“25”) &#x2F;true<br> Number.isFinite(25) &#x2F;&#x2F;true<br> Number.isFinite(“25”) &#x2F;&#x2F;false</p><p> isNaN(NaN) &#x2F;&#x2F;true<br> isNaN(“NaN”) &#x2F;&#x2F;true<br> Number.isNaN(NaN) &#x2F;&#x2F;true<br> Number.isNaN(“NaN”) &#x2F;&#x2F;false</p><h2 id="Number-parseInt-Number-parseFloat"><a href="#Number-parseInt-Number-parseFloat" class="headerlink" title="Number.parseInt(),Number.parseFloat()"></a>Number.parseInt(),Number.parseFloat()</h2><p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上，行为完全保持不变。</p><p> &#x2F;&#x2F;ES5写法<br> parseInt(“12.34”); &#x2F;&#x2F;12<br> parseFloat(‘123.45’) &#x2F;&#x2F;123.45</p><p> &#x2F;&#x2F;ES6写法<br> Number.parseInt(“12.34”); &#x2F;&#x2F;12<br> Number.parseFloat(‘123.45’) &#x2F;&#x2F;123.45</p><p>这样做的目的是逐步减少全局性方法，使得语言逐步模块化。</p><p> Number.parseInt &#x3D;&#x3D;&#x3D; parseInt &#x2F;&#x2F;true<br> Number.parseFloat &#x3D;&#x3D;&#x3D; parseFloat &#x2F;&#x2F;true</p><h2 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h2><p>Number.isInteger()用来判断一个值是否是整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p><p> Number.isInteger(25)  &#x2F;&#x2F;true<br> Number.isInteger(25.0) &#x2F;&#x2F;true<br> Number.isInteger(25.1) &#x2F;&#x2F;false<br> Number.isInteger(“15”) &#x2F;&#x2F;false<br> Number.isInteger(true) &#x2F;&#x2F;false<br>ES5可以通过下面的代码，部署Number.isInteger()。</p><p> (function(){<br>  var floor &#x3D; Math.floor,<br>   isFinite &#x3D; global.isFinite;</p><p>  Object.defineProperty(Number,’isInteger’,{<br>   value: function isInteger(value){<br>    return typeof value &#x3D;&#x3D;&#x3D; ‘number’ &amp;&amp; isFinite(value) &amp;&amp;<br>      value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp;<br>      floor(value) &#x3D;&#x3D;&#x3D; value;<br>   },<br>   confogurable:true,<br>   enumerable:false,<br>   writable:true</p><p>  });<br> })(this)</p><h2 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h2><p>ES6在Number对象上面，新增了一个极小的常量<strong>Number.EPSILON</strong>。</p><p> Number.EPSILON<br> &#x2F;&#x2F;2.220446049250313e-16<br> Number.EPSILON.toFixed(20);<br> &#x2F;&#x2F;‘0.00000000000000022204’</p><p>引入一个这么小量的目的，在于为浮点数计算，设置一个误差范围。因为浮点数不是精确的</p><p> 0.1 + 0.2<br> &#x2F;&#x2F;0.3000000000004</p><p> 0.1 + 0.2 - 0.3<br> &#x2F;&#x2F;5.551115124125783e-17</p><p>但是如果误差能够小于Number.EPSILON,我们就可以认为得到了正确结果。</p><p>因此，Number.EPSILON的实质是一个可以接受的误差范围。</p><h2 id="安全整数和Number-isSafeInteger"><a href="#安全整数和Number-isSafeInteger" class="headerlink" title="安全整数和Number.isSafeInteger()"></a>安全整数和Number.isSafeInteger()</h2><p>JavaScript能够准确表示的整数范围是 -2^53和2^53（不含两个端点），超过这个范围，无法精确表示这个值<br> Math.pow(2,53)  &#x2F;&#x2F;9007199254740992</p><p> 9007199254740992  &#x2F;&#x2F;9007199254740992<br> 9007199254740993  &#x2F;&#x2F;9007199254740992</p><p> Math.pow(2,53) &#x3D;&#x3D;&#x3D; Math.pow(2,53) +1 &#x2F;&#x2F;true<br>如代码所示，超过2的53次方之后，一个数就不精确了</p><p>ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限</p><p> Number.MAX_SAFE_INTEGER &#x3D;&#x3D;&#x3D; Math.pow(2,53) -1 &#x2F;&#x2F; true<br> Number.MAX_SAFE_INTEGER &#x3D;&#x3D;&#x3D; 9007199254740991 &#x2F;&#x2F; true<br> Number.MAX_SAFE_INTEGER &#x3D;&#x3D;&#x3D; -Number.MAX_SAFE_INTEGER &#x2F;&#x2F; true<br> .MAX_SAFE_INTEGER &#x3D;&#x3D;&#x3D; -9007199254740991 &#x2F;&#x2F; true<br>由此，可以看出JavaScript能够精确表示的极限。<br>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p><p>这个函数的实现很简单，就跟安全整数两个边界值比较一下</p><p> Number.isSafeInteger &#x3D; function (n) {<br>  return (typeof n &#x3D;&#x3D;&#x3D; ‘number’ &amp;&amp;<br>    Math.round(n) &#x3D;&#x3D;&#x3D; n &amp;&amp;<br>    Number.Min_SAFE_INTEGER &lt;&#x3D; n &amp;&amp;<br>    n &lt;&#x3D; Number.MAX_SAFE_INTEGER);<br> }<br>实际使用者函数时，需要注意，验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而是同时验证参与运算的没有一个值。</p><p> Number.isSafeInteger(9007199254740993 - 990)&#x2F;&#x2F;true<br> 返回结果9007199254740992<br> &#x2F;&#x2F;正确答案应该是9007199254740003</p><h2 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h2><p>ES6在Math对象上新增了17个与数学相关的方法，这些方法都是静态的，只能在Math对象上调用。</p><h3 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h3><p>Math.trunc方法用于出去一个数的小数部分，返回整数部分</p><p> Math.trunc(4.2) &#x2F;&#x2F;4<br> Math.trunc(-4.2) &#x2F;&#x2F;-4<br> Math.trunc(-0.1234) &#x2F;&#x2F;-0<br>对于非数字，Math.trunc内部使用Number方法将其先转为数值</p><p> Math.trunc(‘123.456’);&#x2F;&#x2F;123<br>对于空值和无法截取整数的值，返回NaN</p><p> Math.trunc(NaN);  &#x2F;&#x2F;NaN<br> Math.trunc(‘foo’); &#x2F;&#x2F;NaN<br> Math.trunc();   &#x2F;&#x2F;NaN</p><p>对于这个没有部署这个方法的环境，可以用下面的代码模拟</p><p> Math.trunc &#x3D; Math.trunc || function(x){<br>  return x &lt;0 ? Math.ceil(x) : Math.floor(x);<br> };</p><h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h3><p>Math.sign方法用来判断一个数到底是整数、负数、还是零。</p><p>它会返回五种值</p><ul><li>参数为正数，返回+1</li><li>参数为负数，返回-1</li><li>参数为0，返回0</li><li>参数为-0，返回-0</li><li>其他值，返回NaN</li></ul><h3 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h3><p>Math.cbrt()方法用于计算一个数的立方根</p><p> Math.cbrt(-1) &#x2F;&#x2F;-1<br> Math.cbrt(0)  &#x2F;&#x2F;0<br> Math.cbrt(1)  &#x2F;&#x2F;1<br> Math.cbrt(2)  &#x2F;&#x2F;1.2599210498948734</p><h3 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h3><p>JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0</p><p> Math.clz32(0) &#x2F;&#x2F;32<br> Math.clz32(1) &#x2F;&#x2F;31<br> Math.clz32(1000) &#x2F;&#x2F;22<br>0的二进制形式全是0，所以有32个前导0，1的二进制形式是0b1,只占1位，所以32位之中有31个前导0；1000的二进制形式是0b1111101000,一共10位，故有22个前导0。</p><h3 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h3><p>Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。</p><p> Math.imul(2,4) &#x2F;&#x2F;8<br> Math.imul(-1,8) &#x2F;&#x2F;-8<br> Math.imul(-2,-2) &#x2F;&#x2F;4<br>如果只考虑最后32位，多数情况下，Math.imul(a,b)与a<em>b的结果是相同的，即该方法等同于(a</em>b)|0的效果（超出32位的部分溢出）。之所以需要部署这个方法，是因为JavaScript有精度显示，超过2^53次方的值无法精确表示。对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</p><h3 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h3><p>Math.fround方法返回一个数的单精度浮点数形式。</p><p> Math.fround(0)  &#x2F;&#x2F;0<br> Math.fround(1)  &#x2F;&#x2F;1<br> Math.fround(1.337) &#x2F;&#x2F;1.3370000123977661<br> Math.fround(1.5)  &#x2F;&#x2F;1.5<br> Math.fround(NaN)  &#x2F;&#x2F;NaN<br>对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</p><h3 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h3><p>Math.hypot方法返回所有参数的平方和的平方根</p><p> Math.hypot(3,4);&#x2F;&#x2F;5<br> Math.hypot(3,4,5); &#x2F;&#x2F;7.0710678118654755<br> Math.hypot();  &#x2F;&#x2F;0<br> Math.hypot(NaN); &#x2F;&#x2F;NaN<br> Math.hypot(3,4,’foo’); &#x2F;&#x2F;NaN<br> Math.hypot(3,4,’5’) &#x2F;&#x2F;7.0710678118654755<br> Math.hypot(-3)  &#x2F;&#x2F;3</p><h3 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h3><p>ES6 新增了4个对数方法</p><ol><li>Math.expm1()</li></ol><p> Math.expm1(x)返回e^x -1 即Math.exp(x)-1。</p><p>  Math.expm1(-1)  &#x2F;&#x2F;-0.632120558828577<br>  Math.expm1(0)  &#x2F;&#x2F;0<br>  Math.expm1(1) &#x2F;&#x2F;1.718281828459045<br> 对于没有部署这个方法的环境，可以用下面的代码模拟。</p><p>  Math.expm1 &#x3D; Math&#x2F;expm1 || function(){<br>   return Math.exp(x)-1;<br>  }</p><ol start="2"><li>Math.log1p()</li></ol><p> Math.log1p(x)方法返回1+x的自然对数，即Math.log(1+x),如果x小于-1，返回NaN.</p><p>  Math.log1p(1)  &#x2F;&#x2F;0.6931471805599453<br>  Math.log1p(0)   &#x2F;&#x2F;0<br>  Math.log1p(-1) &#x2F;&#x2F;-Infinity<br>  Math.log1p(-2)  &#x2F;&#x2F;NaN<br> 对于没有部署这个方法的环境们可以用下面代码模拟</p><p>  Math.log1p &#x3D; Math&#x2F;log1p || function(){<br>   return Math.log(1+x);<br>  }<br>3. Math.log10()</p><p> Math.log10(x)返回以10为底的对数，如果x小于0，则返回NaN</p><p>  Math.log10(2) &#x2F;&#x2F;0.3010299956639812<br>  Math.log10(1) &#x2F;&#x2F;0<br>  Math.log10(0) &#x2F;&#x2F; -Infinity<br>  Math.log10(-2) &#x2F;&#x2F;NaN<br>  Math.log10(100000) &#x2F;&#x2F;5<br> 对于没有部署这个方法的环境，可以用下面的代码模拟<br>  Math.log10 &#x3D; Math.log10 || function(x){<br>   return Math.log(x) &#x2F;Math.LN10;<br>  };</p><ol start="4"><li>Math.log3()</li></ol><p> Math.log2(x)返回以2为底的x的对数，如果小于0，则返回NaN</p><p>  Math.log2(3)  &#x2F;&#x2F;1.584962500721156<br>  Math.log2(2)  &#x2F;&#x2F;1<br>  Math.log2(1)  &#x2F;&#x2F;0<br>  Math.log2(0)  &#x2F;&#x2F;-Infinity<br>  Math.log2(-2) &#x2F;&#x2F;NaN<br>  Math.log2(1024) &#x2F;&#x2F;10<br>  Math.log2(1 &lt;&lt; 29) &#x2F;&#x2F;29<br> 对于没有部署这个方法的环境，可以用下面的代码模拟</p><p> Math.log2 &#x3D; Math.log2 || function(x){<br>  return Math.log(x)&#x2F;Math.LN2;<br> }</p><h3 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h3><p>ES6新增了6个三角函数的方法。</p><ul><li>Math.sinh(x) 返回x的双曲正弦(hyperbolic sine)</li><li>Math.cosh(x) 返回x的双曲余弦(hyperbolic cosine)</li><li>Math.tanh(x) 返回x的双曲正切(hyperbolic tangent)</li><li>Math.asinh(x) 返回x的反双曲正弦(inverse hyperbolic sine)</li><li>Math.acosh(x) 返回x的反双曲余弦(inverse hyperbolic cosine)</li><li>Math.atanh(x) 返回x的反双曲正切(inverse hyperbolic tangent)</li></ul><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>ES7新增了一个指数运算符(**),目前Babel转码器已经支持</p><p> 2 <strong>2 &#x2F;&#x2F;4<br>2</strong> 3 &#x2F;&#x2F;8<br>指数运算符可以与等号结合，形成一个新的赋值运算符(**&#x3D;)</p><p> let a &#x3D;2;<br> a **&#x3D; 2;<br> &#x2F;&#x2F;等同于 a&#x3D; a*a;</p><p> let b &#x3D;3;<br> b **&#x3D;3;<br> &#x2F;&#x2F;等同于b &#x3D; b<em>b</em>b*b;</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第五章 正则的扩展</title>
    <link href="/2022/06/10/ECMAScript6-five-chart/"/>
    <url>/2022/06/10/ECMAScript6-five-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h2 id="RegExp构造函数"><a href="#RegExp构造函数" class="headerlink" title="RegExp构造函数"></a>RegExp构造函数</h2><p>在ES5中，RegExp构造函数的参数有两种情况。</p><p>第一种情况，参数是字符串，第二个参数表示正则表达式的修饰符(flag)。</p><p> var regex &#x3D; new RegExp(‘xyz’,’i’);<br> &#x2F;&#x2F;等价于<br> var regex &#x3D; &#x2F;xyz&#x2F;i;<br>第二种情况，参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。</p><p> var regex &#x3D; new RegExp(&#x2F;xyz&#x2F;i);<br> &#x2F;&#x2F;等价于<br> var regex &#x3D; &#x2F;xyz&#x2F;i;<br>但是ES5中，不允许此时使用第二个参数来添加修饰，会报错</p><p> var regex &#x3D; new RegExp(&#x2F;xyz&#x2F;,’i’);<br> &#x2F;&#x2F;Uncaught TypeError<br>ES6允许了这种行为，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且返回的正则表达式还会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><p> new RegExp(&#x2F;abc&#x2F;ig,’i’).flage<br> &#x2F;&#x2F;  ‘i’</p><h2 id="字符串的正则方法"><a href="#字符串的正则方法" class="headerlink" title="字符串的正则方法"></a>字符串的正则方法</h2><p>字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。</p><p>String.prototype.match调用RegExp.prototype[Symbol.match]<br>String.prototype.replace调用RegExp.prototype[Symbol.replace]<br>String.prototype.search调用RegExp.prototype[Symbol.search]<br>String.prototype.split调用RegExp.prototype[Symbol.split]</p><h2 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h2><p>ES6对正则表达式添加了u修饰符，含义为”Unicode”模式，用来正确处理大于\uffff的Unicode字符。</p><p>一旦加上u修饰符号，就会修改一些正则表达式的行为。</p><h2 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h2><p>除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”修饰符<br>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余第一位置开始，这也就是”粘连”。</p><p> var s &#x3D; ‘aaa_aa_a’;<br> var r1 &#x3D; &#x2F;a+&#x2F;g;<br> var r2 &#x3D; &#x2F;a+&#x2F;y;</p><p> r1.exec(s)&#x2F;&#x2F;[“aaa”]<br> r2.exec(s)&#x2F;&#x2F;[“aaa”]</p><p> r1.exec(s)&#x2F;&#x2F;[“aa”]<br> r2.exec(s)&#x2F;&#x2F;null<br>一个是g修饰符，一个是y修饰符，这两个正则表达式个执行了一次，第一次执行两者行为相同，得到的字符串相同都是[“aaa”],剩余字符串都是_aa_a,当第二次执行的时候，<strong>y</strong> 修饰符必须从头开始匹配，所以得不出与a+的匹配模式相符合的字符串，所以返回null，而 <strong>g</strong> 修饰符匹配是不要求从第一个位置开始的。所以返回[“aa”]</p><p>使用lastIndex属性，可以更好地诠释y修饰符</p><p> const REGEX &#x3D; &#x2F;a&#x2F;g;</p><p> &#x2F;&#x2F;指定从2号位置(y)开始匹配<br> REGEX.lastIndex &#x3D; 2;</p><p> &#x2F;&#x2F;匹配成功<br> const match &#x3D; REGEX.exec(‘xaya’);<br> match.index &#x2F;&#x2F;3</p><p> &#x2F;&#x2F;下一次匹配从4号位开始<br> REGEX.lastIndex &#x3D; 4;<br> REGEX.exec(‘xaxa’);&#x2F;&#x2F;null</p><p>g修饰符从lastIndex指定你每次搜索的开始位置向后搜索，直到发现匹配为止</p><p>y修饰符同样遵守lastIndex属性，但必须要求在lastIndex指定位置发现匹配</p><p> const REGEX &#x3D; &#x2F;a&#x2F;y;</p><p> &#x2F;&#x2F;指定从2号位置(y)开始匹配<br> REGEX.lastIndex &#x3D; 2;</p><p> &#x2F;&#x2F;匹配失败<br> const match &#x3D; REGEX.exec(‘xaxa’);&#x2F;&#x2F;null</p><p> 指定从3号位置开始匹配<br> REGEX,&#x3D;.lastIndex &#x3D; 3;</p><p> &#x2F;&#x2F;3号位置是粘连，匹配成功<br> const match &#x3D; REGEX.exec(‘xaxa’);<br> REGEX.lastIndex&#x2F;&#x2F;3;<br> REGEX.lastIndex;&#x2F;&#x2F;4<br>进一步说，y修饰符号隐含了头部匹配的标志<strong>^</strong></p><p> &#x2F;b&#x2F;y.exec(‘aba’);<br> &#x2F;&#x2F;null<br>y修饰符设计的本意，就是让头部匹配的表示^在全局匹配中都有效。</p><p>在split方法中使用y修饰符，原字符串必须以分隔号开头，这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。</p><p> &#x2F;&#x2F;没有找到匹配<br> ‘x##’.split(&#x2F;#&#x2F;y)<br> &#x2F;&#x2F;[‘x##’]</p><p> &#x2F;&#x2F;找到两个匹配<br> ‘##x’.split(&#x2F;#&#x2F;y)<br> &#x2F;&#x2F;[‘’,’’,’x’]<br>后续的分隔符只有紧跟前面的分隔符，才会被识别</p><p> ‘#x#’.split(&#x2F;#&#x2F;y)<br> &#x2F;&#x2F;[‘’,’x#’]<br> ‘##’.split(&#x2F;#&#x2F;y)<br> &#x2F;&#x2F;[‘’,’’,’’]</p><h2 id="sticky属性"><a href="#sticky属性" class="headerlink" title="sticky属性"></a>sticky属性</h2><p>与 <strong>y</strong> 修饰符相匹配，ES6的正则对象多了 <strong>sticky</strong> 属性,表示是否这只y修饰符</p><p> var r &#x3D; &#x2F;hello\d&#x2F;y;<br> r.sticky &#x2F;&#x2F;true</p><h2 id="flags属性"><a href="#flags属性" class="headerlink" title="flags属性"></a>flags属性</h2><p>ES6为正则表达式新增了<strong>flags</strong>属性</p><p> ES5的source属性<br> &#x2F;&#x2F;返回正则表达式的正文<br> &#x2F;abc&#x2F;ig.source<br> &#x2F;&#x2F;“abc”</p><p> &#x2F;&#x2F;ES6的flags属性<br> &#x2F;&#x2F;返回正则表达式的修饰符<br> &#x2F;abc&#x2F;ig.flags<br> &#x2F;&#x2F;‘gi’</p><h2 id="RegExp-escape"><a href="#RegExp-escape" class="headerlink" title="RegExp.escape()"></a>RegExp.escape()</h2><p>字符串必须转义，才能作为正则模式<br>已经有提议将这个需求标准化，作为RegExp对象的静态方法RegExp.escape(),放入ES7。但TC39认为，这个方法有安全风险，又不想这个方法变得过于复杂，没有列入ES7。</p><p> RegExp.escape(‘The  Quick Brown Fox’);<br> &#x2F;&#x2F;“The  Quick Brown Fox”</p><p> RegExp.escape(‘Buy it. use it. break it. fix it.’);<br> &#x2F;&#x2F;‘Buy it\ use it. break it. fix it.‘</p><p> RegExp.escape(‘(<em>.</em>)’);<br> &#x2F;&#x2F;“(*.*)“<br>字符串转义以后，可以使用RegExp构造函数生成正则模式</p><p> var str &#x3D; “hello world”;<br> var regex &#x3D; new RegExp(RegExp.escape(str),’g’);</p><h2 id="后行断言"><a href="#后行断言" class="headerlink" title="后行断言"></a>后行断言</h2><p>JavaScript语言的正则表达式，只支持先行断言(lookahead)和线性否定断言(nagative lookkahead)，不支持后行断言(lookbehind)和后行否定断言(negative lookbehind)</p><p>先行断言：指的是x只有在y前面才匹配，必须写成 <strong>&#x2F;x(?&#x3D;y)&#x2F;</strong>,比如，只匹配百分号之前的数字，要写成**&#x2F;\d+(?&#x3D;%)&#x2F;**。</p><p>先行否定断言：指的是，x只有不在y前面才匹配，必须携程 <strong>&#x2F;x(?!y)&#x2F;</strong> ,比如，只匹配不在百分号之前的数字，要写成 **&#x2F;\d+(?!%)&#x2F;**。</p><p> &#x2F;\d+(?&#x3D;%)&#x2F;.exec(‘100% of US presidents have been male’); &#x2F;&#x2F;[“100”]<br> &#x2F;\d+(?!%)&#x2F;.exec(‘that’s all 44 of them’)   &#x2F;&#x2F;[“44”]</p><p>后行断言正好与先行断言相反，只有x在y后面才匹配，必须写成 <strong>&#x2F;(?&lt;&#x3D;y)x&#x2F;</strong>,问号后面多了个 <strong>&lt;</strong> 小于号。</p><p>后行否定断言和先行否定断言相反，**&#x2F;(?&lt;!y)x&#x2F;**,等号改成 <strong>！</strong> 非符号</p><p> &#x2F;(?&lt;&#x3D;$)\d+&#x2F;.exec(‘Benjamin Franklin is on the $100 bill’) &#x2F;&#x2F;[“100”]<br> &#x2F;(?&lt;!$)\d+&#x2F;.exec(‘it’s worth about &amp;90’)  &#x2F;&#x2F;[‘90’]</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第四章 字符串的扩展</title>
    <link href="/2022/06/09/ECMAScript6-fourth-chart/"/>
    <url>/2022/06/09/ECMAScript6-fourth-chart/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-字符串的扩展"><a href="#第四章-字符串的扩展" class="headerlink" title="第四章 字符串的扩展"></a>第四章 字符串的扩展</h1><p>ES6加强了对Unicode的支持，并且扩展了字符串对象。</p><h3 id="字符的Unicode表示法"><a href="#字符的Unicode表示法" class="headerlink" title="字符的Unicode表示法"></a>字符的Unicode表示法</h3><p>JavaScript允许采用\uxxxx形式表示一个字符串，其中“xxxx”表示字符的码点</p><p> “\u0062”<br> &#x2F;&#x2F;“a”<br>但是，这种表示法只限于\u0000——\uFFFF之间的字符，超出这个范围必须用两个双字节的形式表达。</p><p> “\uD842\uDFB7”<br> &#x2F;&#x2F;“吉”</p><p>ES6对这点进行了改进，只要将码点放入大括号，就能正确解读该字符。</p><p> “\u{20BB7}”<br> &#x2F;&#x2F;“吉”</p><p> “\u{41}\u{42}\u{43}”<br> &#x2F;&#x2F;“ABC”</p><p> let hello &#x3D; 123;<br> hell\u{6F} &#x2F;&#x2F;123</p><p> ‘\u{1F680}’  &#x3D;&#x3D;&#x3D; ‘\uD830\uDE80’<br> &#x2F;&#x2F;true<br>综上所述：JavaScript共有6中方法可以表示一个字符。</p><p> ‘\z’ &#x3D;&#x3D;&#x3D; ‘z’  &#x2F;&#x2F;true<br> ‘\172’ &#x3D;&#x3D;&#x3D; ‘z’ &#x2F;&#x2F;true<br> ‘\x7A’ &#x3D;&#x3D;&#x3D; ‘z’ &#x2F;&#x2F;true<br> ‘\uoo7A’ &#x3D;&#x3D;&#x3D; ‘z’ &#x2F;&#x2F;true<br> ‘\u{7A}’ &#x3D;&#x3D;&#x3D; ‘z’ &#x2F;&#x2F;true</p><h2 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt()方法"></a>codePointAt()方法</h2><p>JavaScript内部，字符一UTF-16的格式存储，每个字节固定为2个字节。对于那些需要4个字节存储的字符(Unicode码点大于0xFFFF的字符)，JavaScript会认为它们是两个字符。</p><p> var s&#x3D;”吉”;</p><p> s.length &#x2F;&#x2F;2<br> s.charAt(0) &#x2F;&#x2F;‘’<br> s.charAt(1) &#x2F;&#x2F;‘’<br> s.charCodeAt(0) &#x2F;&#x2F;55362<br> s.charCodeAt(1) &#x2F;&#x2F;57271<br>汉字“吉”的码点是0x20BB7 ,utf-16编码为0xD842 0xDFB7(十进制是55362 57271),需要四个字节存储，对于这种四个字节的字符，JavaScript不能正确处理，字符长度会误判为2，且charAt方法无法读取整个字符，charCodeAt方法只能返回前两个字节和后两个字节的值</p><p>ES6提供了codePointAt方法，能够正确处理4个字节的字符，返回一个字符的码点。</p><p> var s &#x3D; “吉a”;</p><p> s.codePointAt(0); &#x2F;&#x2F;134071<br> s.codePointAt(1); &#x2F;&#x2F;57271</p><p> s.chartCodeAt(2)&#x2F;&#x2F;97<br>codePointAt方法的参数，是字符在字符串的位置(从0开始)。上面代码中，JavaScript将”吉a”视为三个字符。codePointAt方法在第一个字符上，正确的识别了”吉”，返回了它的十进制码点134071(即16进制的20BB7)。在第一个字符(即吉的后面两个字节)和第三个字符”a”上，codePointAt方法的结构与charCodeAt方法。总之codePointAt方法会争取返回32位的UTF-16字符码点。对于那些两个字节存储的常规字符，它的返回结果和charCodeAt方法相同。codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，需要使用toString方法转换一下。</p><p> var s &#x3D; “吉a”;</p><p> s.codePointAt(0).toString(16)  &#x2F;&#x2F;“20bb7”<br> s.charCodeAt(2).toString(16)  &#x2F;&#x2F;“61”</p><p> 等价于<br> var s &#x3D; “吉a”;<br> for(let ch of s){<br>  console.log(ch.codePointAt(0).toString(16));<br> }<br> &#x2F;&#x2F;20bb7<br> &#x2F;&#x2F;61</p><p>codePointAt方法最常见的用法就是用来判断一个字符是两个字节还是三个字节组成。</p><p> function is32Bit(c){<br>  ruturn c.codePoint(0) &gt; 0xFFFF;<br> }<br> is32Bit(“吉”); &#x2F;&#x2F;true<br> is32Bit(“a”); &#x2F;&#x2F;false</p><h2 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h2><p>ES5提供 String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。</p><p> String.fromCharCode(0x20BB7);<br> &#x2F;&#x2F;乱码<br>String.fromCharCode不能识别大于0xFFFF的码点，所有0x20BB7发生了溢出，最高位2被舍弃了，最后返回码点u+0BB7对应的字符，而不是码点u+20BB7对应的字符。</p><p>ES6提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode的方法的不足，作用上与codePointAt方法相反。</p><p> String.fromCodePoint(0x20BB7);<br> &#x2F;&#x2F;“吉”<br> String.fromCode.Point(0x78,ox1f680,0x79) &#x3D;&#x3D;&#x3D; ‘x\uD830\uDE89y’;<br> &#x2F;&#x2F;true</p><p><strong>注意：fromCodePoint方法定义在String对象上，codePointAt()方法定义在字符串实例对象上。</strong></p><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历</p><p> for(let codePoint of ‘foo’){<br>  console.log(codePoint);<br> }<br> &#x2F;&#x2F;“f”<br> &#x2F;&#x2F;“o”<br> &#x2F;&#x2F;“o”<br>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p><p> var text &#x3D; String.fromCodePoint(0x20BB7);</p><p> for(let i &#x3D; 0; i &lt; text.length;i++){<br>  consol.log(text[i]);<br> }<br> &#x2F;&#x2F;“”<br> &#x2F;&#x2F;“”</p><p> for(let i of text){<br>  console.log(i);<br> }<br> &#x2F;&#x2F;“吉”<br>for循环会为人text包含两个字符，而for…of循环会正确识别成一个字符</p><h2 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h2><p>ES5对字符串对象提供chartAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</p><p> ‘abc’.charAt(0) &#x2F;&#x2F;“a”<br> ‘吉’.charAt(0)  &#x2F;&#x2F;“\uD842”<br>charAt方法，返回的是UTF-16编码的第一个字节，实际上是无法显示的，目前，提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符串，返回正确的字符</p><p> ‘abc’.at(0) &#x2F;&#x2F;“a”<br> “吉”.at(0)  &#x2F;&#x2F;“吉”</p><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p>许多欧洲语言有语调号和重音符。为了表示他们Unicode提供两种解决办法，第一种是直接提供重音符号的字符。另一种是提供合成符号，即原字符与重音符号的合成，这两个字符合成一个字符。</p><p>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正则化。normalize方法可接受一个参数来指定normalize的方式，参数的四个可选值如下。</p><ol><li>NFC,默认参数，表示“标准等价合成”，返回多个简单字符和合成字符。所谓“标准等价合成”指的是视觉和语义上的等价</li><li>NFD，表示”标准等价分解”，即在标准等价的前提下，返回合成字符分解的多个简单字符。</li><li>NFKC，表示”兼容等价合成”，返回合成字符，</li><li>NFKD，表示”兼容等价分解”</li></ol><h2 id="includes-，startWith-endsWith"><a href="#includes-，startWith-endsWith" class="headerlink" title="includes()，startWith(),endsWith()"></a>includes()，startWith(),endsWith()</h2><p>传统上，JavaScript只有indexOf方法，用来确定一个字符串是否包含另一个字符串。ES6又提供了三个新方法。</p><ul><li>includes():返回布尔值，表示是否找到参数字符串。</li><li>startsWith():返回布尔值，表示参数字符串是否在源字符串的头部</li><li>endesWith():返回布尔值，表示参数字符串是否在源字符串的尾部</li></ul><p>这三个方法，都支持第二个参数，表示开始搜索的位置</p><p> var s &#x3D; ‘Hello world!’;<br> s.startsWith(“world”,6);&#x2F;&#x2F;true<br> s.endsWith(‘hello’,5);&#x2F;&#x2F;true<br> s.includes(‘hello’,6);&#x2F;&#x2F;false</p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>repeat方法返回一个新字符串，表示将元字符串重复n次</p><p> ‘x’.repeat(3);&#x2F;&#x2F;“xxx”<br> ‘na’.repaet(0);&#x2F;&#x2F;“”</p><p>参数如果是小数，会被向下取整，参数如果是负数或者Infinity会报错，参数如果是NaN，则等同于0</p><h2 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart(),padEnd()"></a>padStart(),padEnd()</h2><p>ES7推出了字符串补全长度的功能，如果某个字符串不够指定长度，会在头部或者尾部补全。padStart用于头部补全，padEnd用于尾部补全。</p><p> ‘x’.padStart(5,’ab’) &#x2F;&#x2F;‘ababx’<br> ‘x’.padEnd(5,’ab’)  &#x2F;&#x2F;‘xabab’<br>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串</p><p> ‘xxx’.padStart(2,’ab’); &#x2F;&#x2F;‘xxx’<br> ‘xxx’.padEnd(2,’ab’); &#x2F;&#x2F;‘xxx’<br>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截取超出位数的补全字符串。</p><p> ‘abc’.padStart(10,’0123456789’); &#x2F;&#x2F;‘0123145abc’<br>如果省略第二个参数，则会空出空格补全长度</p><p> ‘x’.padStart(4) &#x2F;&#x2F;‘   x’<br> ‘x’.padEnd(4)  &#x2F;&#x2F;‘x   ‘<br>padStart的常见的用途是为数值补全指定位数，下面代码生成10位的数值字符串</p><p> ‘1’.padStart(10,’0’) &#x2F;&#x2F;‘0000000001’</p><p>另一个用途是提示字符串格式</p><p> ‘12’.padStart(10,’YYYY-MM-DD’)&#x2F;&#x2F;‘YYYY-MM-12’<br> ‘09-12’.padStart(10,’YYYY-MM-DD’) &#x2F;&#x2F;‘YYYY-09-12’</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>传统的JavaScript语言，输出模板通常是这样写的</p><p> $(‘#result).append(<br>  ‘There are <b>‘ + basket.count +’</b>‘+<br>  ‘items in your basket, ‘ +<br>  ‘<em>‘ + basket.onSale +<br>  ‘</em> are on sale!’<br> );<br>这样写法相当繁琐不方便，ES6引入了模板字符串解决了和这个问题</p><p> $(‘#result’).append(<code>  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;   are on sale! </code>);<br>模板字符串(template String)是增强的字符串，用反(&#96;)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p><p> &#x2F;&#x2F;普通字符串<br> <code>In JavaScript &#39;\n&#39; in a line-feed.</code></p><p> &#x2F;&#x2F;多行字符串<br> <code> In JavaScript this is  not legal.</code></p><p> console.log(<code>string text line 1  string text line 2</code>);</p><p> &#x2F;&#x2F;字符串中嵌入变量<br> var name &#x3D; “Bob”,time &#x3D; “today”;<br> <code>Hello $&#123;name&#125;,how are you $&#123;today&#125;?</code></p><p>如果模板字符串用反引号标识，却需要在模板字符串中引用反引号，则在前面加上反斜杠转义</p><p>如果使用模板字符串表示多行字符串，所有空格和缩进都会保留在输出之中。</p><p> $(‘#list’).html(<code>  &lt;ul&gt;    &lt;li&gt;first&lt;/li&gt;    &lt;li&gt;second&lt;/li&gt;   &lt;/ul&gt; </code>);</p><p>如果你不想所有模板字符串的空格和换行，可以易用trim方法消除</p><p> $(‘#list’).html(<code>  &lt;ul&gt;    &lt;li&gt;first&lt;/li&gt;    &lt;li&gt;second&lt;/li&gt;   &lt;/ul&gt; </code>.trim());</p><p>模板字符串中嵌入变量，需要将变量名写在${}之中。<br>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。同样，模板字符串中还能调用函数</p><p> var x &#x3D;1;<br> var y &#x3D;2;<br> function fn(){<br>  return “Hello World!”;<br> }<br> <code>$&#123;x&#125; + $&#123;y&#125; = $&#123;x+y&#125;, $&#123;fn()&#125;</code><br> &#x2F;&#x2F;1+2&#x3D;3,Hello World</p><p>如果大括号中的值不是一个字符串，将会按照一般规则转化为字符串，比如，大括号中是一个对象，将默认调用对象的toString方法。</p><p>模板字符串甚至还能嵌套</p><p> const templ &#x3D; addrs &#x3D;&gt;’<br>  <table><br>   ${addrs.map( addr &#x3D;&gt;’<br>    <tr><td>${addr.first}</td></tr><br>    <tr><td>${addr.last}</dt></tr><br>   ‘).join(‘’)}<br>  </table><br> ‘;<br>模板字符串的变量之中，又嵌入了另一个模板字符串。</p><p> const data &#x3D; [<br>  {first:’<Jane>‘,last:’Bond’},<br>  {first:’Lars’,last:’<Croft>‘}<br> ];<br> console.log(templ(data));</p><p> 结果如下:<br> &#x2F;&#x2F;<table></p>  <tr><td><Jane></td></tr>  <tr><td>Bond</td></tr>  <tr><td>Lars</td></tr>  <tr><td><Croft></td></tr> //</table><p>如果需要引用模板字符串本身，在需要时，执行，可以像下面这样写。</p><p> &#x2F;&#x2F;写法一<br> let str &#x3D; ‘return’ + ‘<code>Hello $&#123;name&#125;!</code>‘;<br> let func &#x3D; new Function(‘name’,str);<br> func(‘Jack’) &#x2F;&#x2F;“Hello Jack!”</p><p> &#x2F;&#x2F;写法二<br> let str &#x3D; ‘(name) &#x3D;&gt;<code>Hello $&#123;name&#125;!</code>‘;<br> let func &#x3D; eval.call(null,str);<br> func(‘Jack’) &#x2F;&#x2F;‘Hellp Jack!’</p><h2 id="模板编译实例"><a href="#模板编译实例" class="headerlink" title="模板编译实例"></a>模板编译实例</h2><p>我们来看一个通过模板字符串，生成模板的实例</p><p> var template &#x3D; <code> &lt;ul&gt;   &lt;% for(var i =0;i&lt;data.supplies.length;i++)&#123; %&gt;    &lt;li&gt; &lt;%= data.supplies[i]  %&gt;&lt;/li&gt;   &lt;% &#125; %&gt;  &lt;/ul&gt; </code>;<br>该模板中放置了一个常规模板，该模板使用&lt;%…%&gt;放置JavaScript代码，使用&lt;%&#x3D; …%&gt;输出JavaScript表达式。</p><p>怎样编译这个模板字符串</p><p> 一种思路是将其转换为JavaScript字符串。<br> echo(‘<ul>‘);<br> for(var i &#x3D;0;i&lt;data.supplies.length;i++){<br>  echo(‘<li>‘);<br>  echo(data.supplies[i]);<br>  echo(</li>);<br> }<br> echo(‘</ul>‘);<br>这个转换使用正则表达式就可以了</p><p> var evalExpr &#x3D; &#x2F;&lt;%&#x3D;(.+?)%&gt;&#x2F;g;<br> var expr &#x3D; &#x2F;&lt;%([\s\S]+?)%&gt;&#x2F;g;</p><p> template &#x3D; template<br> .replace(evalExpr,<code>&#39;); \n echo( $1 ); \n echo(</code>‘)<br> .replace(expr,<code>&#39;); \n $1 \n echo(</code>‘);</p><p> template &#x3D; ‘echo(<code>&#39; + template +</code>‘);’;<br>然后，将<strong>templat</strong>e封装在一个函数里面返回，就可以了。</p><p> var script &#x3D;<br> &#96;(function parse(data){<br>  var output &#x3D; “”;</p><p>  function echo(html){<br>   output +&#x3D; html;<br>  }</p><p>  ${template}</p><p>  return output;</p><p> })&#96;;</p><p> return script;<br>将上面的内容拼装成一个模板编译函数compile。</p><p> function compile(template){<br>var evalExpr &#x3D; &#x2F;&lt;%&#x3D;(.+?)%&gt;&#x2F;g;<br> var expr &#x3D; &#x2F;&lt;%([\s\S]+?)%&gt;&#x2F;g;</p><p> template &#x3D; template<br> .replace(evalExpr,<code>&#39;); \n echo( $1 ); \n echo(</code>‘)<br> .replace(expr,<code>&#39;); \n $1 \n echo(</code>‘);</p><p> template &#x3D; ‘echo(<code>&#39; + template +</code>‘);’;</p><p> var script &#x3D;<br> &#96;(function parse(data){<br>  var output &#x3D; “”;</p><p>  function echo(html){<br>   output +&#x3D; html;<br>  }</p><p>  ${template}</p><p>  return output;</p><p> })&#96;;</p><p> return script;</p><p> }<br>compile函数的用法</p><p> var parse &#x3D; eval(compile(template));<br> div.innerHTML &#x3D; parse({supplies:[“broom”,”mop”,”cleaner”]});</p><p>运行结果:</p><p> &#x2F;&#x2F;<ul><br> &#x2F;&#x2F; <li>broom</li><br> &#x2F;&#x2F; <li>mop</li><br> &#x2F;&#x2F; <li>cleaner</li><br> &#x2F;&#x2F;</ul></p><h2 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h2><p>模板字符串的功能，不仅仅是上面这些，它可以紧跟在一个函数名后面，该函数被调用来处理这个模板字符串，这被称为”标签模板”功能</p><p> alert<code>123</code><br>等同于</p><p> &#x2F;&#x2F;alert(123);</p><p>标签模板其实不是模板，是函数调用的一种特殊形式。”标签”指的是函数，紧跟在函数后面的模板字符串是函数的参数。</p><p>但是，如果模板字符串里面有变量，就不是那么简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><p> var a &#x3D; 5;<br> var b &#x3D; 10;</p><p> tag<code>Hello $&#123;a + b&#125; world $&#123;a*b&#125;</code>;<br> &#x2F;&#x2F;等同于<br> tag([‘Hello’,’world’,’’],15,50);<br>tag函数会依次接收多个参数。</p><p> function tag(stringArr,value1,value2){<br>  &#x2F;&#x2F;…<br> }<br> &#x2F;&#x2F;等同于<br> function tag(stringArr,…values){<br>  &#x2F;&#x2F;…<br> }<br>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p><h2 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h2><p>ES6还为原生的String对象，提供了一个raw方法。<br>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义(即斜杠前面再加一个斜杠)的字符串，对应于替换变量后的模板字符串。</p><p>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p>String.raw方法也可以作为正常的函数使用。这时他的第一个参数应该是一个具有raw属性的对象，且raw属性值应该是一个数组。</p><p> String.raw({raw:’test’},0,1,2);<br> &#x2F;&#x2F;‘t0e1s2t’<br> &#x2F;&#x2F;等同于<br> String.raw({raw:[‘t’,’e’,’s’,’t’]},0,1,2);</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第三章 变量的解构赋值 </title>
    <link href="/2022/06/08/ECMAScript6-thrid-chart/"/>
    <url>/2022/06/08/ECMAScript6-thrid-chart/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="3-1-数组的结构赋值"><a href="#3-1-数组的结构赋值" class="headerlink" title="3.1 数组的结构赋值"></a>3.1 数组的结构赋值</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值(Destructuring)。</p><p>以前，为变量赋值，只能直接指定值</p><p> var a &#x3D; 1;<br> var b &#x3D;”hello”;<br> var c &#x3D; 3;</p><p>ES6允许这样写</p><p> var [a,b,c] &#x3D; [1,’hello’,3];</p><p>本质上，ES6的这种写法，属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值，下面是一些使用嵌套数组进行解构的例子。</p><p> let [foo,[[bar],baz]] &#x3D; [1,[[2],3]]<br> foo &#x2F;&#x2F;1<br> bar &#x2F;&#x2F;2<br> baz &#x2F;&#x2F;3</p><p> let [,,third] &#x3D; [“foo”,”bar”,”baz”]<br> third &#x2F;&#x2F;baz</p><p> let [head,…tail] &#x3D; [1,2,3,4];<br> head &#x2F;&#x2F;1<br> tail &#x2F;&#x2F;[2,3,4]</p><p> let[x,y,…z] &#x3D; [‘a’];<br> x&#x2F;&#x2F;“a”<br> y &#x2F;&#x2F; undefined<br> z &#x2F;&#x2F;[]</p><p>如果解构不成功，变量的值就等于undefined。</p><p> var [foo] &#x3D; [];<br> var [bar,foo] &#x3D; [1];<br>这两种情况是等号右边不等于左边</p><p> let [x,y] &#x3D; [1,2,3];<br> x &#x2F;&#x2F;1<br> y &#x2F;&#x2F;2</p><p> let [a,[b],c] &#x3D; [1,[2,3],4];<br> a &#x2F;&#x2F;1<br> b &#x2F;&#x2F;2<br> c &#x2F;&#x2F;4<br>这两种情况是等号左边的模式，只匹配等号右边的部分数组。</p><p>上面的两个例子，都属于不完全解构，但是可以成功。</p><p><strong>注意：</strong></p><p><strong>1.如果等号的右边不是数组，那么就会报错。</strong></p><p><strong>2.解构赋值不仅适用于var命令，也适用于let和const</strong></p><p><strong>3.解构赋值允许指定默认值var [foo &#x3D; 1]&#x3D;[];</strong></p><p><strong>4.ES6内部使用严格相等运算符(&#x3D;&#x3D;&#x3D;)来判断一个位置是否有值</strong></p><p> let x ;<br> if([1][0] &#x3D;&#x3D;&#x3D; undefined){<br>  x&#x3D;f();<br> }else{<br>  x&#x3D;[1][0]<br> }</p><p><strong>5.默认值可以引用解构赋值的其他变量，但该变量必须已经声明</strong></p><h2 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h2><p>解构赋值不仅可以用于数组，还可以用于对象。</p><p> var {foo,bar} &#x3D;{foo:”aaa”,bar:”bbb”};<br> foo &#x2F;&#x2F;“aaa”<br> bar &#x2F;&#x2F;“bbb”</p><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排序的，变量的取值由它的位置决定；</p><p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><p> var {baz} &#x3D; {foo:”aaa”,bar:”bbb”};<br> baz &#x2F;&#x2F;undefined</p><p>如果变量名与属性名不一致，必须要写成下面这样</p><p> var {foo:baz} &#x3D; {foo:’aaa’,bar:’bbb’};<br> baz  &#x2F;&#x2F;aaa;</p><p> let obj &#x3D; {first:’hello’,last:’world’};<br> let {first:f,last:l} &#x3D; obj;<br> f&#x2F;&#x2F;‘hello’<br> l&#x2F;&#x2F;‘world’<br>这本质上说明，对象的结构赋值是下面的简写形式</p><p> var {foo:foo,baz:baz} &#x3D; {foo:’aaa’,baz:’bbb’};</p><p>从另一方面说，对象的结构赋值，内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者——同名属性对应的变量，而不是同名属性。</p><p> var {foo:baz} &#x3D; {foo:”baz”,bar:”bbb”};<br> baz &#x2F;&#x2F;“aaa”<br> foo &#x2F;&#x2F;foo is not defined</p><p>理解：真正被赋值的是变量而不是属性。原因是，对象是引用类型的</p><p>对于ES6来说，let和const是不能重新声明的，所以一旦赋值的变量以前声明过，就会报错。</p><p> let foo;<br> let {foo} &#x3D; {foo:1};&#x2F;&#x2F;Duplicate declaration “fpp”<br>解构赋值的变量都会重新声明，所以报错了，不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。</p><p>和数组一样，解构也可以用于嵌套的对象。</p><p> var {p:[x,{y}]} &#x3D; {<br>    p:[<br>     ‘hello’,<br>     {y:’world’}<br>    ]<br>   };<br> x &#x2F;&#x2F;“hello”<br> y &#x2F;&#x2F;“world”<br>同理，对象的解构赋值也可以指定默认值</p><p> var {x&#x3D;3} &#x3D;{};<br> x&#x2F;&#x2F;3</p><p>默认值生成的条件是，对象的属性值严格等于undefined</p><p> var {x&#x3D;3} &#x3D; {x:undefined};<br> x&#x2F;&#x2F;3</p><p> var {x &#x3D; 3} &#x3D;{x:null}<br> x&#x2F;&#x2F;null<br>如果解构失败，变量的值等于undefined</p><p> var {foo} &#x3D; {bar:”baz”};<br> foo &#x2F;&#x2F;undefined<br>如果解构模式是嵌套的对象，而子对象所在的父属性不存在，那么将会报错</p><p> &#x2F;&#x2F;报错<br> var {foo:{bar}} &#x3D;  {baz:’baz’};<br>如果要将一个已经声明的变量用于解构赋值，必须非常小心</p><p> &#x2F;&#x2F;错误的写法<br> var x;<br> {x} &#x3D; {x:1};<br> &#x2F;&#x2F;SyntaxError:syntax error<br>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释成代码块，就能解决这个问题。</p><p> &#x2F;&#x2F;正确的写法<br> ({x}&#x3D;{x:1})<br>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。</p><p>解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式</p><p> ({} &#x3D; [true.false]);<br> ({} &#x3D; ‘abc’);<br> ({} &#x3D; []);</p><p>因为数组的本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><p> var arr &#x3D; [1,2,3];<br> var {0:first,[arr.length-1]:last} &#x3D; arr;<br> first &#x2F;&#x2F;1<br> last &#x2F;&#x2F;3</p><p>数组arr的o键对应的值是1，[arr.length - 1]就是2键，对应的值是3.方括号这种写法，属于”属性名表达式”。</p><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><p>字符串也可以解构赋值，这是因为，字符串被转换成了一个类似数组对象。</p><p> const [a,b,c,d,e] &#x3D; ‘hello’;<br> a  &#x2F;&#x2F;‘h’<br> b &#x2F;&#x2F;‘e’<br> c &#x2F;&#x2F;‘l’<br> d &#x2F;&#x2F;‘l’<br> e &#x2F;&#x2F;‘o’<br>类似数组的对象都有一个length属性，因此，还可以对这个属性解构赋值<br> let {length : len} &#x3D; “hello”;<br> len &#x2F;&#x2F; 5</p><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值，如果等号右边是数值和布尔值，则会先转化为对象</p><p> let {toString:s} &#x3D; 123;<br> s &#x3D;&#x3D;&#x3D; Number.prototype.toString &#x2F;&#x2F;true</p><p> let {toString: s} &#x3D; true;<br> s &#x3D;&#x3D;&#x3D; Boolean.prototype.toString &#x2F;&#x2F;true</p><p>上述代码中，数值和布尔值的包装对象都有toString属性，因此，变量s都能取到值</p><p>解构赋值的规则是：只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以，对它们进行解构赋值，都会报错。</p><p> let {prop:x} &#x3D; undefined;&#x2F;&#x2F;TypeError<br> let {prop:y} &#x3D; null;&#x2F;&#x2F;TypeError</p><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><p>函数的参数也可以使用解构赋值</p><p> function add([x,y]){<br>  return x + y;<br> }<br> add([1,2]); &#x2F;&#x2F;3</p><p>函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y，对于函数内部的代码来说，它们能感受到的参数就是x和y。</p><p> [[1,2],[3,4]].map(([a,b]) &#x3D;&gt; a + b);<br> &#x2F;&#x2F;[3,7]<br>数组的map方法，传入是一个方法，方法的参数，一次传入数组的值</p><p>函数参数的解构也可以使用默认值</p><p> function move({x&#x3D;0,x&#x3D;0} &#x3D;{}){<br>  return [x,y];<br> }<br> move({x:3,y:8});&#x2F;&#x2F;[3,8]<br> move({x:3});&#x2F;&#x2F;[3,0]<br> move({});&#x2F;&#x2F;[0,0]<br> move();&#x2F;&#x2F;[0,0]</p><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值，如果解构失败，x和y等于默认值。</p><p>注意：</p><p> function move({x：0,x：0} &#x3D;{}){<br>  return [x,y];<br> }<br> move({x:3,y:8});&#x2F;&#x2F;[3,8]<br> move({x:3});&#x2F;&#x2F;[3,undefined]<br> move({});&#x2F;&#x2F;[undefined,undefined]<br> move();&#x2F;&#x2F;[0,0]<br>为什么会得到不一样的结果，函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p><p>undefined会触发函数参数的默认值</p><p> [1,undefined,3].map((x &#x3D; ‘yes’) &#x3D;&gt; x);<br> &#x2F;&#x2F;[1,’yes’,3]</p><h2 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易，对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到等号才能知道</p><p>由此带来的问题是如果模式中出现圆括号该怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。<br>但是，这条规则实际上不容易辨别，处理起来相当麻烦，因此，建议只要有可能，就不要再模式中方法之圆括号。</p><ol><li>变量声明中，不能带有圆括号</li></ol><p>  &#x2F;&#x2F;全部报错<br>  var [(a)] &#x3D; [1];<br>  var {x:(c)} &#x3D; {};<br>  var ({x:c}) &#x3D; {};<br>  var {(x):c} &#x3D; {};</p><p>  var {o:({p:p})} &#x3D; {o:{p:2}};<br>  &#x2F;&#x2F;变量声明语句，模式不能使用圆括号。</p><ol start="2"><li>函数参数中，模式不能带有圆括号</li></ol><p> 函数参数也属于变量声明，因此不能带有圆括号</p><p>  &#x2F;&#x2F;报错<br>  function f([(z)]) {return z; }</p><ol start="3"><li>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。</li></ol><p>  &#x2F;&#x2F;全部报错<br>  ({p:a})  &#x3D; {p:42};<br>  ([a]) &#x3D; [5];</p><p>  &#x2F;&#x2F;报错<br>  [({p:a}),{x:c}] &#x3D; [{},{}];</p><h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>可以使用圆括号的只有一种情况：赋值语句的非模式部分，可以使用圆括号</p><p> [(b)] &#x3D; [3];&#x2F;&#x2F;争取<br> ({p:(d)} &#x3D;  {});&#x2F;&#x2F;正确<br> [(parseInt.prop)] &#x3D; [3]&#x2F;&#x2F;正确</p><p>这三行都是赋值语句，不是声明语句；其次，他们的圆括号都不属于模式的一部分。第一行语句中，模式时取数组的第一个成员，跟圆括号无关；第二行语句中，模式时p，而不是d；第三行语句与第一行语句的性质一致。</p><h2 id="解构赋值的用处"><a href="#解构赋值的用处" class="headerlink" title="解构赋值的用处"></a>解构赋值的用处</h2><ol><li>交换变量的值</li></ol><p> 写法简洁，易读，语义非常清晰。</p><p>  [x,y] &#x3D; [y,x];</p><ol start="2"><li>从函数返回多个值</li></ol><p> 函数只能返回一个值，如果要返回多个直，只能将它们放在数组或者对象里返回，有了解构赋值，取出这些值就非常方便。</p><p>  &#x2F;&#x2F;返回一个数组<br>  function example(){<br>   return [1,2,3];<br>  }<br>  var [a,b,c] &#x3D; example();</p><p>  &#x2F;&#x2F;返回一个对象<br>  function example(){<br>   return{<br>    foo:1,<br>    bar:2<br>   };<br>  }<br>  var {foo,bar} &#x3D; example();</p><ol start="3"><li>函数参数的定义</li></ol><p> 解构赋值可以方便地将一组参数与变量名对应起来。</p><p>  &#x2F;&#x2F;参数是一组有次序的值<br>  function f([x,y,z]){…}<br>  f([1,2,3]);</p><p>  &#x2F;&#x2F;参数是一组无次序的值<br>  function f({x,y,z}){…}<br>  f({z:3,y:2,x:1});</p><ol start="4"><li>提取JSON数据</li></ol><p> 解构赋值对提取JSON对象中的数据，尤其有用。</p><p>  var jsonData &#x3D; {<br>   id:42,<br>   status:’OK’,<br>   data:[111,222]<br>  };</p><p>  let {id,status,data:number} &#x3D;jsonDat;</p><p>  console.log(id,status,number);<br>  &#x2F;&#x2F;42,”OK”,[111,222]</p><ol start="5"><li>函数参数的默认值</li></ol><p>  jQuery.ajax &#x3D; function(url,{<br>   async &#x3D; true,<br>   beforeSend &#x3D; function(){},<br>   cache &#x3D; true,<br>   complete &#x3D; function (){},<br>   crossDomain &#x3D; false,<br>   global &#x3D; true,<br>   &#x2F;&#x2F;… more config</p><p>  }){<br>   &#x2F;&#x2F;… do stuff<br>  };<br> 指定参数默认值，就避免了在函数体内部再写var foo &#x3D; config.foo || ‘default foo’这样的语句</p><ol start="6"><li>遍历Map结构</li></ol><p> 任何部署了，Iterator接口的对象，都可以用for … of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值非常方便。</p><p>  var map &#x3D; new Map();<br>  map.set(‘first’,’hello’);<br>  map.set(‘second’,’world’);</p><p>  for(let [key,value] of map){<br>   console.log(key + “ is “ +value);<br>  }<br>  &#x2F;&#x2F;first is hello<br>  &#x2F;&#x2F;second is world<br> 如果只想获取键名</p><p>  &#x2F;&#x2F;获取键名<br>  for(let[key] of map){<br>   &#x2F;&#x2F;…<br>  }</p><p>  &#x2F;&#x2F;获取键值<br>  for(let [,value] of map){<br>   &#x2F;&#x2F;…<br>  }</p><ol start="7"><li>输入模块的指定方法</li></ol><p> 加载模块时，往往需要指定输入那些方法。结构赋值使得语句非常清晰</p><p>  const{SourceMapConsumer,SourceNode} &#x3D; require(“source-map”);</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第二章 let和const</title>
    <link href="/2022/06/07/ECMAScript6-second-chart/"/>
    <url>/2022/06/07/ECMAScript6-second-chart/</url>
    
    <content type="html"><![CDATA[<h2 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>es6新增let命令，用来声明变量。它的用法类似于var，但是所声明的变量,只有在let命令所在的代码块内有效</p><p> {<br>  let a &#x3D; 10;<br>  var b &#x3D; 1;<br> }</p><p> a &#x2F;&#x2F;ReferenceError:a is not defined<br> b &#x2F;&#x2F;1</p><p>解释:分别用let和var声明了两个变量。然后在代码块外面调用这个两个变量，结果let声明的变量报错，var 申明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块中有效</p><p><strong>for循环的计数器，就很适合使用let命令</strong></p><p> for(let i &#x3D;0;i&lt;arr.length;i++){<br>  console.log(i);<br> }<br> console.log(i);</p><p>上面代码的计数器i，只在for循环中有效<br>下面的代码如果使用var，最后输出的是10</p><p> var a &#x3D;[];<br> for (var i &#x3D;0;i&lt;10;i++){<br>  a[i] &#x3D;function(){<br>   console.log(i);<br>  };<br> }<br> a<a href="">6</a>;&#x2F;&#x2F;10</p><p>分析:变量i是var声明的，在全局范围内有效，所有每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i值</p><p>如果用let，声明，声明的变量仅在块级作用域中有效，最后输出的是6.如下：</p><p> var a &#x3D;[];<br> for (let i &#x3D;0;i&lt;10;i++){<br>  a[i] &#x3D;function(){<br>   console.log(i);<br>  };<br> }<br> a<a href="">6</a>;&#x2F;&#x2F;6</p><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>let不像var那样会发生”变量提升”现象，所以变量一定要在声明后使用，否则报错</p><p> console.log(foo);&#x2F;&#x2F;undefined<br> console.log(bar);&#x2F;&#x2F;ReferenceError</p><p> var foo &#x3D; 2;<br> let bar &#x3D; 2;</p><p>解释：变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是<br>没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前<br>变量bar是不存在的，这时如果用到它就会抛出一个错误。</p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在命令，它所声明的变量就”绑定”(binding)这个区域，不再受外部的影响。</p><p> var temp &#x3D; 123;</p><p> if(true){<br>  temp &#x3D;”abc”;&#x2F;&#x2F;ReferenceError<br>  let temp;<br> }</p><p>上面代码中，存在全局变量temp,但是块级作用域内let又声明了一个局部变量temp，导致后者绑定这个<br>块级作用域，所以在let声明变量前，对temp赋值会报错。</p><p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了<br>封闭作用域。凡是在声明之前使用这些变量，就会报错</p><p><strong>定义：</strong>在代码块内，使用let命令声明变量之前，该变量是不可用的，这在语法上，称为”<strong>暂时性死区</strong>“</p><p> if(true){</p><p>  tmp &#x3D; “abc”;<br>  console.log(tmp);</p><p>  let tmp;<br>  console.log(tmp);</p><p>  tmp &#x3D; “123”;<br>  console.log(tmp);<br> }</p><p>上面代码中let命令声明变量tmp之前，都属于tmp的“死区”<br>“暂时性死区”也意味着typeof不再是一个百分百安全的操作。</p><p> typeof x;<br> let x;</p><p>上面代码中，变量x使用let命令声明，所有在声明之前都属于x的“死区”<br>只要用到该变量就会报错，因此，typeof运行时就会抛出一个ReferemceError</p><p>作为比较，如果一个变量根本没有白声明，使用typeof反而不会报错</p><p> typeof undecleared_variable &#x2F;&#x2F;“undefined”</p><p>上面代码中，undeclared_variable是一个不存在的变量名，结果返回”undefined”。所以，在<br>没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这点不成立了。这样设计是<br>为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则报错。</p><p>有些“死区”比较隐藏，不太容易发现。</p><p> function bar(x&#x3D;y,y&#x3D;2){<br>  return [x,y];<br> }<br> bar();&#x2F;&#x2F;报错</p><p>解释：调用bar函数之所以报错(某些实现可能不报错)，是因为参数x默认值等一另一个参数<br>y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。</p><p> function bar(x&#x3D;2,y&#x3D;x){<br>  return [x,y];<br> }<br> bar();&#x2F;&#x2F;[2,2]</p><p>ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止变量在声明<br>之前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这样的规定<br>避免此错误就容易很多。</p><p>暂时性死区的本质就是，只要已进入当前作用域，所要使用的变量就已经存在了，但是不可获取，<br>只有等到声明变量的哪一行代码出现，才可以获取和使用该变量。</p><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let不允许在相同的作用域内，重复声明一个变量</p><p> &#x2F;&#x2F;报错<br> function(){<br>  let a &#x3D; 10;<br>  var a &#x3D;1;<br> }<br> &#x2F;&#x2F;报错<br> function(){<br>  let a &#x3D; 10;<br>  let a &#x3D;1;<br> }</p><p>因此，不能在函数内部重新声明参数</p><p> function func(arg){<br>  let arg;&#x2F;&#x2F;报错<br> }<br> function func(arg){<br>  {<br>   let arg;<br>  }<br> }</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><p>ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的长江。</p><p>第一种场景，内层变量可能会覆盖外层变量。</p><p> var tmp &#x3D; new Date();</p><p> function f(){<br>  console.log(tmp);<br>  if(false){<br>   var tmp &#x3D; “hello world”;<br>  }<br> }</p><p> f();&#x2F;&#x2F;undefined</p><p>上面代码中，函数f执行后，输出结果为undefined,原因在于变量提升，导致内层的tmp变量<br>覆盖了外层的tmp变量。</p><p>第二种场景，用来计数的循环变量泄露为全局变量</p><p> var s &#x3D; ‘hello’;</p><p> for(var i &#x3D; 0;i &lt;s.legnth;i++){<br>  console.log(s[i]);<br> }<br> console.log(i);&#x2F;&#x2F;5</p><p>上面代码中，变量i只用来控制循环，但循环结束之后，它并没有消失，泄露成了全局变量</p><h3 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h3><p>let实际上为JavaScript新增了块级作用域</p><p> function f1(){<br>  let n &#x3D; 5;<br>  if (true){<br>   let n &#x3D; 10;<br>  }<br>  console.log(n);&#x2F;&#x2F;5</p><p> }</p><p>上面的函数中有两个代码块，都声明了变量n，运行后输出5，则表示，外层代码块不受内层代码块的<br>影响。如果使用var定义变量n，最后输出的值就是10；</p><p>ES6允许块级作用域的任意嵌套</p><p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数(IIFE)不在必要了。</p><p> &#x2F;&#x2F;IIFE写法<br> (function(){<br>  var tmp &#x3D; …;<br>  …<br> }());</p><p> &#x2F;&#x2F;块级作用域的写法<br> {<br>  let temp &#x3D; …;<br>  …<br> }</p><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。<br>ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><p> &#x2F;&#x2F;情况一<br> if(true){<br>  function f(){}<br> }</p><p> &#x2F;&#x2F;情况二<br> try{<br>  function f(){}<br> }catch(e){<br>  }</p><p>这两种函数声明，根据ES5的规定都是非法的。<br>但是，浏览器没有遵守这个规定，还是支持在块级作用域之中声明函数，因此，上面两种情况实际<br>都能运用，不会报错，不过，“严格模式下”还是会报错</p><p> &#x2F;&#x2F;ES5严格模式<br> ‘use strict’;<br> if(true){<br>  function f(){}<br> }<br> &#x2F;&#x2F;报错<br> ES6引入了块级作用域，明确允许在块级作用与之中声明函数。<br> &#x2F;&#x2F;ES6严格模式<br> if(true){<br>  function f(){}<br> }<br> &#x2F;&#x2F;不报错</p><p>并且ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><p> function f(){ console.log(‘I am outside!’);}</p><p> (function(){<br>  if(false){<br>   &#x2F;&#x2F;重复声明一次函数f<br>   function f(){console.log(‘I am inside!’);}</p><p>  }<br>  f();<br> }())</p><p>上面代码在ES5中运行，会得到”I am inside!”,因为在if内声明的函数f会被提升到函数头部，实际运行的<br>代码如下。</p><p> &#x2F;&#x2F;ES5版本<br> function f(){console.log(‘I am outside!’);}<br> (function (){<br>  function f(){console.log(‘I am inside!’);}<br>   if(false){<br>   }<br>  f();<br> }());</p><p>ES6运行结果就完全不一样了，会得到”I am outside!”因为块级作用域内声明的函数类似以let<br>，对作用域之外没有影响，实际运行的代码如下。</p><p> &#x2F;&#x2F;ES6版本<br> function f(){console.log(‘I am outside!’)}<br> (function (){<br>  f();<br> }())</p><p>很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B<br>中规定，浏览器实现可以不遵守上面的规定，有自己的行为方式。</p><ul><li>允许在块级作用域内声明函数</li><li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部</li><li>同时，函数声明还会提升到所在块级作用域的头部</li></ul><p>注意，上面三条规则只对ES6的浏览器实现有效，其他环境啊的实现不用遵守，还是将块级作用的函数声明当let处理，<br>前面那段代码，在Chrome环境下运行会报错。</p><p> &#x2F;&#x2F;ES6的浏览器环境<br> function f(){console.log(‘I am outside!’);}<br> (function(){<br>  if(false){<br>  &#x2F;&#x2F;重复声明一次函数f<br>  function f(){console.log(‘I am inside!’);}<br>  }<br>  f();<br> }())<br> &#x2F;&#x2F;Uncaught TypeError: f is not a function</p><p>上面的代码报错，是因为实际运行的是下面的代码</p><p> &#x2F;&#x2F;ES6的浏览器环境<br> function f(){console.log(‘I am outside!’);}<br> (function (){<br>  var f &#x3D; undefined;<br>  if(false){<br>   function f(){console.log(‘I am inside!’);}<br>  }<br>  f();<br> }());<br> &#x2F;&#x2F;Uncaught TypeError: f is not a function</p><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是<br>函数声明语句</p><p> &#x2F;&#x2F;函数声明语句<br> {<br>  let a &#x3D; ‘secret’;<br>  function f(){<br>   return a;<br>  }</p><p> }</p><p> &#x2F;&#x2F;函数表达式<br> {<br>  let a &#x3D; ‘secret’;<br>  let f &#x3D; function(){<br>   return a;<br>  }<br> }</p><p>另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立<br>如果没有使用大括号，就会报错</p><p> &#x2F;&#x2F;不报错<br> ‘use strict’;<br> if(true){<br>  function f(){}<br> }</p><p> &#x2F;&#x2F;报错<br> ‘use strict’;<br> if(true)<br>  function f(){}</p><h2 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h2><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变</p><p> const PI &#x3D; 3.1415;</p><p> PI &#x3D; 3 ;<br> &#x2F;&#x2F;TypeError：Assignment to constant varoiable.</p><p><strong>改变常量的值会报错。</strong></p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到最后赋值</p><p> const foo;<br> &#x2F;&#x2F;SyntaxtError: Missing initializer in const declaration</p><p>上面代码表示，对于const来说，只声明不赋值，就会报错</p><p>const作用域与let命令相同：只在声明所在的块级作用域内有效。</p><p> if(true){<br>  const MAX &#x3D; 5;<br> }<br> MAX&#x2F;&#x2F;Unctught ReferenceError:MAX is no defined</p><p>const 命令声明的常量也是不提升的，同样存在暂时性死区，只能在声明的位置后面使用。</p><p> if(true){<br>  console.log(MAX);&#x2F;&#x2F;ReferenceError<br>  const MAX &#x3D; 5;<br> }</p><p>上面代码在常量MAX声明之前就调用，结果报错。<br>const声明的常量，也与let一样不可重复声明。</p><p> var message &#x3D; ‘hello!’;<br> let age &#x3D; 25;</p><p> &#x2F;&#x2F;一下两行都会报错<br> const message &#x3D; “Goodbye!”;<br> const age &#x3D; 30;</p><p>对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量<br>名指向的地址不变，并不保证改地址的数据不变，所以讲一个对象声明为常量必须非常小心</p><p> consy foo &#x3D; {};<br> foo.prop &#x3D; 123;</p><p> foo.prop<br> &#x2F;&#x2F;123<br> foo &#x3D; {}&#x2F;&#x2F;TypeError:”foo” is read-only</p><p>上面的代码中，常量foo存储的是一个地址，这个地址指向一个对象，不可变的只是这个地址，即<br>不能把foo指向另一个地址，但对象本身是可变的，所以一依然可以为其添加新的属性</p><p>下面是另一个例子。</p><p> const a &#x3D; [];<br> a.push(‘hello’);&#x2F;&#x2F;可执行<br> a.length &#x3D; 0;&#x2F;&#x2F;可执行<br> a &#x3D; [“Dave”];</p><p>常量a是一个数组，这个数组本身手机可写的，但是如果将另一个数组赋值给a，就会报错。<br>如果真的想将对象冻结，应该使用object.freeze方法。</p><p> const foo &#x3D; object.freeze({});<br> &#x2F;&#x2F;常规模式下，下面一行不起作用<br> &#x2F;&#x2F;严格模式时，该运行会报错<br> foo.prop &#x3D; 123;<br>常量foo指向一个冻结的对象，所以添加的属性不起作用，严格模式时还会报错。<br>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数</p><p> var constize &#x3D; (obj) &#x3D;&gt;{<br>  object.freeze(obj);<br>  object.keys(obj).forEach((key,value)&#x3D;&gt;{<br>   if(typeof obj[key] &#x3D;&#x3D;&#x3D; ‘object’){<br>    constantize(obj[key]);<br>   }<br>  });<br> };</p><p>ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节<br>还会提到另外两种声明变量的方法：import命令和class命令。所以，ES6一共6种声明变量的方法。</p><h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><p>全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5之中，<br>全局对象的属性与全局变量是等价的</p><p> window.a &#x3D; 1;<br> a&#x2F;&#x2F;1<br> a &#x3D; 2;<br> window.a&#x2F;&#x2F;2</p><p>全局对象的属性赋值与全局变量的赋值，是同一件事。（对NODE来说，这一条只对REPL环境适用，<br>模块环境之中，全局变量必须显示声明成global对象的属性。）</p><p>未声明的全局变量，自动成为全局对象window的属性，这被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了<br>很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才知道，其次程序员很容易不知不觉就创建<br>了全局变量（比如打错字）。另一方面，从语义上讲，语言的顶层对象是一个实体含义的对象，也是不合适的。<br>ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是全局对象属性；另一方面<br>另一方面规定，let命令、const命令、class命令声明的全局便令，不属于全局对象的属性。也就是说，从ES6开始，全局<br>变量将逐步与全局对象属性脱钩。</p><p> var a &#x3D; 1;<br> &#x2F;&#x2F;如果在Node的REPL环境，可以写成global.a<br> &#x2F;&#x2F;或者采用通用方法，写成this.a<br> window.a&#x2F;&#x2F;1<br> let b &#x3D; 1;<br> window.b &#x2F;&#x2F;undefined</p><p>全局变量a由bar命令声明，所以它是全局对象的属性；全局变量a由let命令声明，所以它不是全局对象的属性<br>返回undefined。</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6第一章 ES6简介和Babel转码</title>
    <link href="/2022/06/06/ECMAScript6-first-chart/"/>
    <url>/2022/06/06/ECMAScript6-first-chart/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h2><p>ECMAScript 6.0是JavaScript语言的下一代标准，在2015年6月正式发布，它的目标是，是的JavaScript语言<br>可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><h2 id="ECMAScript和JavaScript的关系"><a href="#ECMAScript和JavaScript的关系" class="headerlink" title="ECMAScript和JavaScript的关系"></a>ECMAScript和JavaScript的关系</h2><p>1996年11月，JavaScript的创建者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA,<br>希望JavaScript能成为国际标准，为什么不叫JavaScript，有两个原因，一个是商标，Java是Sun公司<br>的商标，根据授权协议，只有Netscape公司可以合法使用JavaScript这个名字，二是，想体现这门语言<br>制定者是ECMA,不是Netscape，这样有利于保证这门语言的开放性和中立性<br>ECMAScript是JavaScript的规格，JavaScript是ECMAScript的实现。（另外的还有Jscript<br>和ActionScript）<br>ES6从开始定知道最后发布，用了整整15年</p><p>ES1.0 是1997年发布<br>ES2.0 是1998年<br>ES3.0 是1999年<br>3.0版本是一个巨大的成功，在业界得到了广泛的支持，成为通行标准，奠定了JavaScript的基本语法<br>ES4.0 从2000年开始酝酿，但最后没有通过，因为版本太激进了，对ES3做了彻底的升级<br>负责制定ECMAScript标准的成员，包括Microsoft、Mozilla、Goggle等大公司驳回了<br>ES4.0 2007年10月，以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级<br>ES3.1 2008年7月 终止了ES4.0的开发，只涉及部分功能改善，发布成了ES3.1<br>ES5.0 2009年12月，发布<br>ES5.1 2011年6月发布<br>ES6.0 2013年2月草案被冻结<br>ES6.0 2013年12月 发布<br>ES6.0 2015年6月 ECMAScript 6正是通过</p><h2 id="部署进度"><a href="#部署进度" class="headerlink" title="部署进度"></a>部署进度</h2><p>各大浏览器的最新版本，对ES6的支持可以看kangax.github.io&#x2F;es5-compat-table&#x2F;es6&#x2F;。<br>随着时间的推移，支持度已经越来越高了，ES6的大部分特性都已经实现了</p><p>Node.js是JavaScript语言的服务器运行环境，对ES6的支持度比浏览器更高。通过Node，可以<br>体验更多的ES6的特性，建议使用版本工具nvm，来安装Node，以为可以自由切换版本。</p><h2 id="第一章-Babel转码器"><a href="#第一章-Babel转码器" class="headerlink" title="第一章 Babel转码器"></a>第一章 Babel转码器</h2><p>Babel是一个广泛使用的ES6转码器，可以将ES6转为ES5代码，从而在现有环境执行，这意味着，你可以用<br>ES6的方式编写程序，又不用担心现有环境是否支持</p><p> &#x2F;&#x2F;转码前<br> input.map(item &#x3D;&gt; item +1);</p><p> &#x2F;&#x2F;转码后<br> input,map(function(item){<br>  return item +1;<br> })</p><h2 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件**.babelrc**"></a>配置文件**.babelrc**</h2><p>Babel的配置文件是**.babelrc**,存放在项目的根目录下。<br>使用Babel的第一步，就是配置这个文件，该文件用来设置转码规则和插件，基本格式如下</p><p> {<br>    “presets”:[],<br>    “plugins”:[]<br> }</p><p>presets字段设定转码规则，官方提供一下的规则集，你可以根据需要安装</p><p>plugins字段设定转码插件</p><h4 id="ES2015转码规则"><a href="#ES2015转码规则" class="headerlink" title="ES2015转码规则"></a>ES2015转码规则</h4><p> npm  install  –save-dev babel-preset-es2015</p><h4 id="react转码规则"><a href="#react转码规则" class="headerlink" title="react转码规则"></a>react转码规则</h4><p> $npm install –save-dev babel-preset-react</p><h4 id="ES7不同阶段语法天的转码规则（共四个阶段），选装其中一个"><a href="#ES7不同阶段语法天的转码规则（共四个阶段），选装其中一个" class="headerlink" title="ES7不同阶段语法天的转码规则（共四个阶段），选装其中一个"></a>ES7不同阶段语法天的转码规则（共四个阶段），选装其中一个</h4><p> $npm install –save-dev babel-preset-stage-0<br> $npm install –save-dev babel-preset-stage-1<br> $npm install –save-dev babel-preset-stage-2<br> $npm install –save-dev babel-preset-stage-3</p><p>然后，将这些规则加入到 .babelrc</p><p> {<br>   “presets”:[<br>  “es2015”,<br>  “react”,<br>  “stage-2”<br>   ],<br>   “plugins”:[]<br> }</p><p>注意，一下所有的Babel工具和模块的应用都必须先写好.babelrc。</p><h3 id="命令行转码babel-cli"><a href="#命令行转码babel-cli" class="headerlink" title="命令行转码babel-cli"></a>命令行转码babel-cli</h3><p>Babel提供babel-cli工具，用于命令行转码</p><p>它的安装命令如下</p><p> $npm install –global babel-cli</p><p>基本用法如下</p><p> #转码结果输出到标准输出<br> $babel example.js</p><p> #转码结果写入一个文件</p><h1 id="–out-file-或-o-参数指定输出文件"><a href="#–out-file-或-o-参数指定输出文件" class="headerlink" title="–out-file 或-o 参数指定输出文件"></a>–out-file 或-o 参数指定输出文件</h1><p> $ babel example.js -o compiled.js</p><p> #整个目录转码</p><h1 id="–out-dir-或-d参数指定输出目录"><a href="#–out-dir-或-d参数指定输出目录" class="headerlink" title="–out-dir 或 -d参数指定输出目录"></a>–out-dir 或 -d参数指定输出目录</h1><p> $ babel src –out-dir lib<br> #或者<br> $ babel src -d lib</p><h1 id="s参数生成-source-map文件"><a href="#s参数生成-source-map文件" class="headerlink" title="-s参数生成 source map文件"></a>-s参数生成 source map文件</h1><p> $babel src -d lib  -s</p><p>上面代码是在全局环境下，进行Babel转码。意味着，如果项目要运行，全局环境必须要有Babel，<br>这也就是说项目产生了对环境的依赖。<br>另一方面，这样做也无法支持不同项目使用不同版本的Babel</p><p>一个解决办法就是将babel-cli安装在项目之中</p><p> #安装<br> $ npm install –save-dev babel-cli</p><p>然后改写package.json</p><p> {<br>  &#x2F;&#x2F;…<br>  “devDependencies”:{<br>   “babel-cli”:”^6.0.0”<br>  },<br>  “scripts”:{<br>   “bulid”:”babel src -d lib”<br>  },<br> }</p><p>转码的时候，就执行下面的命令</p><p> npm run build</p><h3 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h3><p>babel-cli工具自带一个babel-node命令，提供一个支持ES6的REPL环境，它还支持Node的<br>REPL环境的所有功能，而且可以直接运行ES6代码</p><p>它不用单独安装，而是随着babel-cli一起安装，然后执行babel-node就进入了REPL环境</p><p> $ babel-node</p><blockquote><p>(x &#x3D;&gt; x *2)(1)<br> 2</p></blockquote><p>babel-node命令可以直接运行ES6脚本，将上面的代码放入脚本文件es6.js,然后直接运行</p><p> $ babel-node es6.js<br> 2</p><p>babel-node也可以安装在项目中</p><p> npm install –save-dev babel-cli</p><p>然后改写package.json</p><p> {<br>  “scripts”:[<br>   “script-name”:”babel-node script.js”<br>  ]<br> }</p><p>解释：使用babel-node替代node,这样script.js本身就不用做任何转码处理</p><h3 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h3><p>babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载<br>.js、.jsx、.es和.es6后缀名的文件，就会先用Babel进行转码</p><p> $npm install –save-dev babel-register</p><p>使用时，必须首先加载babel-register。</p><p> require(“babel-register”);<br> require(“.&#x2F;index.js”);</p><p>然后，就不需要手动对index.js进行转码了<br>需要注意的是，babel-register只会对require命令加载的文件转码，而不会对大年文件转码。另外，由于它是<br>实时转码，所以只适合在开发环境使用</p><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><p>如果某些代码需要调用Babel的API进行转码，就要使用babel-core模块<br>安装命令如下</p><p> npm install babel-core –save</p><p>然后，在项目中就可以调用babel-core</p><p> var babel &#x3D; require(‘babel-core’);</p><p> &#x2F;&#x2F;字符串转码<br> babel.transform(‘code();’,optins);<br> &#x2F;&#x2F;&#x3D;&gt;{code,map,ast}</p><p> &#x2F;&#x2F;文件转码(异步)<br> babel.transformFile(‘filename.js’,options,function(err,result){<br>  result;&#x2F;&#x2F;&#x3D;&gt;{code,map,ast}<br> })</p><p> &#x2F;&#x2F;文件转码(同步)<br> babel.transforFileSync(‘filename.js’,options);<br> &#x2F;&#x2F;&#x3D;&gt;{code,map,ast}</p><p> &#x2F;&#x2F;Babel AST转码<br> babel.transformFromAst(ast,code,options);<br> &#x2F;&#x2F;&#x3D;&gt;{code,map,ast}</p><p>例子：</p><p> var es6Code &#x3D; ‘let x &#x3D; n &#x3D;&gt; n +1’;<br> var es5Code &#x3D; require(‘babel-core’).transform(es6Code,{<br>   presets:[‘es2015’]<br>  }).code;<br> &#x2F;&#x2F;‘“use strict”;\n\n var x &#x3D;function x(n){\n return n +1;\n}’</p><p>解释：transform方法的第一个参数是一个字符串，表示需要被转换的ES6代码，第二个参数<br>是转换的配置对象。</p><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>Babel默认只转换新的JavaScript句法(syntax),而不是转换新的API，比如Iterator、Generator<br>、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法<br>（比如object.assign）都不会转码。</p><p>举例来说，ES6在Array对象上新增了Array.from方法，Babel就不会转码这个方法。如果想让这个方法<br>运行，必须使用babel-polyfill,为当前环境提供一个垫片。<br>安装命令如下</p><p> npm install –save babel-polyfill</p><p>然后，在脚本头部，加入如下一行代码。</p><p> import ‘babel-polyfill’;<br> &#x2F;&#x2F;或者<br> require(‘babel-polyfill’);<br> Babel默认不转码的API非常多，详细清单可以查看babel-plugin-transform-runtime模块的<br> definitions.js文件。</p><h3 id="浏览器换将"><a href="#浏览器换将" class="headerlink" title="浏览器换将"></a>浏览器换将</h3><p>Babel也可以用于浏览器环境。但是从Babel6.0开始，不再直接提供浏览器版本，而是要构建工具构建<br>出来。如果你没有或不想使用构建工具，可以通过安装5.x版本的babel-core模块获取。</p><p> npm install babel-core@5</p><p>运行上面的命令以后，就可以在当前目录的node_mpdules&#x2F;babel-core&#x2F;子目录里面，找到<br>babel的浏览器版本browser.js（未精简）和browser.min.js(已经精简)</p><p>然后，将下面的代码插入网页<br> <script src="node_modules/babel-core/browser.js"><scrpit><br> <script type="text/babel"><br> //your ES6 CODE<br> </script></p><p>上面代码中，browser.js是Babel提供的转换脚本，可以在浏览器运行。用户的ES6脚本放在<br>script标签中，弹药注明type&#x3D;”text&#x2F;babel”。另一种方法是使用babel-standalone模块提供的<br>浏览器版本，将其插入网页</p> <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel,min,js"></scrip> <script type="text/babel"> //your ES6 CODE </script><p>注意，网页中实时将ES6代码转为ES5，对性能会有影响。生产环境需要加载转码完成的脚本。</p><p>下面是如何将代码打包成浏览器可以使用的脚本，一Babel配合Browserify为例。首先，安装<br> babelify模块。<br> $ npm install –save-dev babelify babel-preset-es2015</p><p>然后，再用命令行转换ES6脚本。</p><p> $ browserif script.js -o bundle.js <br> -t [ babelify –presets [es2015]]<br>上面代码将ES6脚本script.js，转为bundle.js，浏览器直接加载后者就可以了。<br>在package.json设置下面的代码，就不用每次命令行都输入参数了</p><p> {<br>  “browserify”:{<br>   “transform”:[[“babelify”,{“presets”:[“es2015”]}]]<br>  }<br> }</p><h3 id="与其他工具的配合"><a href="#与其他工具的配合" class="headerlink" title="与其他工具的配合"></a>与其他工具的配合</h3><p>许多工具需要Babel进行前置转码，这里有两个例子：ESLint和Mocha。<br>ESLint用于静态检查代码语法和风格，安装命令如下。</p><p> npm install –save-dev selint babel-eslint</p><p>然后，在项目根目录下，新建一个配置文件 .eslintrc,在其中加入parser字段。</p><p> {<br>  “parser”:”babel-eslint”,<br>  “rules”:{<br>   …<br>  }<br> }</p><p>再在package.json之中，加入响应的scripts脚本</p><p> {<br>  “name”:”my-module”,<br>  “scripts”:{<br>   “lint”:”eslint myfiles.js”<br>  },<br>  “devDependencies”:{<br>   “babel-eslint”:”…”,<br>   “eslint”:”…”,<br>  }<br> }</p><h3 id="Traceur转码器"><a href="#Traceur转码器" class="headerlink" title="Traceur转码器"></a>Traceur转码器</h3><p>Google公司的Traceur转码器，也可以将ES6代码转为ES5代码。</p><h4 id="直接插入网页"><a href="#直接插入网页" class="headerlink" title="直接插入网页"></a>直接插入网页</h4><p>Traceur允许将ES6代码直接插入网页，首先必须在网页头部加载Traceur库文件</p> <script src="https://google.github.io/traceur-compiler/bin/traceur.js"></script> <script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"></script> <script src="https://google.github.io/traceur-compiler/bin/bootstrap.js"></script> <script type="module"> import './Greeter.js'; </script><p>上面代码一共有4个script标签，第一个是加载Trcaeur的库文件，第二个和第三个是将这个库文件<br>用于浏览器环境，第四个则是加载用户脚本，这脚本里面可以使用ES6代码。<br>注意，第四个script标签的type属性的值是module,而不是text&#x2F;javascript。这是Traceur编译器识别<br>ES6代码的标志，编译器会自动将所有type&#x3D;module的代码编译为ES5，然后再交给浏览器执行<br>除了外部ES6脚本，也可以直接在网页中放置ES6代码</p><h4 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h4><p>Traceur也提供一个在线编辑器，可以在线将ES6代码转为ES5代码，可以直接作为ES5代码插入网页运行</p><h3 id="命令行转换"><a href="#命令行转换" class="headerlink" title="命令行转换"></a>命令行转换</h3><p>作为命令行工具使用时，Traceur是一个Node的模块，首先需要用npm安装</p><p> npm install -g traceur</p><p>安装成功后，就可以在命令行下使用Traceur了。</p><p>Traceur直接运行es6脚本文件，会在标准输出显示运算结果，以前的calc.js为例。</p><p> $ traceur calc.js<br> Calc constructor<br> 9</p><p>如果要将ES6脚本转为ES5保存，要采用下面的写法。</p><p> traceur –script cal.es6.js –out cale.es5.js</p><p>上面代码的–script选项表示指定输入文件，–out选项表示指定输出文件</p><p>为了防止编译不成功，可以加上–experimental选项</p><p> traceur –script calc.es6.js –out calc.es5.js –experimental</p><p>命令行下转换生成的文件，就可以直接放到浏览器中运行</p><h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><p>2013年3月，ES6草案封闭，不再接受新功能了，新的功能将被列入ES7</p>]]></content>
    
    
    <categories>
      
      <category>ES6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack</title>
    <link href="/2022/02/20/webpack-first/"/>
    <url>/2022/02/20/webpack-first/</url>
    
    <content type="html"><![CDATA[<h2 id="Webpack学习第一部分"><a href="#Webpack学习第一部分" class="headerlink" title="Webpack学习第一部分"></a>Webpack学习第一部分</h2><p>最近学习js的框架，选择了vue，然后接触到了vue中的单文件组件，官方推荐使用 Webpack + vue-loader构建这些单文件 Vue 组件，于是就开始了webpack的学习之旅。 因为原来没有用过任何的构建工具与模块化工具，所以本系列会比较基础。</p><h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>Webpack 是德国开发者 Tobias Koppers 开发的模块加载器兼打包工具，在webpack中，它能把各种资源，例如JS（含JSX）、coffee、样式（含less&#x2F;sass）、图片等都作为模块来使用和处理。因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl。 对应各种不同文件类型的资源, Webpack 有对应的模块 loader比如vue用的是vue-loader。</p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>因为webpack是一个基于node的项目，所以首先需要确保你的电脑里面已经安装了node.js，以及npm。在这里我使用的版本是：<br>node：v6.10.0 ，npm：3.10.10,若是版本问题，请更新到最新版。 若是有出现npm安装过慢的情况，可以使用nrm这个项目来进行npm源地址的切换。</p><p>首先我们直接进行全局的安装，运行如下命令：npm install webpack -g，可能需要一点时间。</p><p>安装成功后，在命令行输入webpack -h即可查看当前安装的版本信息。以及可以使用的指令。</p><p>当然，我们都应该将webapck安装到当前的项目依赖中，此时就可以使用项目的本这样就可以使用项目本地版本的 Webpack。</p><p>通过cd&#x2F;dir确保已经进入项目目录</p><p>确定已经有 package.json，没有就通过</p><p>npm init</p><p>创建，直接一路回车就好，后面再来详细说里面的内容。</p><p>安装 webpack 依赖</p><p>npm install webpack –save-dev</p><p>简单的写法：缩写形式</p><p>npm i webpack -D</p><p>save：模块名将被添加到dependencies，可以简化为参数-S。</p><p>–save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。</p><p> {<br>   “name”: “first-demo”,<br>   “version”: “1.0.0”,<br>   “description”: “this is my first-demo”,<br>   “main”: “index.js”,<br>   “scripts”: {<br>     “test”: “echo &quot;Error: no test specified&quot; &amp;&amp; exit 1”<br>   },<br>   “author”: “minchao”,<br>   “license”: “MIT”,<br>   “dependencies”: {},<br>   “devDependencies”: {<br>     “webpack”: “^1.12.14”<br>   }<br> }</p><p>既然环境都已经安装好了，那么我们就开始来用webpack进行我们的第一个打包运行程序吧！</p><h3 id="开始创建我们第一个打包程序"><a href="#开始创建我们第一个打包程序" class="headerlink" title="开始创建我们第一个打包程序"></a>开始创建我们第一个打包程序</h3><p>首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js,（这里你想用什么名字都可以，只需要在打包的时候读取文件为该名字就好，不过，到时候就知道这个名字的含义啦！）：</p> <!-- index.html --> <html> <head>     <meta charset="utf-8"> </head> <body>     <h1 id="app"></h1>     <script src="bundle.js"></script>     <!-- 注意这里引入的不是我们创建的文件，而是用webpack生成的文件 --> </body> </html><p>下面是js部分</p><p> &#x2F;<em><strong>entry.js</strong></em>&#x2F;<br> document.getElementById(‘app’).innerHTML&#x3D;”这是我第一个打包成功的程序”;</p><p>文件都已经创建成功了，那么就开始我们的打包吧！</p><p>执行这一句: webpack entry.js bundle.js</p><p>在浏览器中打开index.html，就能看到我们设置的文字了！：这是我第一个打包成功的程序</p><p>这么简单的功能直接在html中引入不就好了吗？确实是这样的，不过我们这才刚刚开始，不要急。</p><p>下面我们再来增加一个文件，名为first.js内容如下：</p><p> var h2&#x3D; document.createElement(“h2”)<br> h2.innerHTML&#x3D;”这就是我的第二个打包程序啦！”;<br> document.body.appendChild(h2);</p><p>更改 entry.js:</p><p> document.getElementById(‘app’).innerHTML&#x3D;”这是我第一个打包成功的程序”;</p><p>&#x2F;&#x2F;添加</p><p> require(“.&#x2F;first.js”);</p><p>再来进行一次重复的工作，再打包一次。webpack entry.js bundle.js，如果成功，打包过程会显示日志：</p><p> Hash: b1cfe7ff9d75ce235dc9<br> Version: webpack 1.12.14<br> Time: 54ms<br>     Asset     Size  Chunks             Chunk Names<br> bundle.js  1.82 kB       0  [emitted]  main<br>    [0] .&#x2F;entry.js 208 bytes {0} [built]<br>    [1] .&#x2F;first.js 145 bytes {0} [built]</p><p>总结：Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。</p><p>刷新浏览器，可以发现我们的刚刚的代码已经生效，又有了新的文字出现。</p><p>我们已经成功的把简单的事情变得复杂了，把我们的只有几行代码的两个文件first.js、entry.js使用webpack进行文件打包生成了bundle.js。</p><h3 id="Webpack-能做的就是这样，只能处理-JavaScript-模块"><a href="#Webpack-能做的就是这样，只能处理-JavaScript-模块" class="headerlink" title="Webpack 能做的就是这样，只能处理 JavaScript 模块"></a>Webpack 能做的就是这样，只能处理 JavaScript 模块</h3><p>当然它如果能做的仅仅是这样，那它也就不可能这么火了。所以它可以通过引入其他的loader，进而可以处理其它类型的文件。</p><h4 id="loader介绍"><a href="#loader介绍" class="headerlink" title="loader介绍"></a>loader介绍</h4><p>Loader可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过require来加载任何类型的模块或文件，比如VUE、JSX、SASS 或图片。</p><p>先来看看 loader 有哪些特性？</p><ol><li>Loader可以通过管道方式链式调用，每个loader可以把资源转换成任意格式并传递给下一个loader，但是最后一个loader必须返回JavaScript。</li><li>Loader可以同步或异步执行。</li><li>Loader运行在node.js环境中，所以可以做任何可能的事情。</li><li>Loader可以接受参数，以此来传递配置项给loader。</li><li>Loader可以通过文件扩展名（或正则表达式）绑定给不同类型的文件。</li><li>Loader可以通过npm发布和安装。除了通过package.json的main指定，通常的模块也可以导出一个loader来使用。</li><li>Loader可以访问配置。</li><li>插件可以让loader拥有更多特性。</li><li>Loader可以分发出附加的任意文件。</li></ol><h4 id="loader使用"><a href="#loader使用" class="headerlink" title="loader使用"></a>loader使用</h4><p>安装</p><p>根据上面说的loader的知识，就这样编译是肯定不行的，所以我们安装用来读取css文件的css-loader，再用 style-loader 把它插入到页面中。</p><p>在命令行中输入：npm install css-loader style-loader –save-dev</p><p>在package.json中，主要是devDependencies这个字段有了改变：</p><p> “devDependencies”: {<br>     “css-loader”: “^0.23.1”,<br>     “style-loader”: “^0.13.0”,<br>     “webpack”: “^1.12.2”<br> }</p><p>当然你可以用一个更加方便的方式进行安装，可以直接在package.json中，添加相应的依赖（如上面的代码），之后的命令行中运行npm intall，它会自动帮我们安装相应的依赖。</p><p>安装完毕。</p><p>加载 CSS 文件</p><p>在之前的first-demo中来添加一个css文件。style.css,在里面添加</p><p> body {<br>     background: red;<br> }</p><p>修改我们的entry.js，原文件不变，添加require(“!style!css!.&#x2F;style.css”);,用来引入我们的css文件。</p><p>我们继续编译:</p><p>webpack entry.js bundle.js</p><p>完成后，刷新我们的页面，背景颜色是不是已经变成了红色了呢？</p><p>扩展名自动绑定loader</p><p>这就是我们的loader的使用方式了。如果每次 require CSS 文件的时候都要写 loader 前缀!style!css!这样的东西，显然是一件很麻烦的事情。我们需要它可以根据模块类型（扩展名）来自动绑定需要的 loader。</p><p>来看看更简便的方式，将 entry.js 中的 require(“!style!css!.&#x2F;style.css”)修改为require(“.&#x2F;style.css”)，可以改变一个背景颜色让你更明显的查看到变化！然后执行：</p><p>webpack entry.js bundle.js –module-bind “css&#x3D;style!css”</p><p>没成功对吧! 因为!在命令行中具有特殊的含义，所以我们需要对它进行转义操作。再来试试：</p><p> webpack .&#x2F;entry.js bundle.js –module-bind “css&#x3D;style!css”</p><p>成功的话，应该能再次看到背景的变化。</p><p>虽然这样可以将多个css文件进行编译打包，但是总感觉很是繁琐，我不想每次都运行那么一长串的命令怎么办？</p><p>在上面我们已经尝试过了两种对于loader的使用方式，无论是在require的时候编写我们loader的前缀，还是在我们的命令行中进根据扩展名来自动绑定我们的loader，显然都不够自动化，在需要编译的语言继续增加的情况下，显然会是一个噩梦。 所以webapck实际上为我们提供了一个简单的方法，下面就一起来看看。</p><h3 id="了解webpack配置"><a href="#了解webpack配置" class="headerlink" title="了解webpack配置"></a>了解webpack配置</h3><p>Webpack在执行的时候，除了在命令行传入参数，还可以通过指定的配置文件来执行。默认情况下，会搜索当前目录的webpack.config.js文件，这个文件是一个 node.js 模块，返回一个 json 格式的配置信息对象，或者通过 –config 选项来指定配置文件。</p><p>所以现在我们就来新建一个webpack.config.js，在里面填写进下面的内容：</p><p> var Webpack &#x3D; require(“webpack”);<br> module.exports &#x3D; {<br>     entry: [“.&#x2F;entry.js”],<br>     output: {<br>         path: __dirname,<br>         filename: “bundle.js”<br>     },<br>     module: {<br>         loaders: [{<br>             test: &#x2F;.css$&#x2F;,<br>             loader: “style!css”<br>         }]<br>     }<br> }</p><p>我们现在仅仅需要运行:webpack，如果你的配置没有问题的话，可以在命令行中看到正确的输出，因为这个命令会自动在当前目录中查找webpack.config.js的配置文件，并按照里面定义的规则来进行执行。</p><p>修改css文件感受一下。</p><p>上面我们仅仅是使用了这个配置文件，我们肯定想在实际的工作环境中，自我对于项目进行针对性的配置。下面我们就先来简单的了解一下里面参数的意义：</p><ul><li><p>entry：指入口文件的配置项，它是一个数组的原因是webpack允许多个入口点。 当然如果你只有一个入口的话，也可以直接使用双引号”.&#x2F;entry.js”</p></li><li><p>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称</p></li><li><p>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。</p></li></ul><p>在这里仅仅能做一些很简单的介绍，如果想要真正做到在项目中的实际应用，还需要大量的练习与尝试。在等真正用到了再记录下来。</p><h3 id="了解webpack插件"><a href="#了解webpack插件" class="headerlink" title="了解webpack插件"></a>了解webpack插件</h3><p>下面就来看看webpack中的插件：</p><p>插件可以完成更多loader不能完成的功能。插件的使用一般是在webpack.config.js中的plugins 选项中指定。</p><p>Webpack本身内置了一些常用的插件，还可以通过npm安装第三方插件。</p><p>接下来，我们从一个最简单的，用来给输出的文件头部添加注释信息BannerPlugin的内置插件来实践插件的配置和运行。</p><p>修改webpack.config.js，添加 plugins配置项：</p><p> var Webpack &#x3D; require(“webpack”);&#x2F;&#x2F;必须引入<br> module:{<br> },<br> plugins: [<br>     new webpack.BannerPlugin(“这里是打包文件头部注释！”)&#x2F;&#x2F;注意这是一个数组..<br> ]<br>运行正确的话应该是这样的，打开bundle.js，会发现在文件头部已经有了我们添加的注释：</p><p> &#x2F;<em>! 这里是打包文件头部注释</em>&#x2F;<br> &#x2F;<strong><strong><strong>&#x2F; (function(modules) { &#x2F;&#x2F; webpackBootstrap<br> &#x2F;</strong></strong></strong>&#x2F;    &#x2F;&#x2F; The module cache<br> &#x2F;******&#x2F;    var installedModules &#x3D; {};<br>         &#x2F;***  省略 ***&#x2F;<br>         })<br>最简单的插件使用方式就是这样的了</p><p><a href="https://github.com/guowenfh/vue-webpack/tree/master/webpack">文章出处</a></p>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery插件封装规则</title>
    <link href="/2021/12/13/jquery-plus/"/>
    <url>/2021/12/13/jquery-plus/</url>
    
    <content type="html"><![CDATA[<h1 id="jQuery插件封装"><a href="#jQuery插件封装" class="headerlink" title="jQuery插件封装"></a>jQuery插件封装</h1><p>web开发中，jquery几乎是必不可少的，jQuery用过的都知道，今天我们来讨论jquery的插件机制，jquery有着成千上万的第三方插件。有时，我们写好了一个独立的功能，也想将其与jquery结合起来，可以用jquery链式调用，这就是扩展jquery，写成插件形式了。</p><h2 id="jQuery封装插件知识储备"><a href="#jQuery封装插件知识储备" class="headerlink" title="jQuery封装插件知识储备"></a>jQuery封装插件知识储备</h2><h3 id="jQuery-extend-和jQuery-fn-extend"><a href="#jQuery-extend-和jQuery-fn-extend" class="headerlink" title="jQuery.extend()和jQuery.fn.extend()"></a>jQuery.extend()和jQuery.fn.extend()</h3><p>为了方便用户创建插件，jquery提供了jQuery.extend()和jQuery.fn.extend()方法。</p><p>用JQuery写插件时，最核心的方法有如下两个：</p><p><strong>$.extend(object) 可以理解为JQuery 添加一个静态方法。</strong></p><p><strong>$.fn.extend(object) 可以理解为JQuery实例添加一个方法。</strong></p><ol><li>jQuery.extend(object)方法重载</li></ol><p> 这有个扩展jquery的例子</p><p>  &#x2F;&#x2F;在jQuery上内置静态方法，调用只需$.方法名即可<br>  jQuery.extend({<br>   “minValue”:function(a,b){<br>    return a&lt;b?a:b;<br>   },<br>   “maxValue”:function(a,b){<br>    return a&gt;b?a:b;<br>   }<br>  });</p><p>  var i &#x3D;100,j&#x3D;10;</p><p>  console.log($.minValue(i,j));&#x2F;&#x2F;10<br>  console.log($.maxValue(i,j));&#x2F;&#x2F;100</p><p> 重载版本:jQuery.extend([deep],target,object1,[objectN])<br> 用一个或多个其他对象来扩展一个对象，返回被扩展的对象</p><p>  var settings &#x3D; { validate: false, limit: 5, name: “foo” };<br>  var options &#x3D; { validate: true, name: “bar” };<br>  console.log(jQuery.extend(settings, options));<br>  &#x2F;&#x2F;Object{ validate: true, limit: 5, name: “bar”}</p><p> 这个常用来使用自定义的options来覆盖插件的默认值</p><ol start="2"><li>jQuery.fn.extend()方法</li></ol><p>  &#x2F;&#x2F;sample:扩展jquery对象的方法，bold()用于加粗字体。<br>        (function ($) {<br>            $.fn.extend({<br>                “bold”: function () {<br>                    &#x2F;&#x2F;&#x2F;<summary><br>                    &#x2F;&#x2F;&#x2F; 加粗字体<br>                    &#x2F;&#x2F;&#x2F;</summary><br>                    return this.css({ fontWeight: “bold” });<br>                }<br>            });<br>        })(jQuery);</p><p> 调用方式</p><p>  $(function(){<br>   $(“p”).bold();<br>  });</p><h3 id="jQuery-function-与-function-jQuery-的区别"><a href="#jQuery-function-与-function-jQuery-的区别" class="headerlink" title="jQuery(function () { }); 与  (function ($) { })(jQuery);的区别"></a>jQuery(function () { }); 与  (function ($) { })(jQuery);的区别</h3><p> jQuery(function () { });<br> &#x2F;&#x2F;相当于<br> $(document).ready(function () { });<br> &#x2F;** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** *&#x2F;<br> (function ($) { })(jQuery);<br> &#x2F;&#x2F;相当于<br> var fn &#x3D; function ($) { };<br> fn(jQuery);</p><p>jQuery(function () { });是某个DOM元素加载完毕后执行方法里的代码。</p><p>(function ($) { })(jQuery); 定义了一个匿名函数，其中jQuery代表这个匿名函数的实参。通常用在JQuery插件开发中，起到了定义插件的私有域的作用。</p><h2 id="自执行的匿名函数-x2F-闭包"><a href="#自执行的匿名函数-x2F-闭包" class="headerlink" title="自执行的匿名函数&#x2F;闭包"></a>自执行的匿名函数&#x2F;闭包</h2><ul><li>什么是自执行的匿名函数</li></ul><p> 形如: (function(){&#x2F;&#x2F;code})()的函数</p><ul><li><p>error——为什么(function {&#x2F;&#x2F; code})();可以被执行, 而function {&#x2F;&#x2F; code}();却会报错?</p><p> (1). 首先, 要清楚两者的区别:<br> (function {&#x2F;&#x2F;…})是表达式, function {&#x2F;&#x2F;…}是函数声明.<br>(2). 其次, js”预编译”的特点:<br> js在”预编译”阶段, 会解释函数声明, 但却会忽略表达式.</p><p> (3). 当js执行到function() {&#x2F;&#x2F;code}();时, 由于function() {&#x2F;&#x2F;code}在”预编译”阶段已经被解释过, js会跳过function(){&#x2F;&#x2F;code}, 试图去执行(); 故会报错;</p><p>  当js执行到(function {&#x2F;&#x2F; code})();时, 由于(function {&#x2F;&#x2F; code})是表达式, js会去对它求解得到返回值, 由于返回值是一 个函数, 故而遇到();时, 便会被执行.</p></li></ul><h2 id="一步一步封装JQuery插件"><a href="#一步一步封装JQuery插件" class="headerlink" title="一步一步封装JQuery插件"></a>一步一步封装JQuery插件</h2><p>尝试写一个高亮的插件:</p><ol><li>定一个闭包区间，防止插件”污染”</li></ol><p>  &#x2F;&#x2F;闭包限定命名空间<br>  (function($){</p><p>  })(window.jQuery);<br>2. jQuery.fn.extend(object)扩展jquery方法，制作插件</p><p>  &#x2F;&#x2F;闭包限定命名空间<br>  (function($){<br>   $.fn.extend({<br>    “heightLight”:function(options){<br>     &#x2F;&#x2F;do something<br>    }<br>   });<br>  })(window.jQuery)</p><ol start="3"><li>给插件默认参数，实现 插件的功能</li></ol><p>  &#x2F;&#x2F;闭包限定命名空间<br>  (function ($){<br>   $.fn.extend({<br>    “highLight”:function(options){<br>     var opts &#x3D; $.extend({},defaluts,options);&#x2F;&#x2F;使用jQuery.extend覆盖插件默认参数<br>     this.each(function(){&#x2F;&#x2F;这里的this就是Jquery对象<br>      &#x2F;&#x2F;遍历所有的要高亮的dom，当调用highLight()插件的是一个集合的时候<br>      var $this &#x3D; $(this);&#x2F;&#x2F;获取当前dom的jQuery对象，这里的this是当前循环的dom<br>      &#x2F;&#x2F;根据参数来设置dom的样式<br>      $this.css({<br>       backgroundColor:opts.background,<br>       color:opts.foreground<br>      });<br>     });<br>    }<br>   });</p><pre><code class="hljs">//默认参数  var defaluts = &#123;      foreground: &#39;red&#39;,      background: &#39;yellow&#39;  &#125;; </code></pre><p>  })(window.jQuery)</p><p> 到这一步，高亮插件基本功能已经具备了，调用代码如下：</p><p>  $(function(){<br>   $(“p”).heightLight();&#x2F;&#x2F;调用自定义的高亮插件<br>  })</p><p> 这里只能直接调用，不能链式调用。但是jQuery是可以链式调用的，就是可以在一个Jquery上调用多个方法，如:</p><p>  $(“#id”).css({marginTop:’100px’}).addAttr(“title”,”测试”);</p><p> 但是，我们上面的插件，就不能这样链式调用。比如:</p><p>  $(“p”).highLight().css({marginTop:’100px’});<br>  &#x2F;&#x2F;将会报找不到css方法，原因是我们在完成功能后，没有将jQuery没有返回出来。</p><p> 接下来，return jQuery对象，让我们的插件也支持链式调用。(其实很简单，就是在执行完我们插件代码的时候将jQuery对象return出来。和上面代码没什么区别)</p><p>  &#x2F;&#x2F;闭包限定命名空间<br>  (function($){<br>   $.fn.extend({<br>    “highLight”:function(options){<br>     &#x2F;&#x2F;使用jQuery.extend覆盖插件默认参数<br>     var opts &#x3D; $.extend({},defaluts,options);<br>     &#x2F;&#x2F;遍历高亮的doom，当调用highLight()插件是一个集合的时候<br>     return this.each(function(){<br>      &#x2F;&#x2F;获取当前的dom的jquery对象，这里this是当前循环的dom<br>      var $this &#x3D; $(this);<br>      &#x2F;&#x2F;根据参数来设定dom的样式<br>      $this.css({<br>       backgroundColor:opts.background,<br>       color:opts.foreground<br>      });<br>     });<br>    }<br>   });<br>   &#x2F;&#x2F;默认参数<br>   var defaults &#x3D; {<br>    foreground:”red”,<br>    background:”yellow”<br>   };</p><p>  })(window.jQuery);</p><p> 这样就实现了链式调用，加上return 返回jQuery对象就可以实现链式调用。</p><ol start="4"><li>暴露公共方法，给别人来扩展你的插件(如果有需求的话)</li></ol><p> 比如高亮插件有一个format方法来格式化高亮文本，否则我们可以写成公共，暴露给插件使用者，不同的使用者会根据自己需求来重写format方法，从而使高亮文本呈现不同的格式。</p><p>  &#x2F;&#x2F;公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。<br>     $.fn.highLight.format &#x3D; function (str) {<br>         return “<strong>“ + str + “</strong>“;<br>     }<br>5. 插件的私有方法</p><p> 有些时候，我们插件需要一些私有方法，不能被外界访问。例如 我们插件里面需要有个方法来检测用户调用插件时传入的参数是否符合规范。</p><ol start="6"><li>其他的一些设置，如：为你的插件加入元数据插件的支持使其变得更加强大。</li></ol><p>完成的插件，包含公共方法和私有方法</p><p> &#x2F;&#x2F;闭包限定命名空间<br> (function ($) {<br>     $.fn.extend({<br>         “highLight”: function (options) {<br>             &#x2F;&#x2F;检测用户传进来的参数是否合法<br>             if (!isValid(options))<br>                 return this;<br>             var opts &#x3D; $.extend({}, defaluts, options); &#x2F;&#x2F;使用jQuery.extend 覆盖插件默认参数<br>             return this.each(function () {  &#x2F;&#x2F;这里的this 就是 jQuery对象。这里return 为了支持链式调用<br>                 &#x2F;&#x2F;遍历所有的要高亮的dom,当调用 highLight()插件的是一个集合的时候。<br>                 var $this &#x3D; $(this); &#x2F;&#x2F;获取当前dom 的 jQuery对象，这里的this是当前循环的dom<br>                 &#x2F;&#x2F;根据参数来设置 dom的样式<br>                 $this.css({<br>                     backgroundColor: opts.background,<br>                     color: opts.foreground<br>                 });<br>                 &#x2F;&#x2F;格式化高亮文本<br>                 var markup &#x3D; $this.html();<br>                 markup &#x3D; $.fn.highLight.format(markup);<br>                 $this.html(markup);<br>             });</p><pre><code class="hljs">     &#125; &#125;); //默认参数 var defaluts = &#123;     foreground: &#39;red&#39;,     background: &#39;yellow&#39; &#125;; //公共的格式化 方法. 默认是加粗，用户可以通过覆盖该方法达到不同的格式化效果。 $.fn.highLight.format = function (str) &#123;     return &quot;&lt;strong&gt;&quot; + str + &quot;&lt;/strong&gt;&quot;; &#125; //私有方法，检测参数是否合法 function isValid(options) &#123;     return !options || (options &amp;&amp; typeof options === &quot;object&quot;) ? true : false; &#125;</code></pre><p> })(window.jQuery);</p><p>调用:</p><pre><code class="hljs">//调用者覆盖 插件暴露的共公方法$.fn.highLight.format = function (txt) &#123;     return &quot;&lt;em&gt;&quot; + txt + &quot;&lt;/em&gt;&quot;&#125;$(function ()&#123;    $(&quot;p&quot;).highLight(&#123; foreground: &#39;orange&#39;, background: &#39;#ccc&#39; &#125;); //调用自定义 高亮插件&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈颜色的分类和含义以及网页结构</title>
    <link href="/2021/05/18/color-and-websiteFlows/"/>
    <url>/2021/05/18/color-and-websiteFlows/</url>
    
    <content type="html"><![CDATA[<h2 id="颜色的分类和含义"><a href="#颜色的分类和含义" class="headerlink" title="颜色的分类和含义"></a>颜色的分类和含义</h2><h3 id="暖色"><a href="#暖色" class="headerlink" title="暖色"></a>暖色</h3><p>暖色可以创造温暖的感觉，暖色通常会让人联想起太阳、火焰和爱情。红色是血的颜色，感觉是温暖的。橙色和黄色会给人夏天的感觉。给图像添加一个橙色的滤镜，图像看起来就会有温馨快乐的感觉。</p><h3 id="冷色"><a href="#冷色" class="headerlink" title="冷色"></a>冷色</h3><p>冷色也有其独特的含义，通常会让人联想起凉爽的气候、冬季、死亡、悲伤、冰、夜晚和水这些事物。冷色可以给人平静、安宁、新人、干净的感觉。紫色与尊贵经常联系在一起，看起来十分内敛。</p><h3 id="红色"><a href="#红色" class="headerlink" title="红色"></a>红色</h3><p>红色是代表爱情和激情的颜色。 红色也表示危险，所以很多表示停止的标识牌都是红色的，红色是很强势的颜色，当它和其他颜色相遇时，比如搭配黑色，可以创建非常强势的感觉。 红色可以搭配一些严肃的语气和强硬的命令。</p><h3 id="橙色"><a href="#橙色" class="headerlink" title="橙色"></a>橙色</h3><p>橙色代表了温暖，但是并不像红色那样咄咄逼人。橙色能够创建一个有趣的氛围，因为它充满了活力，而且橙色创造出的活跃气氛并没有危险的感觉。橙色可以与一些健康产品搭上关系，比如维生素C，毕竟橙子里也有很多维生素C。</p><h3 id="黄色"><a href="#黄色" class="headerlink" title="黄色"></a>黄色</h3><p>提到黄色，经常可以联想到太阳和温暖。使用橙色的时候，可以创造出一种夏天的好玩的感觉，黄色则带给人口渴的感觉，所以经常可以在卖饮料的地方看到黄色的装饰。黄色也可以和懦弱与恐惧联系起来,当黄色与黑色搭配在一起时，十分吸引人的注意力,一个绝佳的例子就是出租车都采用这种配色</p><h3 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h3><p>在西方国家，绿色是钱的颜色，这与他们的文化和财富有关。因为大多数植物都是绿色的。绿色也代表着经济增长和健康。绿色经常用作一些保健食品的LOGO，因为看起来就十分贴近自然。绿色还意味着利润和收益。如果搭配上蓝色，通常会给人健康、清洁、生活和自然的感觉。</p><h3 id="蓝色"><a href="#蓝色" class="headerlink" title="蓝色"></a>蓝色</h3><p>蓝色是一个神奇的颜色，因为不同明度的蓝色会给人不同的感受、想法和情绪。深蓝色可以给人一种悲伤的感觉，让人联想起伤心时怎么听都不够的蓝调音乐。浅蓝色则通常会让人联想起天空和水，给人以提神、自由和平静的感觉。蓝天永远都是平静的，水流可以冲走泥土，清洗伤口，所以蓝色也代表着新鲜和更新。蓝色给人冷静的感觉，会帮助人放松下来。</p><h3 id="紫色"><a href="#紫色" class="headerlink" title="紫色"></a>紫色</h3><p>紫色总是让人不禁想起皇室成员的长袍。紫色可以更多地与浪漫、亲密、柔软舒适的质感产生联系。紫色给人一种奢华的感觉，也有一种神秘感。下面这个葡萄酒网站就是极好的例子。</p><h3 id="白色"><a href="#白色" class="headerlink" title="白色"></a>白色</h3><p>白色通常与医院联系在一起,宗教绘画有时候也是没有色彩的，白色也代表着圣洁。白色通常给人干净的感觉，比如白色的床单和衣服都让人感觉很干净。也可以代表棉花和柔软的云朵。心理健康相关的事物也可以选用白色，白色也同样适用于卫生、清洁相关的设计。</p><h3 id="黑色"><a href="#黑色" class="headerlink" title="黑色"></a>黑色</h3><p>黑色通常与死亡有关，尤其是在美国。它可以代表腐坏，因为很多食物腐坏变质以后就是黑色的。黑色也代表邪恶，因为是白色的对立颜色，而白色通常代表着纯洁美好善良。黑暗和未知也会给人焦虑的感觉。很多图像中，黑色表达了抑郁、绝望和孤独。虽然黑色有很多负面的含义，但是黑色也是一个万能色彩，当黑色遇上其他颜色的时候会产生其他的意义。比如当黑色邂逅金黄色，就可以给人一种奢华、高档的感觉；当黑色偶遇银灰色，则会给人一种成熟稳重的感觉。</p><h2 id="颜色总结"><a href="#颜色总结" class="headerlink" title="颜色总结"></a>颜色总结</h2><p>作为一名前端工程师，了解色彩是一件必不可少的事儿，在设计的时候应该慎重地考虑和选用颜色。通过不同的颜色可以创造出不同感觉的图像。合适的组合可以获得关注，通过视觉传达设计师所想，进一步拉近设计师与观众的距离，让图像更具力量。如果之前并不考虑用色，现在开始，应该培养对于色彩的感觉，相信客户会看到不一样的你，你的设计作品将会通过颜色建立联想，更好地传达信息。</p><h2 id="网站是一个个页面构成的。七大经典网页布局类型"><a href="#网站是一个个页面构成的。七大经典网页布局类型" class="headerlink" title="网站是一个个页面构成的。七大经典网页布局类型"></a>网站是一个个页面构成的。七大经典网页布局类型</h2><h3 id="1、国字型"><a href="#1、国字型" class="headerlink" title="1、国字型"></a>1、国字型</h3><p>是大型网站所喜欢的类型，即最上面是网站的标题以及横幅广告，接下来就是网站的主要内容。左右分列一些小条内容，中间是主要部分，与左右一起罗列到底。最下面是网站的一些基本信息、联系方式、版权声明等。这种结构差不多是最多见的一种结构类型。</p><h3 id="2、拐角型"><a href="#2、拐角型" class="headerlink" title="2、拐角型"></a>2、拐角型</h3><p>这种结构与国字型只是形式上的区别，其实是很近的，上面是标题以及广告横幅，接下来的左侧是一窄列连接等，右列是很宽的正文，下面也是一些网站的辅助信息。在这种类型中，一种很常见的类型是最上面是标题以及广告，左侧是导航链接</p><h3 id="3、标题正文型"><a href="#3、标题正文型" class="headerlink" title="3、标题正文型"></a>3、标题正文型</h3><p>这种类型即最上面是标题或类似的一些东西，下面是正文，比如一些文章或注册页面等就是这种类</p><h3 id="4、左右框架型"><a href="#4、左右框架型" class="headerlink" title="4、左右框架型"></a>4、左右框架型</h3><p>这是一种左右为分别两页的框架结构，一般左面是导航链接，有时做上面会有一些小的标题或标志。右面是正文。我们见到的大部分的大型论坛都是这种结构的，有一些网站也喜欢采用。这种类型结构非常清晰，一目了然。</p><h3 id="5、上下框架型"><a href="#5、上下框架型" class="headerlink" title="5、上下框架型"></a>5、上下框架型</h3><p>与上面类似，区别仅仅在于是一种上下分为两页的框架。</p><h3 id="6、综合框架型"><a href="#6、综合框架型" class="headerlink" title="6、综合框架型"></a>6、综合框架型</h3><p>上页两种结构的结合，相对复杂的一种结构框架，较为常见的是类似“拐角型”结构。</p><h3 id="7、封面型"><a href="#7、封面型" class="headerlink" title="7、封面型"></a>7、封面型</h3><p>这种类型基本上是出现在一些网站的首页，大部分为一些精彩的平面设计结合一些小的动画，放上几个简单的链接或者仅是一个“进入”的链接甚至直接在首页的图片上做链接而没有任何提示。这种类型大部分出现在企业网站和个人主页，如果说处理的好，会给人赏心悦目的感觉</p>]]></content>
    
    
    <categories>
      
      <category>UI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jquery类库</title>
    <link href="/2021/04/16/javascript-jquery/"/>
    <url>/2021/04/16/javascript-jquery/</url>
    
    <content type="html"><![CDATA[<h1 id="jquery类库"><a href="#jquery类库" class="headerlink" title="jquery类库"></a>jquery类库</h1><p>JavaScript的核心API设计得很简单，但由于浏览器之间的严重不兼容性，导致客户端的API过于复杂。IE9的到来缓和了这种不兼容性导致的糟糕境况，然而使用JavaScript框架或工具类库，能简化通用操作，能隐藏浏览器之间的差异，这让很多程序员在开发Web应用时变得更简单。</p><p>jQuery类库如此广泛地使用，作为Web开发者，我们必须熟悉它：即便没有在自己的代码中使用它，也很有可能在他人写的代码中遇见过。</p><p>jQuery足够小巧和稳定，本书就可以把它讲述清楚。</p><p>下面就介绍一下jQuery。</p><h2 id="jQuery的特性"><a href="#jQuery的特性" class="headerlink" title="jQuery的特性"></a>jQuery的特性</h2><ul><li><p>丰富强大的语法(CSS选择器)，用来查询文档元素</p></li><li><p>高效的查询方法，用来找到与CSS选择器匹配的文档元素集</p></li><li><p>一套有用的方法，用来操作选中的元素</p></li><li><p>强大的函数式编程技巧，用来批量操作元素集，而不是每次只操作单个</p></li><li><p>简洁的语言用法(链式调用)，用来表示一系列顺序操作</p></li></ul><h2 id="jQuery可以用来实现简单查询并操作dom"><a href="#jQuery可以用来实现简单查询并操作dom" class="headerlink" title="jQuery可以用来实现简单查询并操作dom"></a>jQuery可以用来实现简单查询并操作dom</h2><ul><li>设置HTML属性、CSS样式和类、HTML表单的值和元素内容、位置高宽，以及数据</li><li>改变文档结构：对元素进行插入、替换、包装和删除操作</li><li>使用jQurey的跨浏览器事件模型</li><li>使用jQuery来实现动画视觉效果</li><li>jQuery的Ajax工具，如何用脚本来发起HTTP请求</li><li>jQuery的工具函数</li><li>jQuery选择器的所有语法，以及使用jQuery的高级选择方法</li><li>如何使用和编写插件来对jQuery进行扩展</li><li>jQuery UI 类库</li></ul><h2 id="jQuery基础"><a href="#jQuery基础" class="headerlink" title="jQuery基础"></a>jQuery基础</h2><p>jQuery类库定义了一个全局函数:jQuery()。该函数使用频繁，因此在类库中还给它定义了一个快捷别名:$。这是jQuery在全局命名空间中定义的唯一两个变量。</p><h3 id="jQuey-函数"><a href="#jQuey-函数" class="headerlink" title="jQuey()函数"></a>jQuey()函数</h3><p>在jQuery类库中，最重要的方法是jQuery()方法(也就是$())。它的功能很强大，有4种不同的调用方式。</p><ol><li><p>第一种是最常调用方式是传递CSS选择器(字符串)给$()方法</p></li><li><p>第二种调用方式是传递一个Element、Document或Window对象给$()方法。例如:$(document)或$(this)</p></li><li><p>第三种调用方式是传递HTML文本字符串给$()方法。在这种调用方式下，jQuery会根据传入的文本创建好HTML元素并封装为Jquery对象返回。</p></li></ol><p> 在这种情况下，$()也可接收第二参数，可以传递Document对象来指定与所创建元素相关联的文档。例如：</p><p>  var img &#x3D; $(“<img/>“,  &#x2F;&#x2F;新建一个<img>元素<br>     {<br>      src:url, &#x2F;&#x2F;具有HTML属性<br>      css:{},  &#x2F;&#x2F; CSS样式<br>      click:handleClick &#x2F;&#x2F;事件程序有关<br>     })</p><p> 第二个参数对象的属性名是”css”、”html”、”text”、”width”、”height”、”offset”、”val”或”data”或者属性名是jQuery事件处理程序注册方法名时，jQuery将调用新创建元素上的同名方法，并传入属性值。（css()、html()、text()等）</p><ol start="4"><li>第四种调用方式时传入一个函数给$()方法。此时，当文档加载完毕且DOM可操控时，传入的函数将被调用。</li></ol><p> 例如：</p><p>  jQuery(function(){ &#x2F;&#x2F;文档加载完毕时调用<br>   &#x2F;&#x2F;所有jQuery代码放在这里<br>  });</p><p>有时还可以看见$(f)的老式和完整写法：$(document).ready(f)</p><h2 id="jQuery术语"><a href="#jQuery术语" class="headerlink" title="jQuery术语"></a>jQuery术语</h2><ol><li>“jQuery函数”</li></ol><p> jQuery函数时jQuery或$()的值。该函数可以用来创建jQuery对象，用来注册DOM就绪时需要调用的处理程序，还用做jQuery命名空间。</p><ol start="2"><li>“jQuery对象”</li></ol><p> jQuery对象时由jQuery函数返回的对象。一个jQuery对象表示一组文档元素，也叫”jQuery结果”、”jQuery集”或”包装集”</p><ol start="3"><li>“jQuery方法”</li></ol><p> jQuery方法是由jQuery函数返回的jQuery对象的方法。jQuery类库最重要的部分就是它定义的这些强大的方法。</p><p>注意：jQuery函数和jQuery方法有时很难区分，因为有部分函数和方法的名称是一样的。注意下面这两行代码的差异:</p><p> &#x2F;&#x2F;jQuery的each()函数用来<br> &#x2F;&#x2F;对数组a种的每一个元素都调用一次函数f<br> $.each(a,f)；</p><p> &#x2F;&#x2F;调用jQuery()函数获取表示文档种所有<a>元素的jQuery对象<br> &#x2F;&#x2F;然后调用该jQuery对象的each()方法<br> &#x2F;&#x2F;对选中的每一个元素调用一次函数f<br> $(“a”).each(f);</p><p>jQuery官方文档使用类似$.each的命令来表示jQuery函数，用类似.each(带点号但不带美元符号)的命名表示jQuery方法。</p><h2 id="jQuery的getter和setter方法"><a href="#jQuery的getter和setter方法" class="headerlink" title="jQuery的getter和setter方法"></a>jQuery的getter和setter方法</h2><p>jQuery对象上最简单、最常见的操作是获取(get)或设置(set)HTML属性、CSS样式、元素内容和位置高宽的值。</p><ul><li>jQuery使用同一个方法既当getter用游荡setter用，</li><li>用做setter时，这些方法会给jQuery对象种的每一个元素设置值，然后返回该jQuery对象以方便链式调用</li><li>用getter时，这些方法只会查询元素集中的第一个元素，返回单个值</li><li>用作setter时，这些方法会接受对象参数。</li><li>用所setter时，这些方法经常接受函数参数</li></ul><h3 id="获取和设置HTML属性"><a href="#获取和设置HTML属性" class="headerlink" title="获取和设置HTML属性"></a>获取和设置HTML属性</h3><p>attr()方法是jQuery中用于HTML属性的getter&#x2F;setter，它符合上面描述的概要理解中的每一条。</p><p> $(img).attr(“src”,”<a href="http://baidu.com/">http://baidu.com</a>“);</p><p> $().removeAttr();&#x2F;&#x2F;删除属性</p><h3 id="获取和设置CSS属性"><a href="#获取和设置CSS属性" class="headerlink" title="获取和设置CSS属性"></a>获取和设置CSS属性</h3><p>css()方法和attr()方法类似</p><p> $(“h1”).css(“font-weight”);&#x2F;&#x2F;获取h1的字体重量<br> $(“h1”).css(“font-weight”,”bolder”);&#x2F;&#x2F;获取h1的字体重量</p><h3 id="获取和设置元素内容"><a href="#获取和设置元素内容" class="headerlink" title="获取和设置元素内容"></a>获取和设置元素内容</h3><p>$(..).html()、$(..).text()、$(..).val()</p><h3 id="获取和设置元素的位置高度"><a href="#获取和设置元素的位置高度" class="headerlink" title="获取和设置元素的位置高度"></a>获取和设置元素的位置高度</h3><p> $(“div”).offset()&#x2F;&#x2F;获取当前位置<br> var position &#x3D;  $(“div”).offset().top +100;<br> $(“div”).offset(position)&#x2F;&#x2F;设置新的位置<br> $(“div”).width()&#x2F;&#x2F;获取元素的宽度<br> $(“div”).innerWidth()<br> $(“div”).outerWidth()<br> $(“div”).borderWidth()<br> $(“div”).marginWidth()</p><h3 id="获取和设置元素数据"><a href="#获取和设置元素数据" class="headerlink" title="获取和设置元素数据"></a>获取和设置元素数据</h3><p>jQuery定义了一个名为data()的getter&#x2F;setter方法，可用来设置或获取与文档元素Document或Window对象相关联的数据。</p><p> $(“div”).data(“x”,1);&#x2F;&#x2F;设置一些数据<br> $(“div.nodata”).removeData(“x”);&#x2F;&#x2F;删除一些数据<br> var x &#x3D; $(“div”).data(“x”)&#x2F;&#x2F;获取一些数据</p><h2 id="修改文档结构"><a href="#修改文档结构" class="headerlink" title="修改文档结构"></a>修改文档结构</h2><h3 id="插入和替换元素"><a href="#插入和替换元素" class="headerlink" title="插入和替换元素"></a>插入和替换元素</h3><p>在目标元素的结尾插入内容   append()   appendTo()<br>在目标元素的起始处插入内容 preped()   prepredTo()<br>在目标元素的后面插入内容   after()   insertAfter()<br>在目标元素的前面插入内容 before()   insertBefore()<br>将目标元素替换为内容   replaceWith()  replaceAll()</p><h3 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h3><p>clone()创建并返回每一个选中元素(包含元素所有的子孙)的一个副本</p><p>但不会复制事件处理程序和元素关联的其他数据</p><h3 id="包装元素"><a href="#包装元素" class="headerlink" title="包装元素"></a>包装元素</h3><p>wrap()包装每一个选中的元素</p><p>wrapInner()包装每一个选中元素的内容</p><p>wrapAll()则将选中元素作为一组来包装</p><p>这三个方法，通常传入一个新创建的包装元素或用来创新包装元素的HTML字符串。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>empty()会删除每个选中元素的所有子节点，但不会修改元素自身。</p><p>remove()方法会从文档中移除选中的元素（以及所有元素的内容）。</p><p>通常不调用参数，此时remove()会从文档中删除所有元素。</p><p>如果接受一个参数，该参数会被当作选择器，jquery对象中只有匹配到该选择器的元素才会被移除。</p><p>remove()方法会移除所有事件监听处理程序以及可能绑定到被移除元素上的其他数据。</p><p>detach()方法和remove()方法类似，但不会移除事件处理程序和数据。</p><p>unwrap()方法可以用来实现元素的移除，其方式是wrap()或wrapAll()方法的反操作:移除每一个选中元素的父元素，不影响选中元素及其兄弟节点。</p><h2 id="jQuery处理事件程序"><a href="#jQuery处理事件程序" class="headerlink" title="jQuery处理事件程序"></a>jQuery处理事件程序</h2><p>处理事件有时是一个难点IE(IE9以下)实现了一个与其所有其他浏览器不同的事件API。jQuey API具有简单的形式，比标准或IE的事件API更容易使用。jQuery API还有更复杂、功能更齐全的形式，比标准API更强大。</p><h3 id="事件处理程序的简单注册"><a href="#事件处理程序的简单注册" class="headerlink" title="事件处理程序的简单注册"></a>事件处理程序的简单注册</h3><p>jQuery定义了简单的事件注册方法，可用于常用和普适的每一个浏览器事件。</p><p>比如，给单机事件注册一个事件处理程序，只要调用click()方法：</p><p> &#x2F;&#x2F;单击任意<p>时，使其背景变成灰色<br> $(“p”).click(function(){<br>  $(this).css(“background-color”,”gray”);<br> })</p><p>下面时jQuery定义的简单事件处理程序注册的方法:</p><p> &#x2F;<em>焦点事件</em>&#x2F;<br> blur()&#x2F;&#x2F;失去焦点  focusin()&#x2F;&#x2F;获取焦点 focus()&#x2F;&#x2F;元素获得焦点时 focusout()&#x2F;&#x2F;失去焦点</p><p> &#x2F;<em>鼠标事件</em>&#x2F;<br> mousedown()&#x2F;&#x2F;按下鼠标按钮   mouseup()&#x2F;&#x2F;松开鼠标按钮  mouseenter()&#x2F;&#x2F;鼠标指针进入（穿过）元素  </p><p> mouseleave()&#x2F;&#x2F;鼠标移出 mousemove()&#x2F;&#x2F;指定的元素中移动时 mouseout()&#x2F;&#x2F;鼠标指针从元素上移开</p><p> mouseover() &#x2F;&#x2F;鼠标指针位于元素上方时 scroll()&#x2F;&#x2F;元素滚动</p><p> &#x2F;<em>键盘事件</em>&#x2F;<br> keydown()&#x2F;&#x2F;按下按键  keypress()&#x2F;&#x2F;按键次数  keyup() &#x2F;&#x2F;按键被松开并复位</p><p> &#x2F;<em>元素事件</em>&#x2F;<br> change()&#x2F;&#x2F;发生变化  click()&#x2F;&#x2F;单击 select()&#x2F;&#x2F;文本被选择时  dbclick()&#x2F;&#x2F;双击  </p><p> &#x2F;<em>页面事件</em>&#x2F;<br> resize()&#x2F;&#x2F;浏览器窗口调整大小进行 submit()&#x2F;&#x2F;提交表单时 load()&#x2F;&#x2F;元素（及子元素）已加载时</p><p> error()&#x2F;&#x2F;载入遇到错误  unload()&#x2F;&#x2F;当用户离开页面时，会发生 unload 事件</p><p>focusein和focuseout事件支持冒泡 focuse和blur事件不支持冒泡</p><p>mouseover和mouseout事件支持冒泡,  mouseenter和mouseleave是非冒泡事件</p><p>这几个事件是最初从IE引入的，jQuery隐式的做了浏览器兼容，以确保它们在所有浏览器下正确工作。</p><p>resize和unload事件类型只在Window对象中触发，如果想要给这两个事件类型注册处理程序，应该在$(window)上调用resize（）和unload()方法。</p><p>scroll（）方法经常也用在$(window)对象上，但它也可以用在有滚动条的任何元素上。</p><p>除了以上的这些，还有两个特殊形式的方法，有时很有用。</p><p>hover（）h和toggle()</p><p>hover()是用来给mouseenter和mouseleve事件注册处理程序。调用hover（f,g）就和调用mouseenter(f)然后调用mouseleave(g)一样。如果仅传入一个参数给hover()，则该参数函数会同时用enter和leave事件的处理程序。</p><p>toggle()该方法将事件处理程序函数绑定到单击事件。可指定两个或多个处理程序函数，当单击事件发生时，jQuery每次会调用一个处理程序函数。</p><h3 id="jQuery事件处理程序"><a href="#jQuery事件处理程序" class="headerlink" title="jQuery事件处理程序"></a>jQuery事件处理程序</h3><p>上面的例子中的事件处理程序函数被当作是不带参数以及不返回值的。像这样书写事件处理程序非常正常，但jQuery调用每一个事件处理程序时的确传入了一个或多个参数，并且对处理程序的返回值进行了处理。</p><p>jQuery事件处理程序函数的返回值始终有意义。如果处理程序返回false。该事件相关联的默认行为，以及该事件接下来的冒泡都会被取消。也就是说，返回false等同于调用Event对象的preventDefault和stopPropation()方法。</p><h3 id="jQuery事件对象"><a href="#jQuery事件对象" class="headerlink" title="jQuery事件对象"></a>jQuery事件对象</h3><p>jQuery通过定义自己的Event对象来隐藏浏览器之间的实现差异。当一个jQuery事件处理程序被调用时，总会传入一个jQuery事件对象作为其第一个参数。Jquery事件对象主要以W3C标准为基准，同时它也实现了一些实际的事件标准。</p><p>jQuery会将以下字段从原生Event对象中复制到jQuery Event对象上：</p><p> altkey   ctrlKey   newValue   screenX<br> attrChange currentTarget offsetX   screenY<br> attrName detail   offsetY   shiftKey<br> bubbles  eventPhase  originalTarget srcElement<br> button  fromElement  pageX   target<br> cancelable  keyCode   pageY   toElement<br> charCode layerX   prevValue   view<br> clientX  layerY   relatedNode  wheelDelta<br> clientY  metaKey   relatedTarget which<br>除了这些属性，Event对象还定义了以下方法:</p><p> preventDefault()   isDefaultPrevented()<br> stopPropagation()   isPropagationStopped()<br> stopImmediatePropagation() isImmediatePropagationStopped()</p><p>这些事件属性和方法在之前第十七章介绍过。并在第四部分的ref-Event中有详细文档说明。对于一部分字段，jQuery做了特殊处理，使其在所有浏览器中行为一致，需要我们留意:</p><p>metaKey</p><p>如果原生事件对象没有metaKey属性，jQuery会使其与ctrlKey属性的值一样。在Mac OS中，Command键设置meta键的属性</p><p>pageX，pageY</p><p>如果原生事件对象没有定义这两个属性，但定义了鼠标指针的视口坐标clientX和clientY，jquery会计算出鼠标指针的文档坐标并把它们存储在pageX和pageY中。</p><p>target,currentTarget,relatedTarget</p><p>target属性表示在其上发生事件的文档元素。如果原生事件对象的目标时文本节点，jQuery返回的目标会替换为包含该文本节点的元素.<br>currentTarget和target不一样，那么正在处理的事件是从触发它的元素冒泡上来的，此时使用is()方法来检测target元素可能会很有用。<br>relatedTarget表示其他元素</p><p>timeStamp</p><p>事件发生时的时间，单位时毫秒，由Date.getTime()方法返回，这个字段时jquery自身设置的，可以解决Firefox中一个长期存在的bug。</p><p>which</p><p>这是一个非标准事件属性，jQuery做了统一化处理，使其可以用来指明在事件发生期间，按下的是哪个鼠标按钮或键盘按键。</p><p>data</p><p>如果注册事件处理程序时指定了额外的数据，处理程序可以用该字段的值来访问。</p><p>handler</p><p>当前正被调用的事件处理程序函数的引用。</p><p>result<br>该事件最近调用的处理程序的返回值，忽略没有返回值的处理程序</p><p>originalEvent<br>浏览器生成的原生事件对象的引用</p><h3 id="事件处理程序的高级注册"><a href="#事件处理程序的高级注册" class="headerlink" title="事件处理程序的高级注册"></a>事件处理程序的高级注册</h3><p>.bind（）绑定一个事件类型字符串和一个方法函数</p><p> $(“#id”).bind(“click”,f);</p><h3 id="注销事件处理程序"><a href="#注销事件处理程序" class="headerlink" title="注销事件处理程序"></a>注销事件处理程序</h3><p>.unbind()注销事件处理程序避免在将来的事件中触发它。</p><h3 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h3><p>当用户使用鼠标、键盘或触发其他事件类型时，注册事件处理程序会自动调用。然而，如果能手动触发事件，有时会很有哟个，手动触发事件最简单的方式是不带参数调用事件注册的简单方法。如(click()或mouseover())</p><p> $(“form”).submit();  &#x2F;&#x2F;和用户单击提交按钮一样</p><h3 id="实时事件"><a href="#实时事件" class="headerlink" title="实时事件"></a>实时事件</h3><p>bind()方法绑定事件处理程序到指定文档元素，就与addEventListner()和attachEvent()一样。</p><h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><p>之前十六章的脚本化css我们知道了，通过设置CSS的visibility属性，可以显示和隐藏元素，</p><p>jQuery还定义了fadeIn()和fadeOut()等简单方法来实现视觉效果，除了简单动画方法，jQuery还定义了一个animate()方法。</p><p>jQuery动画方法经常使用动画时长来作为第一个可选的参数。如果省略时长参数，通常会得到默认值400ms。注意，省略时长时，有部分方法会立刻跳到最后一帧，没有中间的动画效果:</p><h3 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h3><p>fadeIn()、fadeOut()、fadeTo()</p><p>show()、hide()、toggle()</p><p>slideDown()、slideUp()、slideDown()</p><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p> $(“#id”).animate({<br>  opacity:.25,  &#x2F;&#x2F;将不透明度调整为0.25<br>  font-seize：10  &#x2F;&#x2F;将字体大小变化到10像素<br> },{<br>  ?duration:500,  &#x2F;&#x2F;动画持续半秒<br>  complete:function(){  &#x2F;&#x2F;在动画完成时调用该函数<br>   this.text(“Goodble”);&#x2F;&#x2F;改变文本元素<br>  }<br> })</p><ol><li>动画属性对象</li></ol><p> animate()方法的第一个参数必须是对象，该修啊ing的属性名必须是css属性名，这些属性名必须是动画的目标值</p><ol start="2"><li>动画选项对象</li></ol><p> animate()方法的第二个参数是可选的，该选项对象用来指定动画如何执行。有两个最重要的选项我们已经接触过。duration属性指定动画持续的毫秒时间，该属性的值还可以是”fast”、”slow”或任何在jquery.fx.speed中定义的名称</p><h3 id="动画的取消、延迟和队列"><a href="#动画的取消、延迟和队列" class="headerlink" title="动画的取消、延迟和队列"></a>动画的取消、延迟和队列</h3><p>jQuery还定义了一些动画和队列相关的方法，我们需要进一步了解。首先是stop()方法；它用来停止选中元素的当前正在执行的任何动画。</p><p> &#x2F;&#x2F;当鼠标悬浮在图片上时，图片变得不透明<br> &#x2F;&#x2F;注意：我们没有在鼠标事件上持有队列化动画<br> $(“img”).bind({<br>  mouseover:function(){ $(this).stop().fadeTo(300,1.0);},<br>  mouseout:function(){$(this).stop().fadeTo(300,0.5);}<br> });</p><p>与动画相关的第二个方法时delay()。这会直接添加一个时间延迟到动画队列中:第一个参数时时长(以毫秒为单位的数值或字符串),第二个参数是队列名，是可选的。</p><p> &#x2F;&#x2F;快速淡出为半透明，等一等，然后向上滑动<br> $(“img”).fadeTo(100,0.5).delay(200).slideUp();</p><h2 id="jQuery中的Ajax"><a href="#jQuery中的Ajax" class="headerlink" title="jQuery中的Ajax"></a>jQuery中的Ajax</h2><p>在Web应用编程技术里，Ajax很流行，它使用HTTP脚本(参考第18章)来按需加载数据，而不需要刷新整个页面。在Web应用中，Ajax技术非常有用，因此jQuery内置了Ajax工具来简化使用。</p><p>jQuery定义了一个高级工具方法和四个高级工具函数。这些高级工具都基于同一个强大的底层函数:jQuery.ajax()。</p><h3 id="load-方法"><a href="#load-方法" class="headerlink" title="load()方法"></a>load()方法</h3><p>load()是所有jQuery工具中最简单的:向它传入一个URL，它会异步加载该URL的内容，然后将内容插入每一个选中元素中，替换掉已经存在的任何内容。</p><p> &#x2F;&#x2F;每隔60秒加载并显示最新的状态报告<br> setInterval(function(){<br>  $(“#status”).load(“status_report.html”);<br> },60000);</p><p>除了必须的URL参数，load()方法还接受两个可选的参数，第一个可选的参数表示的数据，可以追加到URL后面，或者与请求一起发送。如果传入的是字符串，则会追加到URL后面(放在”?”或”&amp;”后面)。如果传入对象，该对象会被转化为一个用”&amp;”分隔的名&#x2F;值对后与请求一起发送。</p><p>load()方法的另一个可选参数是回调函数，当Ajax请求成功或未成功，以及(当请求成功时)URL加载完毕并插入选中元素时，会调用该回调函数。</p><h3 id="jQuery的Ajax状态码"><a href="#jQuery的Ajax状态码" class="headerlink" title="jQuery的Ajax状态码"></a>jQuery的Ajax状态码</h3><p>success: 表示请求成功完成</p><p>notmodified: 表示请求已正常完成，但服务器返回的响应内容是HTTP 304”Not Modified”,表示请求的URL内容和上次请求的相同，没有变化</p><p>error: 表示请求没有成功完成，原因是某些HTTP错误，更多细节，可以检查传入每个回调函数中的XMLHttpRequest对象的HTTP状态码来获取</p><p>timeout:如果ajax请求没有在选定的时间区域内完成，会调用错误回调，并传入该状态码</p><p>parseerror:该状态码表示HTTP请求已成功完成，但jQuery无法按照期望的方式解析</p><h3 id="Ajax工具函数"><a href="#Ajax工具函数" class="headerlink" title="Ajax工具函数"></a>Ajax工具函数</h3><p>jQuery的其他Ajax高级工具不是方法，而是函数，可以通过jQuery或$直接调用，而不是在jQuery对象上调用。jQuery.getScript()加载并执行JavaScript代码文件。jquery.getJSON()加载URL，将其解析未JSON，并将解析结果传递到指定的回调函数中。这两个函数会调用一个更通用的URL获取函数:jQuery.get()。最后，jQuery.post()和jQuery.get()很类似，除了执行的是HTTP POST而不是GET请求，与load()方法一样，所有这些函数都是异步的:在任何数据加载前它们就会返回调用者，加载结果则通过调用指定的回调函数来通知。</p><ol><li>jQuery.getScript()</li></ol><p> jQuery.getScript()函数的第一个参数是JavaScript代码文件的URL。它会异步加载文件，加载完成后在全局作用域执行该代码，它能同时适用同源和跨源脚本</p><p>  &#x2F;&#x2F;从其他服务器动态加载脚本<br>  jQuery.getScript(“http:?&#x2F;example.com&#x2F;js&#x2F;widget.js”);</p><p> 也可以传入回调函数作为第二个参数，在这种情况下，jQuery会在代码加载和执行完成后调用一次该回调函数:</p><p>  &#x2F;&#x2F;加载一个类库，并在加载完成时立刻使用它<br>  jQuery.getScript(“js&#x2F;jquery.my_plugin.js”,function(){<br>   $(“#id”).my_plugin();&#x2F;&#x2F;使用加载的类库<br>  });</p><ol start="2"><li>jQuery.getJSON()</li></ol><p> jQuery.getJSON()与jQuery.getScript()类似：它会获取文本，然后特殊处理以下，再调用指定的回调函数。jQuery.getJSON()获取到文本后，不会将其当作脚本执行，而会将其解析未JSON。</p><p>  &#x2F;&#x2F;假设data.json包含文本{“x”:1,”y”:2}<br>  jQuery.getJSON(“data.json”,function(data){<br>   &#x2F;&#x2F;data 参数是对象{x:1,y:2}<br>  })</p><ol start="3"><li>jQuery.get()和jQuery.post()</li></ol><p> jQuery.get()和jQuery.post()获取指定URL的内容，如果有数据的话，还可传入指定数据，最后则将结果传递给指定的回调函数。jQuery.get()使用HTTP GET请求来实现，jQuery.post()使用HTTP POST请求，其他两者都是一样的。</p><p>  &#x2F;&#x2F;从服务器请求文本，并在警告对话框中显示<br>  jQuery.get(“debu.txt”,alert);</p><h3 id="jQuery的Ajax的数据类型"><a href="#jQuery的Ajax的数据类型" class="headerlink" title="jQuery的Ajax的数据类型"></a>jQuery的Ajax的数据类型</h3><p>可以给get()和post()传递下面6中类型作为参数。</p><p>“text”</p><p>将服务器的响应作为纯文本返回，不做任何处理</p><p>“html”</p><p>该类型和”text”一样，响应的是纯文本，load()方法使用该类型，将返回的文本插入到文档自身中</p><p>“xml”</p><p>请求的URL被认为指向XML格式的数据，jQuery使用XMLHttpRequest对象的responseText属性。传给回调函数的值是一个表示该XML文档的Document对象，而不是保存文档文字的字符串</p><p>“script”</p><p>请求的URL被认为指向JavaScript文件，返回的文本在传入回调函数前，会当作脚本执行</p><p>“json”</p><p>请求的URL被认为指向JSON格式的数据文件，会使用jQuery.parseJson()来解析返回的内容，得到JSON对象后传入回调函数</p><p>“jsonp”</p><p>请求的URL被认为指向服务器脚本，该脚本支持JSON协议，可以将JSON格式的数据作为参数传递给客户端指定的函数。</p><h3 id="jQuery-ajax-函数"><a href="#jQuery-ajax-函数" class="headerlink" title="jQuery.ajax()函数"></a>jQuery.ajax()函数</h3><p>jQuery的所有Ajax工具最后都会调用jQuery.ajax（）——这是整个类库中最复杂的函数。</p><p>jQuery.ajax()仅接受一个参数，一个选项对象，该对象的属性指定Ajax请求如何执行的很多细节。</p><p>例如：jQuery.getScript(url,callback)与以下jQuery.ajax()的调用等价</p><p> jQuery.ajax({<br>  type:”GET”,  &#x2F;&#x2F;HTTP请求方法<br>  url:url,  &#x2F;&#x2F;要获取数据的url<br>  data:null,  &#x2F;&#x2F;不给url添加任何数据<br>  dataType:”script”, &#x2F;&#x2F;一旦获取到数据，立刻执行脚本<br>  success:callback &#x2F;&#x2F;完成时调用该函数<br> });</p><ol><li>通用选项</li></ol><p> type:指定HTTP的请求方法。默认时GET，常用POST。也可以指定其他HTTP的请求方法,比如”DELETE”和”PUSH”，但不是所有浏览器都支持它们</p><p> url:要获取的URL。对于GET请求，data选项会添加到该URL后面，对于JSONP请求，当cache选项未false时，jQuery可以添加参数到URL中</p><p> data： 添加到URL后(GET请求)或请求内容体中(POST请求)发送的数据。</p><p> dataType：指定响应数据的预期类型，以及jQuery处理该数据的方式；合法值就是上面的六种类型</p><p> contentType：指定请求的HTTP Content-Type头，默认是”application&#x2F;x-www-form-urlencoded”,这是HTML表单和绝大部分服务器脚本使用的正常值。如果将type选项设置为”POST”,向发送纯文本或XML文档作为请求体时，需要设置该选项</p><p> timeout：超过时间，单位是毫秒，如果设置了该选项，当请求没有在指定超时时间内完成，请求会取消同时触发error回调</p><p> cache：对于GET请求，如果该选项设置为false，jQuery会添加一个”_&#x3D;”参数到URL中，或者替换已经存在的同名参数。该参数的值时当前时间(毫秒格式)。这样禁用基于浏览器的缓存，因为每次请求的URL都不一样</p><p> ifModified：该选项设置为true时，jQuery会请求每一个URL记录Last-Modified和If-None-Match响应头的值，并会在接下里的请求中为相同的URL设置蛇蝎头部信息。</p><p> global：该选项指定jQuery是否应该触发上面描述的Ajax请求过程中的事件。默认值时true；设置该选项为false会禁用Ajax相关的所有事件。</p><ol start="2"><li>回调</li></ol><p> context:该选项指定回调函数在调用时的上下文对象——就是this。该选项没有默认值，如果不设置，this会指向选项对象。设置context选项也会影响Ajax事件触发的方式，如果设置该选项，值应该是windo、document或触发事件所在的Elemengt</p><p> beforeSend:该选项指定Ajax请求发送到服务器之前激活的回调含糊，第一个参数是XMLHttpRequest对象。</p><p> success:该选项指定Ajax请求成功完成时调用的回调函数。第一个参数是服务器发送的数据；第二个参数是jQuery状态码；第三个参数是用来发送该请求的XMLHttpRequest对象</p><p> error：该选项指定Ajax请求不成功时调用的回调函数。</p><p> complets：该选项指定Ajax请求完成时激活的回调函数。每一个Ajax请求或者成功时调用success回调，或者失败时调用error回调。在调用success或error后，jQuery会调用complete回调。传给complete回调的第一个参数是XMLHttpRequest对象，第二个参数则是状态码。</p><ol start="3"><li>不常用的选项和钩子</li></ol><p> async：脚本化的HTTP请求本身就是异步的。然而，XMLHttpRequest对象提供了一个选项，可以用来阻塞当前进程，直到接受到响应。如果想开启这一阻塞行为，可以设置该选项为false。</p><p> dataFilter：该选项指定一个函数，用来过滤或预处理服务器返回的数据。第一个参数是从服务器返回的原始数据，第二个参数是dataType选项的值，如果指定该函数，则它必须返回一个值。该值会用来替换调服务器 的响应。注意dataFileter()函数会在JSON解析和脚本执行前执行。同时注意对于跨域的”script”和”jsonp”请求不会调用dataFilter()。</p><p> jsonp：当设置dataType选项为”jsonp”时，url或data选项通常会包含一个类似”jsonp&#x3D;?”的参数。</p><p> jsonpCallback：对于dataType为”jsonp”请求(或URL中带有类似”jsonp&#x3D;?”这种JSONP参数的”json”请求)，jQuery必须将URL中的”?”替换成包装函数名。</p><p> processData:当设置data选项为对象时，jQuery通常会将该对象转化成字符串，该字符串遵守标准的HTML”application&#x2F;x-www-form-urlencoded”格式。如果想要省略掉该不走，可设置该选项为fasle</p><p> scriptCharset:对于跨域的”script”和”jsonp”请求，会使用<script>元素，该选项用来指定<script>元素的charset属性值。</p><p> tranditional:jQuery 1.4改变了数据对象的序列化为"application/x-www-form-urlencoded"字符串的方式。设置该选项为true，可以让jQuery回复到原来的方式</p><p> username,password：如果请求需要密码验证，请使用这两个选项来指定用户名和密码。</p><p> xhr：该选项指定一个工厂函数，用来获取XMLHttpRequest对象。该工厂函数在调用时不带参数，而且必须返回一个实现了XMLHttpRequest API的对象，这个非常底层的钩子可以创建自己对XMLHttpRequest的包装，也可以给方法添加特性和测量。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript Jquery</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本化http</title>
    <link href="/2021/04/14/JavaScript-http/"/>
    <url>/2021/04/14/JavaScript-http/</url>
    
    <content type="html"><![CDATA[<h1 id="脚本化http"><a href="#脚本化http" class="headerlink" title="脚本化http"></a>脚本化http</h1><p>超文本传输协议(HyperText Transfer Protocol,HTTP)规定Web浏览器如何从Web服务器获取文档和向Web服务器提交表单内容，以及Web服务器如何响应这些请求和提交。</p><p>Web浏览器会处理大量的HTTP，通常，HTTP并不在脚本的控制下，只是当用户单击链接、提交表单和输入URL时才发生。</p><p>但是，用JavaScript代码操作HTTP是可行的。当脚本设置window对象的location属性或调用表单对象的submit()方法时，都会初始化HTTP请求。</p><p>术语Ajax描述了一种主要使用脚本操作HTTP的Web应用架构。Ajax应用的主要特点是使用脚本操作HTTP和Web服务器进行数据交换，不会导致页面重载。避免页面重载的能力使Web应用更像传统的桌面应用。</p><p>Comet是使用脚本操纵HTTP的Web应用架构相关术语。在某种意义上Comt和Ajax相反，在Comet中，Web服务器发起通信并异步发送数据到客户端。如果Web应用需要响应服务端发送的消息，则它会使用Ajax技术发送或请求数据。在Ajax中，客户端从服务端”拉”数据。而在Comet中，服务器端向客户端”推”数据。Comet海波阔其他名词，(“服务器推”、”Ajax推”和”HTTP流”)</p><h2 id="使用XMLHttpRequest"><a href="#使用XMLHttpRequest" class="headerlink" title="使用XMLHttpRequest"></a>使用XMLHttpRequest</h2><p>浏览器在XMLHttpRequest类上定义了它们的HTTP API。这个类的每个实例都表示一个独立的请求&#x2F;响应对，并且这个对象的属性和方法允许指定请求细节和摄取响应数据。</p><p>当然，使用这个HTTP API必须要做的第一件事就是实例化XMLHttpRequest对象：</p><p> var request &#x3D; new XMLHttpRequest();</p><p>一个HTTP请求由4个部分组成：</p><ol><li>HTTP请求方法或”动作”(verb)</li><li>正式请求的URL</li><li>一个可选的请求头集合，其中可能包括身份验证信息</li><li>一个可选的请求体</li></ol><p>服务器返回的HTTP响应包含3部分:</p><ol><li>一个数字和文字组成的状态码，用来显示请求的成功和失败</li><li>一个响应头集合</li><li>响应主体</li></ol><p>HTTP的基础请求&#x2F;响应架构非常简单并且易于使用。但在实践中会有各种各样随之而来的复杂问题:客户端和服务区交换cookie，服务区重定向浏览器到其他服务器，缓存某些资源而剩下的不缓存，某些客户端通过代理通过代理服务器发送所有的请求等。<br>XMLHttpRequest不是协议级的HTTP API而是浏览器级的API。浏览器需要考虑cookie、重定向、缓存和代理，但代码只需要担心请求和响应。</p><h3 id="指定请求"><a href="#指定请求" class="headerlink" title="指定请求"></a>指定请求</h3><ol><li>创建XMLHttpRequest对象之后，发起HTTP请求的下一步是调用XMLHttpRequest对象的open()方法去指定这个请求的两个必需部分:方法和URL。</li></ol><p>  request.open(“GET”,&#x2F;&#x2F;开始一个HTTP GET请求<br>   “data.csv”);&#x2F;&#x2F;URL的内容</p><ul><li><p>open()的第一个参数指定HTTP方法或动作。这个字符串不区分大小写，但通常大家用大写字母来匹配HTTP协议。</p><p>“GET”和”POST”方法得到了广泛的支持。</p><p>“GET”用于常规请求，它适用于当URL完全指定请求资源，当请求对服务器没有任何副作用以及当服务器的响应是可缓存时。</p><p>“POST”方法常用于HTML表单。它在请求主体中包含额外数据(表单数据)，且这些数据常存储在服务器数据库中(副作用)。</p><p>除了这两个之外，XMLHttpRequest的规范还允许把”DELETE”、”HEAD”、”OPTIONS”和”PUT”作为open()的第一个参数。</p></li><li><p>open()的第二个参数时URL，它时请求的主题。这时相对于文档的URL，这个文档包含调用open()的骄傲本。如果指定绝对URL、协议、主机和端口通常必须匹配所在文档的对应内容:跨域请求通常会报错。</p></li></ul><ol start="2"><li>如果有请求头的话，请求进程的下一个步骤时设置它。例如，POST的请求需要”Content-Type”指定请求主题的MIME类型：</li></ol><p>  request.setRequestHeader(“Content-Type”,”text&#x2F;plain”);</p><p> 你不能自己指定”Content-Length”、”Date”、”Referer”或”User-Agent”头，XMLHttpRequest将自动添加这些头防止伪造它们。类似的XMLHttpRequest对象自动处理cookie、连续时间、字符集和编码判断</p><ol start="3"><li>使用XMLHttpRequest发起请求的最后一步是指定可选的请求猪蹄并向服务器发送它。使用send()方法实现<br>  request.send(null);</li></ol><p>GET请求绝对没有主体，所以应该传递null或省略这个参数。POST的请求通常拥有主体，同时它应该匹配使用setRequestHeader()指定的”Content-Type”头。</p><p><strong>顺序问题</strong></p><p>HTTP请求的各部分有指定顺序：</p><ul><li>请求方法和URL首先到达</li><li>然后请求头</li><li>最后是请求主体</li></ul><p>XMLHttpRequest实现通常直到调用send()方法才开始启动网络。但XMLHttpRequest API设计似乎使每个方法都将写入网络流。这意味着调用XMLHttpRequest方法的顺序必须撇陪HTTP请求的架构。例如setRequestHeader()必须调用在必须在open()之后，send()之前</p><p>例子:POST方法发送纯文本给服务器</p><p> function postMessage(msg){</p><p>  var request &#x3D; new XMLHttpRequest();&#x2F;&#x2F;新请求<br>  request.open(“POST”,”&#x2F;log.php”);&#x2F;&#x2F;用POST向服务器端发送脚本<br>  &#x2F;&#x2F;用请求主体发送纯文本消息<br>  request.setRequestHeader(“Content-Type”,&#x2F;&#x2F;请求主体是纯文本<br>       “text&#x2F;plain;charset&#x3D;UTF-8”);<br>  request.send(msg);&#x2F;&#x2F;把msg作为请求主体发送<br>  &#x2F;&#x2F;请求完成，我们将忽略任何响应和任何错误<br> }</p><h3 id="取得响应"><a href="#取得响应" class="headerlink" title="取得响应"></a>取得响应</h3><p>一个完整的HTTP响应由状态码、响应头集合和响应主体组成。这些都可以通过XMLHttpRequest对象的属性和方法使用：</p><ul><li><p>status和statusText属性以数字和文本的形式返回HTTP状态码。这些属性保存标准的HTTP值，像200和”OK”表示成功请求，404和”Not Found”表示URL不能匹配服务器上的任何资源。</p></li><li><p>使用getResponseHeader()和getAllResponseHeader()能查询响应头。XMLHttpRequest会自动处理cookie：它会从getAllResponseHeaders()头返回集合中过滤掉cookie头，而去过给getResponseHeader()传递”Set-Cookie”和”Set-Cookie2”则返回null。</p></li><li><p>响应主体可以从responseText属性中得到文本形式的，从responseXML属性中得到Document形式。</p></li></ul><p>XMLHttpRequest对象通常异步使用:发送请求后,send()方法立即返回，知道响应返回，前面列出的响应方法和属性才有效。</p><p>为了在响应准备就绪时得到通知，必须监听XMLHttpRequest对象上的readystatechange事件。</p><p>readyState是一个整数，它指定了HTTP请求的状态，第一列的符号时XMLHttpRequest构造函数定义的常量。</p><p>XMLHttpRequest的readyState值</p><p> 常量     值   含义</p><p> UNSENT    0  open()尚未调用<br> OPENED    1  open()已经调用<br> HEADERS_RECEIVED 2  接受到头信息<br> LOADING    3  接收到响应主体<br> DONE    4  响应完成</p><p>示例：定义了getText()函数来演示如何监听readystatechange事件。</p><p> &#x2F;&#x2F; 发出一个HTTP GET请求以获得指定URL的内容<br> &#x2F;&#x2F; 当响应成功到达，验证它是否是纯文本<br> &#x2F;&#x2F; 如果是，把它传递给指定回调函数<br> function getText(url, callback) {<br>     var request &#x3D; new XMLHttpRequest();         &#x2F;&#x2F; 新建请求<br>     request.open(“GET”, url);                   &#x2F;&#x2F; 指定待获取的URL<br>     request.onreadystatechange &#x3D; function() {   &#x2F;&#x2F; 定义事件处理程序<br>         &#x2F;&#x2F; 如果请求完成，则它是成功的<br>         if (request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; request.status &#x3D;&#x3D;&#x3D; 200) {<br>             var type &#x3D; request.getResponseHeader(“Content-Type”);<br>             if (type.match(&#x2F;^text&#x2F;))            &#x2F;&#x2F; 确保响应式文本<br>                 callback(request.responseText); &#x2F;&#x2F; 把它传递给回调函数<br>         }<br>     };<br>     request.send(null);                         &#x2F;&#x2F; 立即发送请求<br> }</p><ol><li>同步响应</li></ol><p> 由于其本身的性质，异步处理HTTP响应是最好的方式。然而，XMLHttpRequest也支持同步响应。如果把false作为第三个参数传递给open()，那么send()方法将阻塞直到请求完成。</p><p>  &#x2F;&#x2F; 发出一个HTTP GET请求以获得指定URL的内容<br>  &#x2F;&#x2F; 返回响应文本，或如果请求不成功或响应不是文本就报错<br>  function getTexSynct(url) {<br>      var request &#x3D; new XMLHttpRequest();         &#x2F;&#x2F; 新建请求<br>      request.open(“GET”, url);                   &#x2F;&#x2F; 传递false实现同步<br>   request.sen(null);       &#x2F;&#x2F; 立即发送请求</p><pre><code class="hljs">  // 如果请求不是200 OK，就报错  if (request.status === 200) throw new Error(request.statusText);</code></pre><p>   &#x2F;&#x2F;如果类型错误，就报错<br>   var type &#x3D; request.getResponseHeader(“Content-Type”);</p><p>   if(!type.match(&#x2F;^text&#x2F;))<br>    throw new Error(“Expected textual response;got:”+type);</p><p>   return request.responseText;</p><p>  }</p><p> 同步请求是吸引人的，但应该避免使用它们，客户端JavaScript是单线程的，当send()方法阻塞时，它通常会导致整个浏览器UI冻结。如果连接到服务器响应慢，那么用户的浏览器将冻结。</p><ol start="2"><li>响应解码</li></ol><p> 在前面的示例中,我们假设服务器使用像”text&#x2F;plain”、”text&#x2F;html”或”text&#x2F;css”这样的MIME类型发送文本响应，然后我们使用XMLHttpRequest对象的responseText属性得到它。</p><p> 如果服务器想发送诸如对象或数组这样的结构化数据作为其响应，它应该传输JSON编码的字符串数据。当接受它时，可以把responseText属性传递给JSON.parse()。</p><p> 示例解析HTTP响应</p><p>  &#x2F;&#x2F; 发起HTTP GET响应以获取指定URL的内容<br>  &#x2F;&#x2F; 当响应到达时，把它以解析后的XML Document对象、解析后的JSON对象<br>  &#x2F;&#x2F; 或字符串形式传递给回调函数<br>  function get(url, callback) {<br>      var request &#x3D; new XMLHttpRequest();         &#x2F;&#x2F; 创建新请求<br>      request.open(“GET”, url);                   &#x2F;&#x2F; 指定待获取的URL<br>      request.onreadystatechange &#x3D; function() {   &#x2F;&#x2F; 定义事件监听器<br>          &#x2F;&#x2F; 如果请求完成且成功<br>          if (request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; request.status &#x3D;&#x3D;&#x3D; 200) {<br>              &#x2F;&#x2F; 获取响应类型<br>              var type &#x3D; request.getResponseHeader(“Content-Type”);<br>              &#x2F;&#x2F; 检查类型，这样我们不能在将来得到HTML文档<br>              if (type.indexOf(“xml”) !&#x3D;&#x3D; -1 &amp;&amp; request.responseXML)<br>                  callback(request.responseXML);             &#x2F;&#x2F; Document对象相应<br>              else if (type &#x3D;&#x3D;&#x3D; “application&#x2F;json”)<br>                  callback(JSON.parse(request.responseText)); &#x2F;&#x2F; JSON响应<br>              else<br>                  callback(request.responseText);             &#x2F;&#x2F; 字符串响应<br>          }<br>      };<br>      request.send(null);                         &#x2F;&#x2F; 立即发送请求<br>  }</p><h3 id="编码请求主体"><a href="#编码请求主体" class="headerlink" title="编码请求主体"></a>编码请求主体</h3><p>HTTP POST请求包括一个请求主体，它包含客户端传递给服务器的数据。我们通常使用HTTP请求发送的都是更复杂的数据。</p><ol><li>表单编码的请求</li></ol><p> 考虑HTML表单。当用户提交表单时，表单中的数据(每个表单元素的名字和值)编码到一个字符串中并随请求发送。像这样:</p><p>  name&#x3D;minchao&amp;sex&#x3D;man<br> 表单数据编码格式是一个正式的MIME类型：</p><p>  application&#x2F;x-www-form-urlencoded</p><p> 当POST方法提交表单数据时，必须设置”Content-Type”请求头为这个值。这种编码并不要HTML表单。在Ajax应用中，你希望发送给服务器的很可能时一个JavaScript对象。</p><p>  {<br>   name:”minchao”,<br>   sex:”man”<br>  }<br> 用于HTTP请求的编码对象</p><p>  &#x2F;**</p><ul><li>编码对象的属性，</li><li>如果它们是来自HTML表单的名&#x2F;值对，使用application&#x2F;x-wwww-form-urlencode格式<br> *&#x2F;<br>function encodeFormData(data) {<br>if (!data) return “”;    &#x2F;&#x2F; 一直返回字符串<br>var pairs &#x3D; [];          &#x2F;&#x2F; 为了保存名值对<br>for(var name in data) {                                  &#x2F;&#x2F; 遍历每个名字<br>    if (!data.hasOwnProperty(name)) continue;            &#x2F;&#x2F; 跳过继承属性<br>    if (typeof data[name] &#x3D;&#x3D;&#x3D; “function”) continue;      &#x2F;&#x2F; 跳过方法<br>    var value &#x3D; data[name].toString();                   &#x2F;&#x2F; 把值转换成字符串<br>    name &#x3D; encodeURIComponent(name.replace(“ “, “+”));   &#x2F;&#x2F; 编码名字<br>    value &#x3D; encodeURIComponent(value.replace(“ “, “+”)); &#x2F;&#x2F; 编码值<br>    pairs.push(name + “&#x3D;” + value);   &#x2F;&#x2F; 记住名&#x3D;值对<br>}<br>return pairs.join(‘&amp;’); &#x2F;&#x2F; 返回使用&amp;连接的名&#x2F;值对<br>}</li></ul><p> 使用表单编码数据发起一个HTTP POST请求</p><p>  function postData(url, data, callback) {<br>      var request &#x3D; new XMLHttpRequest();<br>      request.open(“POST”, url);                    &#x2F;&#x2F; 对指定URL发生POST请求<br>      request.onreadystatechange &#x3D; function() {     &#x2F;&#x2F; 简单的事件处理程序<br>          if (request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; callback) &#x2F;&#x2F; 当响应完成<br>              callback(request);                    &#x2F;&#x2F; 调用回调函数<br>      };<br>      request.setRequestHeader(“Content-Type”,      &#x2F;&#x2F; 设置 Content-Type<br>                               “application&#x2F;x-www-form-urlencoded”);<br>      request.send(encodeFormData(data));           &#x2F;&#x2F; 发送表单数据<br>  }</p><p> 使用表单编码数据发起HTTP  GET请求</p><p>  function getData(url, data, callback) {<br>     var request &#x3D; new XMLHttpRequest();<br>     request.open(“GET”, url +                     &#x2F;&#x2F; 通过添加编码数据获取指定的url<br>                  “?” + encodeFormData(data));<br>     request.onreadystatechange &#x3D; function() {     &#x2F;&#x2F; 简单事件处理程序<br>         if (request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; callback) callback(request);<br>     };<br>      request.send(null);                           &#x2F;&#x2F; 发送请求<br>  }</p><ol start="2"><li>JSON编码的请求</li></ol><p> 在POST请求主体中使用表单编码时常见惯例。</p><p>  function postJSON(url, data, callback) {<br>      var request &#x3D; new XMLHttpRequest();<br>      request.open(“POST”, url);                    &#x2F;&#x2F; 对指定URL发送POST请求<br>      request.onreadystatechange &#x3D; function() {     &#x2F;&#x2F; 简单是事件处理程序<br>          if (request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; callback) &#x2F;&#x2F; 当响应完成时<br>              callback(request);                    &#x2F;&#x2F; 调用回调函数<br>      };<br>      request.setRequestHeader(“Content-Type”, “application&#x2F;json”);<br>      request.send(JSON.stringify(data));<br>  }</p><ol start="3"><li>XML编码的请求</li></ol><p> XML有时也用于数据传输的编码。JavaScript对象的用表单编码或JSON编码版本表达的。<br> 略</p><ol start="4"><li>上传文件</li></ol><p> HTML表单的特性之一时当用户通过&lt; input type&#x3D;”file”&gt;元素选择文件时，表单将在它产生的POST请求主体中发送文件内容。HTNL表单始终能上传文件，但到目前为止，它还不能使用XMLHttpRequest API做相同的事。</p><p> 使用HTTP POST请求上传文件</p><p>  &#x2F;&#x2F;查找有data-upload属性的全部<input tyep="file">元素<br>  &#x2F;&#x2F;并注册onchange事件处理程序<br>  &#x2F;&#x2F;这样任何选择的文件都会自动通过POST方法发送到指定的”uploadto”URL<br>  &#x2F;&#x2F;服务器的响应是忽略的<br>  whenReady(function() {                        &#x2F;&#x2F; 当文档准备就绪时运行<br>      var elts &#x3D; document.getElementsByTagName(“input”); &#x2F;&#x2F; 所有的input元素<br>      for(var i &#x3D; 0; i &lt; elts.length; i++) {             &#x2F;&#x2F; 遍历它们<br>          var input &#x3D; elts[i];<br>          if (input.type !&#x3D;&#x3D; “file”) continue;  &#x2F;&#x2F; 跳过所有非文件上传元素<br>          var url &#x3D; input.getAttribute(“data-uploadto”); &#x2F;&#x2F; 获取上级URL<br>          if (!url) continue;                   &#x2F;&#x2F; 跳过任何没有URL的元素</p><pre><code class="hljs">      input.addEventListener(&quot;change&quot;, function() &#123;  // 当用户选择文件时          var file = this.files[0];         // 假设单个文件选择          if (!file) return;                // 如果没有文件，不做任何事情          var xhr = new XMLHttpRequest();   // 创建新请求          xhr.open(&quot;POST&quot;, url);            // 向这个URL发送POST请求          xhr.send(file);                   // 把文件作为主体发送      &#125;, false);  &#125;</code></pre><p>  });</p><ol start="5"><li>multipart&#x2F;form-data请求</li></ol><p> 当HTML表单同时包含文件上传元素和其他元素时，浏览器不能使用普遍的表单编码而必须使用称为”multipart&#x2F;form-data”的特殊Content-Type来用POST方法提交表单。</p><p> 使用POST方法发送multipart&#x2F;form-data请求主体</p><p>  function postFormData(url, data, callback) {<br>      if (typeof FormData &#x3D;&#x3D;&#x3D; “undefined”)<br>          throw new Error(“FormData is not implemented”);</p><pre><code class="hljs">  var request = new XMLHttpRequest();            // 新HTTP请求  request.open(&quot;POST&quot;, url);                     // 对指定URL发送POST请求  request.onreadystatechange = function() &#123;      // 简单的事件处理程序      if (request.readyState === 4 &amp;&amp; callback)  // 当响应完成时          callback(request);                     // 调用回调函数  &#125;;  var formdata = new FormData();  for(var name in data) &#123;      if (!data.hasOwnProperty(name)) continue;  // 跳过继承的属性      var value = data[name];      if (typeof value === &quot;function&quot;) continue; // 跳过方法      // 每个属性变成请求的一部分      // 这里允许File对象      formdata.append(name, value);              // 作为一部分添加名/值对  &#125;  // 在multipart/form-data请求主体中发送名值对</code></pre><p>   &#x2F;&#x2F; 每对都是请求的一部分，注意，当传入FormData对象时<br>   &#x2F;&#x2F; sen()会自动设置Content-Type头<br>      request.send(formdata);<br>  }</p><h3 id="HTTP进度事件"><a href="#HTTP进度事件" class="headerlink" title="HTTP进度事件"></a>HTTP进度事件</h3><p>在之前的示例中，使用readystatechange事件探测HTTP请求的完成。</p><p>常见的progress事件处理程序一样使用upload事件处理程序，对于XMLHttpRequest对象x，设置x.onpressgress以监控响应的下载进度，并且设置x.upload.onprogress以监控请求的上传进度。</p><p> &#x2F;&#x2F; 查找所有含有”fileDropTarget”类的元素<br> &#x2F;&#x2F; 并注册DnD事件处理程序使它们能响应文件的拖拽<br> &#x2F;&#x2F; 当文件放下时，上传它们到data-uploadto属性<br> whenReady(function() {<br>     var elts &#x3D; document.getElementsByClassName(“fileDropTarget”);<br>     for(var i &#x3D; 0; i &lt; elts.length; i++) {<br>         var target &#x3D; elts[i];<br>         var url &#x3D; target.getAttribute(“data-uploadto”);<br>         if (!url) continue;<br>         createFileUploadDropTarget(target, url);<br>     }</p><pre><code class="hljs"> function createFileUploadDropTarget(target, url) &#123;     // 跟踪当前是否正在上传，因此我们能拒绝放下</code></pre><p>   &#x2F;&#x2F; 我们可以处理多个并发上传<br>   &#x2F;&#x2F; 但对这个例子使用进度通知太困难了<br>         var uploading &#x3D; false;</p><pre><code class="hljs">     console.log(target, url);     target.ondragenter = function(e) &#123;         console.log(&quot;dragenter&quot;);         if (uploading) return;  // 如果正忙，忽略拖放         var types = e.dataTransfer.types;         if (types &amp;&amp;              ((types.contains &amp;&amp; types.contains(&quot;Files&quot;)) ||              (types.indexOf &amp;&amp; types.indexOf(&quot;Files&quot;) !== -1))) &#123;             target.classList.add(&quot;wantdrop&quot;);             return false;         &#125;     &#125;;     target.ondragover = function(e) &#123; if (!uploading) return false; &#125;;     target.ondragleave = function(e) &#123;         if (!uploading) target.classList.remove(&quot;wantdrop&quot;);     &#125;;     target.ondrop = function(e) &#123;         if (uploading) return false;         var files = e.dataTransfer.files;         if (files &amp;&amp; files.length) &#123;             uploading = true;             var message = &quot;Uploading files:&lt;ul&gt;&quot;;             for(var i = 0; i &lt; files.length; i++)                  message += &quot;&lt;li&gt;&quot; + files[i].name + &quot;&lt;/li&gt;&quot;;             message += &quot;&lt;/ul&gt;&quot;;                          target.innerHTML = message;             target.classList.remove(&quot;wantdrop&quot;);             target.classList.add(&quot;uploading&quot;);                          var xhr = new XMLHttpRequest();             xhr.open(&quot;POST&quot;, url);             var body = new FormData();             for(var i = 0; i &lt; files.length; i++) body.append(i, files[i]);             xhr.upload.onprogress = function(e) &#123;                 if (e.lengthComputable) &#123;                     target.innerHTML = message +                         Math.round(e.loaded/e.total*100) +                         &quot;% Complete&quot;;                 &#125;             &#125;;             xhr.upload.onload = function(e) &#123;                 uploading = false;                 target.classList.remove(&quot;uploading&quot;);                 target.innerHTML = &quot;Drop files to upload&quot;;             &#125;;             xhr.send(body);             return false;         &#125;         target.classList.remove(&quot;wantdrop&quot;);     &#125; &#125;</code></pre><p> });</p><h3 id="中止请求和超时"><a href="#中止请求和超时" class="headerlink" title="中止请求和超时"></a>中止请求和超时</h3><p>可以通过调用XMLHttpRequest对象的abort()方法来取消正在进行的HTTP请求。abort()方法在所有的XMLHttpRequest版本和XHR2中可用。</p><p> &#x2F;&#x2F; 发起HTTP GET请求获取指定的URL的内容<br> &#x2F;&#x2F;  如果响应成功到达，传入responseText给回调函数<br> &#x2F;&#x2F; 如果响应在timeout毫秒内没有到达，中止这个请求<br> &#x2F;&#x2F;  浏览器可能在abort()后触发”readstatechange”<br> &#x2F;&#x2F;  如果时部分请求结果到达，甚至可能设置status属性<br> &#x2F;&#x2F; 所以需要设置一个标记，当部分且超时的响应到达时不会调用回调函数<br> &#x2F;&#x2F; 如果使用load事件就没有这个风险<br> function timedGetText(url, timeout, callback) {<br>     var request &#x3D; new XMLHttpRequest();         &#x2F;&#x2F; 创建新请求<br>     var timedout &#x3D; false;                       &#x2F;&#x2F; 是否超时<br>     &#x2F;&#x2F; 启动计时器，在timeout毫秒后将中止请求<br>     var timer &#x3D; setTimeout(function() {         &#x2F;&#x2F; 如果触发，启动一个计时器<br>                                timedout &#x3D; true; &#x2F;&#x2F; 如果标记<br>                                request.abort(); &#x2F;&#x2F; 然后中止请求<br>                            },<br>                            timeout);            &#x2F;&#x2F; 中止请求之前的时长<br>     request.open(“GET”, url);                   &#x2F;&#x2F; 获取指定的URL<br>     request.onreadystatechange &#x3D; function() {   &#x2F;&#x2F; 定义事件处理程序<br>         if (request.readyState !&#x3D;&#x3D; 4) return;   &#x2F;&#x2F; 忽略未完成的请求<br>         if (timedout) return;                   &#x2F;&#x2F; 忽略中止请求<br>         clearTimeout(timer);                    &#x2F;&#x2F; 取消等待的超时<br>         if (request.status &#x3D;&#x3D;&#x3D; 200)             &#x2F;&#x2F; 如果请求成功<br>             callback(request.responseText);     &#x2F;&#x2F; 把response传给回调函数<br>     };<br>     request.send(null);                         &#x2F;&#x2F; 立即发送请求<br> }</p><h3 id="跨域HTTP请求"><a href="#跨域HTTP请求" class="headerlink" title="跨域HTTP请求"></a>跨域HTTP请求</h3><p>作为同源策略的一部分，XMLHttpRequest对象通常仅可以发起和文档具有相同服务器的HTTP请求。</p><h2 id="借助-lt-script-gt-发送HTTP请求-JSON"><a href="#借助-lt-script-gt-发送HTTP请求-JSON" class="headerlink" title="借助&lt; script&gt;发送HTTP请求:JSON"></a>借助&lt; script&gt;发送HTTP请求:JSON</h2><p>&lt; script&gt;元素可以作为一种Ajax传输机制:只须设置&lt; script&gt;元素的src属性，然后浏览器就会发送一个HTTP请求以下载src属性所指向的URL。</p><p><strong>脚本和安全性</strong></p><p>为了使用&lt; script&gt;元素进行Ajax传输，必须允许Web页面可以执行远程服务器发送过来的任何JavaScript代码，这意味着对于不可信的服务器，不应该采取该技术。当与可信的服务器通信时，要提防攻击者可能进入服务器中，然后黑客会接管你的页面，运行他自己的代码，并显示任何他想要的内容。</p><p>这种使用&lt; script&gt;元素作为Ajax传输的技术成为JSONP，若HTTP请求所得到的响应数据时经过JSON编码的，则适合使用该技术。</p><p> &#x2F;&#x2F; 根据指定的URL发送一个JSON请求<br> &#x2F;&#x2F; 然后把解析得到的响应数据传递给回调函数<br> &#x2F;&#x2F; 在URL中添加一个名为jsonp的查询参数，用于指定该请求的回掉函数的名称<br> function getJSONP(url, callback) {<br>     &#x2F;&#x2F; 为本次请求创建一个唯一的回调函数名称<br>     var cbnum &#x3D; “cb” + getJSONP.counter++; &#x2F;&#x2F; 每次自增计数器<br>     var cbname &#x3D; “getJSONP.” + cbnum;      &#x2F;&#x2F; 作为JSONP函数的属性</p><pre><code class="hljs"> // 将回调函数名称以表单编码的形式添加到URL的查询部分</code></pre><p>  &#x2F;&#x2F; 使用jsonp作为参数名，一些支持JSONP的服务<br>  &#x2F;&#x2F; 可能使用其他的参数名，比如callback<br>     if (url.indexOf(“?”) &#x3D;&#x3D;&#x3D; -1)   &#x2F;&#x2F; URL没有查询部分<br>         url +&#x3D; “?jsonp&#x3D;” + cbname; &#x2F;&#x2F; 作为查询部分添加参数<br>     else                           &#x2F;&#x2F; 否则<br>         url +&#x3D; “&amp;jsonp&#x3D;” + cbname; &#x2F;&#x2F; 作为新的参数添加它</p><pre><code class="hljs"> // 创建script元素用于发送请求 var script = document.createElement(&quot;script&quot;); // 定义将被脚本执行的回调函数 getJSONP[cbnum] = function(response) &#123;     try &#123;         callback(response); // 处理响应数据     &#125;     finally &#123;               // 即使回调函数或响应抛出错误         delete getJSONP[cbnum];                // 删除该函数         script.parentNode.removeChild(script); // 移除script元素     &#125; &#125;; // 立即触发HTTP请求 script.src = url;                  // 设置脚本的URL document.body.appendChild(script); // 把它添加到文档中</code></pre><p> }</p><p> getJSONP.counter &#x3D; 0;  &#x2F;&#x2F; 用于创建唯一回调函数名称的计数器</p><h2 id="基于服务器端推送事件的Come技术"><a href="#基于服务器端推送事件的Come技术" class="headerlink" title="基于服务器端推送事件的Come技术"></a>基于服务器端推送事件的Come技术</h2><p>在服务器端推送事件的标准草案中定义了一个EventSource对象，简化了Comet应用程序的编写可以传递一个URL给EventSource()构造函数，然后在返回的实例上监听消息事件。</p><p> var ticker &#x3D; new EventSource(“stockprices.php”);<br> ticker.onmessage &#x3D; function(e){<br>  var type &#x3D; e.type;<br>  var data &#x3D; e.data;<br>  &#x2F;&#x2F;现在处理事件类型和事件的字符串数据<br> }</p><p>Comet架构的一个常见的应用是聊天应用，聊天客户端可以通过XMLHttpRequest向聊天室发送新的消息，也可以通过EventSource对象订阅聊天信息。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件处理</title>
    <link href="/2021/04/13/JavaScript-seventeen/"/>
    <url>/2021/04/13/JavaScript-seventeen/</url>
    
    <content type="html"><![CDATA[<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p>客户端JavaScript程序采用了异步事件驱动编程模型。在这种程序设计风格下，当文档、浏览器、元素或与之相关的对象发生某些有趣的事情时，Web浏览器就会产生事件(event)。例如，当Web浏览器加载完文档、用户把鼠标指针移到超链接上或敲击键盘时。Web浏览器都会产生事件。如果JavaScript应用程序关注特定类型的事件，那么它可以注册当这类事件发生时要调用的一个或多个函数。</p><p>事件类型(event type)是一个用来说明发生什么类型事件的字符串。例如，”mousemove”表示用户移动鼠标，”keydown”表示键盘上某个键被按下，而”load”表示文档(或某个其他资源)从网络上加载完毕。由于事件类型只是一个字符串，因此，实际上有时会被称为”事件名字”。</p><p>事件目标(event target)是发生的事件或与之相关的对象。当讲事件时，我们必须同时指明类型和目标。例如，Window上的load事件或<code>&lt;button&gt;</code>元素的click事件。在客户端的JavaScript应用程序中，Window、Document和Element对象是最常见的事件目标，但某些事件是由其他类型的对象触发。</p><p>事件处理程序(event handler)或事件监听程序(event listener)是处理或响应事件的函数。应用程序通过指明事件类型和事件目标，在Web浏览器中注册它们的事件处理程序函数。</p><p>事件对象(event object)是与特定事件相关并且包含有关事件详细信息的对象。事件对象作为参数传递给事件处理程序函数。</p><p>事件传播(event propagation)是浏览器决定哪个对象触发其事件处理程序的过程。对于单个对象的特定事件(比如Window对象的load事件)，必须是不能传播的。</p><p>事件传播的另外一种形式成为事件捕获(event capturing)，在容器元素上注册的特定处理程序有机会在事件传播到真是目标之前拦截(或”捕获”)它。</p><p>特定的事件类型包括：</p><ul><li>文档加载和准备就绪事件</li><li>鼠标事件</li><li>鼠标滚轮事件</li><li>拖放事件</li><li>键盘事件</li><li>文本输入事件</li></ul><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>Web初期，客户端的程序员只能用少部分事件，比如”load”、”click”和”mouseover”等。这些传统事件类型在所有浏览器中得到了很好的支持。随着Web平台发展到包括更强大的API，事件集合越来越大。<br>新事件有三个来源:</p><ul><li><p>3级DOM事件规范，经过长期的停滞之后，W3C带动下又开始换发生机。</p></li><li><p>HTML5规范及相关衍生规范的大量新API定义了新事件，比如历史管理、拖放、跨文档通信，以及视频和音频的播放。</p></li><li><p>基于触摸和支持JavaScript的移动设备的出现，比如Ipone，它们需要定义新的触摸和手势事件类型。</p></li></ul><h3 id="传统的事件类型"><a href="#传统的事件类型" class="headerlink" title="传统的事件类型"></a>传统的事件类型</h3><ul><li>表单事件</li></ul><p> <code>&lt;form&gt;</code>元素会分别处罚submit和reset事件。</p><ul><li>Window事件</li></ul><p> Window事件是指事件的发生与浏览器窗口中显示的任何特定文档内容相关。</p><p> load事件是这些事件中最重要的一个，当文档和其所有外部资源完全加载并显示给用户时就会触发它。</p><p> unload事件是load事件的相对事件，当用户离开当前文档转向其他文档时触发。</p><p> Window对象的onerror属性有点像事件处理程序，当JavaScript出错时会触发它。</p><ul><li>鼠标事件</li></ul><p> 当用户在文档上移动或者单击鼠标时都会产生鼠标事件。这些事件在鼠标指针所对应的最深嵌套元素上触发。但它们会冒泡直到文档最顶层。传递给鼠标事件处理程序的事件对象有属性集。</p><p> mousemove事件。用户每次移动或拖动鼠标时会触发。这些事件的发生非常频繁，因此不能用于触发计算密集型任务。</p><p> mosuedown和mouseuo。用户按下或释放鼠标按键是，糊触发。通过注册mousedown和mosuemove事件处理程序，可以探测和响应鼠标的拖动。合理地这样做能够不过鼠标事件。甚至当鼠标从开始元素移出时我们都能够持续地接受到mousemove事件。</p><p> 在mousedown和mosueup事件队列之后，浏览器也会触发click事件。如果用户在较短的时间内连续两次单击鼠标按键，跟在第二个click事件之后的是dbclick事件。</p><p> mouseover和mouseout事件，当鼠标指针从悬停到新元素上时，浏览器会在该元素上触发mouseover事件。当鼠标指针不在悬停在某个元素上时，浏览器会触发mouseout事件。</p><p> mouseenter和mouseleave。用于判断鼠标指针是离开了这个元素还是移到了另一个元素。</p><ul><li>键盘事件</li></ul><p> 当键盘聚焦到Web浏览器时，用户每次按下或释放键盘上的按键时都会产生事件。键盘快捷键对于操作系统和浏览器本身有特殊意义，它们经常被操作系统或浏览器”吃掉”并对JavaScript事件处理程序不可见。</p><p> 传递给键盘事件处理程序的事件对象有keyCode字段，它指定按下或释放的键是哪个。除了keyCode，键盘事件对象也有altKey、CtrlKey、metaKey和shiftKey，描述键盘辅助键的状态。</p><p> 所有浏览器都支持keydown、keyup和keypress事件，但有一些互用性问题，因为事件对象的keyCode属性值从未标准化过。</p><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><p>标准化了冒泡的mouseenter和mouseleave事件来取代不冒泡的mouseover和mouseout事件。</p><h3 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h3><p>HTML5及相关标准定义了大量新的Web应用API，其中许多API都定义了事件。</p><p>由于HTML5中加入了播放音频和视频的<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>元素。这些元素有长长的事件列表，它们触发各种关于网络事件、数据缓冲状况和播放状态的通知：</p><p> canplay   loadeddata  playing   stalled<br> canplaythrough loadedmetadata progress  suspend<br> durationchange loadstart  ratechange  timeupdate<br> emptied   pause    seeked    volumechange<br> ended   play   seeking   waiting</p><p>HTML5的拖放API允许JavaScript应用参与操作系统的拖放操作，实现Web和原生应用间的数据传输。</p><p> dragstart   drag   dragend<br> dragenter  dragover dragleave<br> drop<br>触发拖放事件对象和通过鼠标事件来发送的对象类似，其附加属性dataTransfer持有DataTransfer对象，它包含关于传输的数据和其中可用的格式的信息。</p><p>HTML5包含了对离线Web应用的支持，它们可以安装到本地应用缓存中，所以即使浏览器离线时它们依旧能运行，比如何时浏览器失去或得到网络连接都会在Window对象上触发它们。</p><p> cached checking  downloading  error<br> noupdate obsolete  progress updateready</p><h3 id="触摸屏和移动设备事件"><a href="#触摸屏和移动设备事件" class="headerlink" title="触摸屏和移动设备事件"></a>触摸屏和移动设备事件</h3><p>强大的移动设备的广泛采用(特别时使用触摸屏的那些设备)需要建立新的事件类别。在许多情况下，触摸屏事件映射到传统的事件类型(click和srcoll)，但不是每次和触摸屏UI的交互都能仿效鼠标，也不是所有的触摸屏都可以当作鼠标事件处理。</p><p>手势是高级事件，用于通知已经翻译的手势。如果想实现自定义手势，你可以监听低级触摸事件。当手指接触屏幕的时候会触发touchstart事件，当手指移动时会触发touchmove事件，而当手指离开屏幕时会触发touchend事件。</p><p>当用户允许用户从竖屏旋转到横屏时会在Window对象上触发orientationchanged事件，该事件传递的事件对象本身没有用，但是，在移动版的Safari中，Window对象的orientation属性能给出当前方位，其值时0、90、180或-90。</p><h2 id="注册事件处理程序"><a href="#注册事件处理程序" class="headerlink" title="注册事件处理程序"></a>注册事件处理程序</h2><p>注册事件处理程序有两种基本方式。</p><p>第一种方式出现在Web初期，给事件目标对象或文档元素设置属性。</p><p>第二种方式时更新并且更通用，是将事件处理程序传递给对象或元素。复杂的是，每种技术都有两个版本，可以在JavaScript代码中设置事件处理程序为对象属性，或对于文档元素，可以在HTML中直接设置相应属性。</p><p>对于通过方法调用的处理程序注册，有一个标准方法，命名为<strong>addEventListener()</strong>,除IE8及以前版本之外，所有浏览器都支持这种方式，而IE9之前的版本支持的是一个叫attachEvent()的不同方法。</p><h3 id="设置JavaScript对象属性为事件处理程序"><a href="#设置JavaScript对象属性为事件处理程序" class="headerlink" title="设置JavaScript对象属性为事件处理程序"></a>设置JavaScript对象属性为事件处理程序</h3><p>注册事件处理程序最简单的方式就是通过设置目标的属性为所需事件处理程序函数。按照约定，事件处理程序属性的名字由”on”后面跟着事件名称组成:onclick、onchange、onload、onmouseover等。</p><h3 id="设置HTML标签属性为事件处理程序"><a href="#设置HTML标签属性为事件处理程序" class="headerlink" title="设置HTML标签属性为事件处理程序"></a>设置HTML标签属性为事件处理程序</h3><p>HTML5规范章程草案定义了这类事件处理程序的完整列表：</p><p> onafterprint onfocus  oninline  onresize<br> onbeforeprint onhashchange onpagehide onstorage<br> onbeforeunload onload  onpageshow  onundo<br> onblur  onmessage  onpopstate  onunload<br> onerror  onnoffline  onredo</p><p><strong>程序员应该谨记这条规则：禁止(或至少避免)使用HTML事件处理程序属性，因为这些属性直接混合了JavaScript和HTML</strong></p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h3><p>除IE8及之前版本之外的所有浏览器都支持的标准事件模型中，任何能成为事件目标的对象——这些对象包括Window对象、Document对象和所有文档元素都定义了一个名叫addEventListener()的方法。使用这个方法可以为事件目标注册事件处理程序。</p><p>相对addEventListener()的是removeEventListener()方法。同样接受三个参数，从对象中删除事件处理程序。</p><h3 id="attachEvenet"><a href="#attachEvenet" class="headerlink" title="attachEvenet()"></a>attachEvenet()</h3><p>IE9之前不支持addEventListener()和removeEventListener()。IE5及以后版本定义了类似的attachEvent()和detachEvent()。</p><p>attachEvent()和detachEvent()方法的工作原理与addEventListener()和removeEventListener()类似，但也有如下区别:</p><ul><li>因为IE事件模型不支持事件捕获，所有attachEvent()和detachEvent()要求只有两个参数：事件类型和处理程序函数。</li><li>IE方法的第一个参数使用了带”on”前缀的事件处理程序属性名，而非没有前缀的事件类型。例如，当给addEventListener()传递”click”时，要给attachEvent()传递”onclick”。</li><li>attachEvent()允许相同的事件处理程序函数注册多次。当特定的事件类型发生时，注册函数的调用次数和注册次数一样。</li></ul><h2 id="事件处理程序的调用"><a href="#事件处理程序的调用" class="headerlink" title="事件处理程序的调用"></a>事件处理程序的调用</h2><p>一旦注册了事件处理程序，浏览器会在指定的对象上发生指定类型事件时自动调用它。</p><h3 id="事件处理程序的参数"><a href="#事件处理程序的参数" class="headerlink" title="事件处理程序的参数"></a>事件处理程序的参数</h3><p>通常调用事件处理程序时把事件对象作为它们的一个参数(有一个例子，后面会介绍)。事件对象的属性提供了有关事件的详细信息。例如：type属性指定了发生的事件类型。</p><p>IE8及以前版本中，通过设置属性注册事件处理程序，当调用它们时并未传递事件对象。取而代之地通过window.event来获取事件对象。处于互通性，你能像下面这样书写事件处理程序。</p><p> function handler(event){<br>  event &#x3D; event || window.event;<br>  &#x2F;&#x2F;处理程序代码出现在这里<br> }<br>向使用attachEvent()注册的事件处理程序传递事件对象，但它们也能使用window.event。</p><p>当通过设置HTML属性注册事件处理程序时，浏览器会把JavaScript编码转换到一个函数中。非IE浏览器使用event参数来构造函数，而IE在构造函数时没有要求参数，如果在这样的函数中使用event标识符，那么引用的正式window.event。在这两种情况下，HTML事件处理程序都能作为event引用事件对象。</p><h3 id="事件处理程序的运行环境"><a href="#事件处理程序的运行环境" class="headerlink" title="事件处理程序的运行环境"></a>事件处理程序的运行环境</h3><p>当通过设置属性注册事件处理程序时，看起来像在文档上定义了新方法：</p><p> e.onclick &#x3D; function(){&#x2F;<em>处理程序代码</em>&#x2F;};<br>事件处理程序在事件目标上定义，所以它们作为这个对象的方法来调用，并不出人意料，在事件处理程序内，this关键字指的是事件目标。</p><p>甚至当使用addEventListener()注册时，调用的处理程序使用事件目标作为它们的this值。但是对于attchEvent()来说，这就是不对的，使用attachEvent()注册的处理程序作为函数调用，它们的this值时全局(Window)对象。</p><p> &#x2F;*</p><ul><li>在指定的事件目标上注册用于处理指定类型事件的处理程序函数</li><li>确保处理程序一直作为事件目标的方法调用<br> *&#x2F;<br> function addEvent(target,type,handler){<br>if(target.addEventListener)<br> target.addEventListener(type,handler,false);<br>else<br> target.attachEvent(“on”+type,function(event){<br>   &#x2F;&#x2F;把处理程序作为事件目标的方法调用<br>   &#x2F;&#x2F;传递事件对象<br>   return handler.call(target,event);<br> });<br> }</li></ul><h3 id="事件处理程序的作用域"><a href="#事件处理程序的作用域" class="headerlink" title="事件处理程序的作用域"></a>事件处理程序的作用域</h3><p>像所有的JavaScript函数一样，事件处理程序从词法上讲也是作用域。它们在其定义时的作用域而非调用时的作用域执行。并且它们能存取那个作用域中任何一个本地变量。</p><h3 id="事件处理程序的返回值"><a href="#事件处理程序的返回值" class="headerlink" title="事件处理程序的返回值"></a>事件处理程序的返回值</h3><p>通过设置对下岗属性或HTML属性注册事件处理程序的返回值有事时非常有意义的，通常情况下，返回值false就是告诉浏览器不要执行这个事件相关的默认操作。例如表单提交按钮的onclick事件处理程序能返回false阻止浏览器提交表单。(当用户是输入验证失败时使用)</p><p>Window对象的onbeforeunload事件处理程序的返回值也非常有意义。当浏览器将要跳转到新页面时触发这个事件。如果事件处理程序返回一个字符串，那么它将出现在询问客户是否想离开当前页面的标准对话框中。</p><h3 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h3><p>文档元素或其他对象可以为指定事件类型注册多个事件处理程序。当适当的事件发生时，浏览器必须按照如下规则调用所有事件处理程序：</p><ul><li>通过设置对象属性或HTML属性注册的处理程序优先调用。</li><li>使用addEventListener()注册的处理程序按照它们的注册顺序调用</li><li>使用attachEvent()注册的处理程序可能按照任何顺序调用，所以代码不应该依赖与调用顺序。</li></ul><h3 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h3><p>当事件目标是Window对象或其他一些单独对象时，浏览器简单地通过调用对象上适当地处理程序响应事件。当目标时文档或文档元素时，情况比较复杂。</p><p>在调用在目标元素上的事件处理函数后，大部分事件会”冒泡”到DOM树根。调用目标的父元素的事件处理程序，然后调用在目标的祖父元素上注册的事件处理程序。</p><p>发生在文档元素上的大部分事件都会冒泡，值得注意的例外是focus、blur和scroll事件。文档元素上的load事件会冒泡，但它不会在Document对象上停止冒泡而不会传播到Window对象。</p><p>js的事件时向上传播的。</p><p> $(“div”).click(function(event) {<br>     alert(“div clicked”);<br> });</p><p> $(“p”).click(function(event) {<br>     alert(“p clicked”);<br> });</p><p> $(“span”).click(function(event) {<br>     alert(“span clicked”);<br> });</p> <div>     <p>hello, <span>world!</span> </div><p>如果点击world，会一次弹出三个框”span clicked“，”p clicked“，”div clicked“。因为在点击span的时候，span的click事件向上传播到p的onclick函数里，然后再向上传播到div的onclick函数里。</p><p>如果点击hello，会一次弹出两个框”p clicked“，”div clicked“。因为在点击p的时候，p的click事件向上传播到div的onclick函数里。</p><p>如果点击div，就只会一次弹出一个框”div clicked“。</p><p>解决事件向上传播(冒泡)的方法:</p><ul><li><p>return false;</p><p>$(“div”).click(function(event) {<br>alert(“div clicked”);<br>});</p><p>$(“p”).click(function(event) {<br>alert(“div clicked”);<br>return false;<br>});</p><p>$(“span”).click(function(event) {<br>alert(“span clicked”);<br>return false;<br>});</p></li><li><p>event.target来识别判断</p><p>$(“div”).click(function(event) {<br>if (event.target &#x3D;&#x3D; this)<br>    alert(“div clicked”);<br>});  </p><p>$(“span”).click(function(event) {<br>if (event.target &#x3D;&#x3D; this)<br>alert(“span clicked”);<br>});  </p><p>$(“span”).click(function(event) {<br>alert(“span clicked”);<br>});</p></li><li><p>调用even.stopPropagation()方法</p><p>$(“div”).click(function(event) {<br>alert(“div clicked”);<br>});<br>$(“span”).click(function(event) {<br>alert(“span clicked”);<br>event.stopPropagation();<br>});</p></li></ul><h3 id="事件取消（即是上面中的阻止冒泡的三种方法达到的目的）"><a href="#事件取消（即是上面中的阻止冒泡的三种方法达到的目的）" class="headerlink" title="事件取消（即是上面中的阻止冒泡的三种方法达到的目的）"></a>事件取消（即是上面中的阻止冒泡的三种方法达到的目的）</h3><p>(略查看上面的三种方法)</p><h2 id="文档加载事件"><a href="#文档加载事件" class="headerlink" title="文档加载事件"></a>文档加载事件</h2><p>大部分Web应用都需要Web浏览器通知它们文档加载完毕和为操作准备就绪的时间。Window对象的load事件就是为了这个目的，当文档加载解析完毕且所有延迟(deferred)脚本都执行完毕时会触发DOMContentLoade事件，此时图片和异步(async)脚本可能依旧再加载，但是文档已经操作准备就绪了。</p><p>FF引入了这个事件，然后它被包括Microsoft的IE9在内的所有其他浏览器厂商采用，尽管其名字中有DOM,但HTML5标准化了它。</p><p>document.readState属性随着文档加载过程而变。在IE中，每次状态改变都伴随着Document对象上的readystatechange事件，当IE接受到”complete”状态时使用这个事件来做判断是可行的。</p><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><p>与鼠标相关的事件有不少，除了”mouseenter”和”mouseleave”外的所有事件都能冒泡。链接和提交按钮上的click事件都是默认操作且能够阻止。可以取消上下文菜单事件来阻止显示上下文菜单。但一些浏览器有配置选项导致不能取消上下文菜单。</p><ol><li>click：   高级事件，当用户按下并释放鼠标按键或其他方式”激活元素时触发”</li><li>contextmenu: 可以取消的事件，当上下文菜单即将出现时触发。当前浏览器在鼠标右击时显示上下文菜单，所有，这个事件也能像click事件那样使用。</li><li>dbclick：  当用户双击鼠标时触发</li><li>mousedown:  当用户按下鼠标按键时触发</li><li>mouseup：  当用户释放鼠标按键时触发</li><li>mousemove：  当用户移动鼠标时触发</li><li>mouseover：  当鼠标进入元素时触发</li><li>mouseout：  当鼠标离开元素时触发</li><li>mouseenter：  类似”mouseover”,但不冒泡</li><li>mouseleave：  类似”mouseout”,但不冒泡</li></ol><h2 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h2><p>所有现代浏览器都支持鼠标滚轮，并在用户滚动滚轮时触发事件。浏览器通常使用鼠标滚轮滚动或缩放文档，但可以通过取消mousewheel事件来阻止这些默认操作。</p><h2 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h2><p>拖放(Drag-and-Drop)实在”拖放源(drag source)”和”拖放目标(drop target)”之间传输数据的用户界面，它可以存在相同应用也是不同应用之间。拖放是复杂的人机交互，用于实现拖放的API总是很复杂：</p><ul><li>它们必须与底层OS结合，使它们能够在不相关的应用间工作。</li><li>它们必须适用于”移动”、”复制”、”链接”数据传输操作，允许拖放源和拖放目标通过设置限制允许的操作，然后让用户选择(通常使用键盘辅助键)许可设置</li><li>它们必须为拖放源提供一种方式指定待拖动的图标或图像</li><li>它们必须为拖放源和拖放目标的交互提供基于事件的通知。</li></ul><p>见源码第十七章17-4自定义时间拖放。</p><h2 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h2><p>浏览器有3个传统的键盘输入事件。keydown事件是低级事件，keypress事件是较高级的事件，它产生了一个可打印字符。</p><p>建议中的textinput事件和已经实现的textInput事件都传递一个简单的事件对象，它有一个用于保存输入文本的data属性。(另一个属性inputMethod是建议用于指定输入源，但它尚未实现)。</p><p>通过keypress事件传递的对象更加混乱。一个keypress事件表示输入的单个字符。事件对象以数字Unicode编码的形式指定字符，所以必须用String.fromCharCode()把它转换成字符串。</p><p>示例见源码17-7使用propertychange事件探测文本输入</p><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>当用户在键盘上按下或释放按键时，会发生keydown和keyup事件，它们由辅助键、功能键和数字键产生，如果用户按键事件足够长会导致它开始重复，那么在keyup事件到达之前会收到多个keydown事件。</p><p>这些事件对象都有数字属性keyCode，指定了按下的键是哪个。</p><p>无论shift键处于什么状态，子母键总是产生大写keyCode值，这是因为它们出现在物理键盘上。</p><p>类似鼠标事件对象，键盘事件对象由altKey、ctrlKey和shiftKey属性，当事件发生时，如果对应的辅助键被按下，那么它们会被设置为true。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本化CSS</title>
    <link href="/2021/04/12/JavaScript-sixteen/"/>
    <url>/2021/04/12/JavaScript-sixteen/</url>
    
    <content type="html"><![CDATA[<h1 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h1><p>层叠样式表(Cascading Style Sheet,CSS)是一种指定HTML文档视觉表现的标准。CSS的本意是想让视觉设计师来使用的。它允许设计师精确地指定文档元素的字体、颜色、外边距、缩进、边框甚至是定位。</p><p>想要理解CSS脚本化，我们必须熟悉CSS基础和最常用的样式属性。</p><h2 id="CSS概览"><a href="#CSS概览" class="headerlink" title="CSS概览"></a>CSS概览</h2><p>HTML文档的视觉显示包含很多变量：字体、颜色、间距等。CSS标准列举了这些变量，我们称为样式属性。CSS定义了这些属性以指定字体、颜色、外边距、边框、背景图片、文本对齐方式、元素尺寸和元素位置。为了定义HTML的视觉表现，规定了这些CSS属性的值。为此，紧跟冒号和值，例如：</p><p> font-weight:blod<br>为了全面地描述一个元素的视觉表现，通常需要指定不止一个属性。</p><p> margin-left:10Z%;&#x2F;<em>左边距是页面宽度的10%</em>&#x2F;<br> text-indent:.5in; &#x2F;<em>1&#x2F;2英寸缩进</em>&#x2F;<br> font-size:12pt;&#x2F;<em>字体尺寸12pt</em>&#x2F;<br>如你所见，CSS忽略了”&#x2F;<em>“和”</em>&#x2F;“之间的注释，但是它不支持 “&#x2F;&#x2F;“后面的注释。</p><h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>在CSS中的C代表的就是”层叠”。该术语指示了应用于文档中任何给定元素的样式规则是各个来源的层叠。</p><ul><li>Web浏览器默认样式表</li><li>文档的样式表</li><li>每个独立的HTML元素的style属性</li></ul><p>当然，style属性中的样式覆盖了样式表中的样式。</p><h3 id="CSS历史"><a href="#CSS历史" class="headerlink" title="CSS历史"></a>CSS历史</h3><p>CSS是一个相对较老的标准。CSS1只出了具体的颜色、字体、外边距、边框和一些基本样式。CSS2澄清和更正了CSS2，并且删除了浏览器供应商从未实现的功能。CSS3规范了CSS各种各样的专门化模块。</p><h3 id="非标准属性"><a href="#非标准属性" class="headerlink" title="非标准属性"></a>非标准属性</h3><p>当浏览器厂商实现非标准CSS属性时，它们用属性名前加一个厂商的前缀。</p><p>Firefox使用-moz-，Chrome使用-webkit-，而IE使用-ms-，它们甚至用这种方式来实现将来会标注化的属性。</p><h2 id="CSS重要属性"><a href="#CSS重要属性" class="headerlink" title="CSS重要属性"></a>CSS重要属性</h2><p>对于客户端的程序员来说，最重要的CSS特性是那些指定文档中每个元素的可见性、尺寸和精确定位的属性。</p><p> 属性      描述<br> position   指定元素的定位类型<br> top、left   指定元素上、左边缘的位置<br> bottom、right  指定元素下、右边缘的位置<br> width,height  指定元素的尺寸<br> z-index    指定元素相对于其他重叠元素的”堆叠次序”，定义了元素定位的三个维度<br> display    指定元素是否以及如何显示<br> visibility   指定元素是否可见<br> clip    定义元素的”裁剪区域，只显示元素在区域内的部分”<br> overflow   指定元素比分配的空间要大时的处理方式<br> margin、border、padding 指定元素的空白和边框<br> background   指定元素的背景颜色或图片<br> opacity    指定元素的不透明(或半透明)，它是CSS3的属性，有些浏览器支持，IE中不同</p><h3 id="用CSS定位元素"><a href="#用CSS定位元素" class="headerlink" title="用CSS定位元素"></a>用CSS定位元素</h3><p>position有四个属性值</p><ul><li>static<br> 默认属性。指定元素按照常规的文档内容流(对多数西方语言而言就是从左往右、从上到下)进行定位。静态定位的元素不能用top、left和类似其他属性定位。想要用tlbr(top、left、bottom、right)四个属性定位，必须将此属性设置其他三个值。</li><li>absolute<br> 该值指定元素是相对于它包含的元素进行定位。相对于所有其他的元素，绝对定位的元素是独立定位的，它不是静态定位的元素中文档流的一部分。它的定位，要么是相对于最近的定位祖先元素，要么是相对于文档本身。</li><li>fixed<br> 该值指定元素是相对于浏览器窗口进行定位的。固定定位的元素总是显示在那里，不会随着文档其他部分而滚动。类似于绝对定位的元素，固定定位的元素和所有元素是独立的，它不是文档流的一部分，除了IE6，现代浏览器都支持固定定位。</li><li>relative<br> 当position属性设置为relative，元素按照常规的文档流进行布局，它的定位相对于它文档流中的位置进行调整。系统保留着元素在正常文档流中的空间，不会因为要填充空间而将其各边合拢，也不会将元素从新的位置”推开”。</li></ul><h3 id="第三个维度：z-index"><a href="#第三个维度：z-index" class="headerlink" title="第三个维度：z-index"></a>第三个维度：z-index</h3><p>left、top、right和bottom属性是容器元素二维坐标中指定x和y坐标，z-index属性，定义了第三个维度：它允许指定元素的堆叠次序，并指示两个或多个重叠元素中的哪一个应该绘制在其他的上面。</p><h3 id="边框、外边框和内边距"><a href="#边框、外边框和内边距" class="headerlink" title="边框、外边框和内边距"></a>边框、外边框和内边距</h3><p>border表示边框，margin表示外边框padding表示内边距</p><h3 id="文件显示和可见性"><a href="#文件显示和可见性" class="headerlink" title="文件显示和可见性"></a>文件显示和可见性</h3><p>两个CSS属性影响了文档的可见性：visibility和display。visibility属性很简单，当其值为hidden时，该元素不显示；当其值设置为visible时，该元素显示。而display设置为none时，受影响的元素将不显示，甚至根本没有布局。</p><p>visibility和display 属性之间的差别可以从它们对使用静态或相对定位的元素的影响中看到。对于一个常规布局流中的元素，设置visibility属性为hidden使得元素不可见，但是在文档布局中人保留了它的空间。类似的元素可以重复隐藏和显示而不改变文档布局，它各边的元素会合拢，就当它从来不存在。</p><p>visibility和display属性对绝对定位和固定定位的元素的影响是等价的，因为这些元素都不是文档流的一部分。热庵后在隐藏和显示定位元素时一般首选visibility属性。</p><h3 id="颜色、透明度和般透明度color-RGB-opacity"><a href="#颜色、透明度和般透明度color-RGB-opacity" class="headerlink" title="颜色、透明度和般透明度color,RGB,opacity"></a>颜色、透明度和般透明度color,RGB,opacity</h3><p>可以通过CSS的color属性指定文档元素包含的文本颜色。</p><p> opactity:.75; &#x2F;<em>透明度，CSS3</em>&#x2F;<br> filter:alpha(opacity &#x3D;  75); &#x2F;<em>IE透明度设置</em></p><h3 id="部分可见：overflow和clip"><a href="#部分可见：overflow和clip" class="headerlink" title="部分可见：overflow和clip"></a>部分可见：overflow和clip</h3><p>visibility属性可以让文档元素完全隐藏，而overflow和clip属性允许只显示元素的一部分。overflow属性指定内容超出元素的大小时该如何显示。</p><ul><li>visible<br> 默认值，如果需要，内容可以溢出并绘制在元素的边框外面。</li><li>hidden<br> 裁减掉和隐藏溢出的内容，即在元素尺寸和定位属性值定义的区域外不会绘制内容</li><li>scroll<br> 元素显示水平和垂直滚动条。如果内容超出元素尺寸，允许用户通过滚动条来查看额外的内容。此属性值负责文档在计算机屏幕中的显示。</li><li>auto<br> 滚动条只在内容超出元素尺寸时显示</li></ul><p>clip属性的值指定了元素的裁剪区域。裁剪区域是矩形，不过clip属性的语法预留了开放的可能。</p><p> clip:rect(top right bottom left)；<br>相对于元素的边框的左上角,top、right、bottom、left四个值指定了裁剪矩形的边界。</p><h2 id="脚本化内联样式"><a href="#脚本化内联样式" class="headerlink" title="脚本化内联样式"></a>脚本化内联样式</h2><p>脚本话CSS最直接了当的方法就是更改单独的文档元素的style属性。类似大多数HTML属性，style也是元素对象的属性，它可以在JavaScript中操作。但是style属性不同寻常：它的值不是字符串，而是一个CSSStyleDeclaration对象。该style对象的JavaScript属性代表了HTML代码中通过style指定的CSS属性。</p><p> e.style.fontSize &#x3D; “24pt”;<br> e.style.fontWeight &#x3D; “bold”;<br> e.style.color &#x3D; “blue”;<br>注意：CSSStyleDeclaration对象中的属性名和实际的CSS属性名有所区别。如果一个CSS中的属性名是-链接的字符。则CSSStyleDeclaration属性名的格式是移除连字符，使用驼峰命名法。</p><h3 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h3><p>脚本化的CSS最常见的用途之一是产生视觉动画效果。使用setTimeout()或setInterval()重复调用函数来修改元素的内联样式达到目的。</p><h2 id="查询计算出的样式"><a href="#查询计算出的样式" class="headerlink" title="查询计算出的样式"></a>查询计算出的样式</h2><p>元素的style属性代表了元素的内联样式，它覆盖所有的样式表，它是设置CSS属性值来改变元素的视觉表现最好的地方。但是，它在查询元素实际应用的样式时用处不大。</p><p>用浏览器窗口对象的getComputedStyle()方法来获取一个元素的计算样式。此方法的第一个参数就是要获取其计算样式的元素，第二个参数也是必需的，通常是null或空字符串，但它也可以是命名CSS伪类对象的字符串，如”:before”、”:after”、”:first-line”或”:first-letter”。</p><p> var title &#x3D; document.getElementById(“section1title”);<br> var titlestyles &#x3D; window.getComputedStyle(element,null);<br>getComputedStyle()方法的返回值是一个CSSStyleDeclaration对象，它代表了应用在指定元素(或伪对象)上的所有样式。</p><h2 id="脚本化CSS类"><a href="#脚本化CSS类" class="headerlink" title="脚本化CSS类"></a>脚本化CSS类</h2><p>通过内联style属性脚本化CSS样式的一个可选方案是脚本化HTML的class属性值。改变元素的class就改变了应用于元素的一组样式表选择器，它能在同一时刻改变多个CSS属性。</p><p>HTML元素可以有多个CSS类名，class属性保存了一个用空格隔开的类名列表。className属性是一个容易误解的名字：classNames可能更好。上面的函数假设className属性只指定零个或一个类名，如果有多个类名就无法工作了。</p><h2 id="脚本化样式表"><a href="#脚本化样式表" class="headerlink" title="脚本化样式表"></a>脚本化样式表</h2><p>到目前为止，我们已经看到如何设置和查询CSS样式和单个元素的类名。脚本化样式表当然也是可能的。虽然不经常这么做，但偶尔这却非常有用。</p><p>脚本化样式表时，将会碰到两类需要使用的对象。</p><p>第一类是元素对象，由<code>&lt;style&gt;</code>和<code>&lt;lin&gt;</code>元素表示。两种元素包含或引用样式表。这些事常规的文档元素，如果它们由id属性值，可以用document.getElementById()函数来选择它们。</p><p>第二类是CSSStyleSheet对象，它表示样式表本身，document.styleSheets属性是一个只读的类数组对象，它包含CSSStyleSheet对象，表示与文档关联在一起的样式表。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脚本化文档</title>
    <link href="/2021/04/11/JavaScript-DOM/"/>
    <url>/2021/04/11/JavaScript-DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="脚本化文档"><a href="#脚本化文档" class="headerlink" title="脚本化文档"></a>脚本化文档</h1><h2 id="DOM概览"><a href="#DOM概览" class="headerlink" title="DOM概览"></a>DOM概览</h2><p>文档对象模型(DOM)是表示和操作HTML和XML文档内容的基础API。API不是特别复杂，但是需要理解大量的结构细节。首先，应该理解HTML或XML文档的嵌套元素在DOM树对象的表示。HTML文档的树状结构包含表示HTML标签或元素和表示文本字符串的节点，它也可能包含表示HTML注释的节点。</p><h2 id="选取文档的元素"><a href="#选取文档的元素" class="headerlink" title="选取文档的元素"></a>选取文档的元素</h2><p>大多数客户端JavaScript程序运行时总是在操作一个或多个文档元素。当这些程序启动时，可以使用全局变量document来引用Document对象。但为了操作文档元素，必须通过某种方式获取这些引用文档元素的Element对象。DOM定义许多方式来选取元素，查询文档的一个或多个元素有如下方法;</p><ul><li>用指定的id属性;</li><li>用制定的name属性；</li><li>用指定的标签名字;</li><li>用指定的CSS类；</li><li>匹配指定的CSS选择器。</li></ul><h3 id="通过ID选取元素"><a href="#通过ID选取元素" class="headerlink" title="通过ID选取元素"></a>通过ID选取元素</h3><p>任何HTML元素可以有一个id属性，在文档中该值必须唯一。</p><p> var section1 &#x3D; document.getElementById(“section1”);<br>在低于IE8版本的浏览器中，getElemnetById（）对匹配元素的ID不区分大小写，而且也返回匹配name属性的元素。</p><h3 id="通过名字选取元素"><a href="#通过名字选取元素" class="headerlink" title="通过名字选取元素"></a>通过名字选取元素</h3><p>HTML的name属性最初打算为表单元素分配名字，在保单数据提交到服务器时，使用该属性的值。类似id属性，name是给元素分配名字，但是区别与id，name属性的值不是必须唯一：多个元素可能有相同的名字，在表单中，单选和复选按钮通常是这种情况。</p><p> var radiobuttons &#x3D; document.getElementsByName(“favorite_color”);</p><h3 id="通过标签选取元素"><a href="#通过标签选取元素" class="headerlink" title="通过标签选取元素"></a>通过标签选取元素</h3><p>Document对象的getElementsByTagName()方法可用来选取指定类型(标签名)的所有HTML或XML元素。</p><p> var spans &#x3D; document,getElementsByTagName(“span”);</p><p> var firstpara &#x3D; document.getElementsByTagName<a href="0">“p”</a>;</p><h3 id="通过CSS类选取元素"><a href="#通过CSS类选取元素" class="headerlink" title="通过CSS类选取元素"></a>通过CSS类选取元素</h3><p>HTML文档和HTML元素上都可以调用getElementsByClassName()，它的返回值是一个实时的NodeList对象，包含文档或元素所有匹配的后代节点。getElementsByClassName()只需要一个字符串参数，但是该字符串可以由多个空格隔开的标识符组成。只有当元素class属性值包含所有指定的标识符时才匹配。</p><p> &#x2F;&#x2F;查找其class属性值中包含”warning”的所有元素<br> var warnings &#x3D; document.getElementsByClassName(“warning”);<br> &#x2F;&#x2F;查找以”log”命名并且有”error”和”fatal”类的元素的所有后代<br> var log &#x3D; document.getElementById(“log”);<br> var fatal &#x3D; log.getElementsByClassName(“fatal error”);</p><h3 id="通过CSS选择器选取元素"><a href="#通过CSS选择器选取元素" class="headerlink" title="通过CSS选择器选取元素"></a>通过CSS选择器选取元素</h3><p>CSS样式表有一种非常强大的语法，那就是选择器，它用来描述文档中的若干或多组元素。CSS选择器语法的全部细节介绍超出了本书的范围，但是这里有一些例子来说明基本的语法。元素可以用ID、标签或类来描述：</p><p> #nav  &#x2F;&#x2F;id&#x3D;”nav”的元素<br> div   &#x2F;&#x2F;所有<div>元素<br> .warning &#x2F;&#x2F;所有在class属性值中包含了”warning’的元素<br>更一般地，元素可以基于属性值来选取：</p><p> p[lang&#x3D;”fr”]  &#x2F;&#x2F;所有使用语法的段落，如:<p lang="fr"><br> *[name&#x3D;”x”]   &#x2F;&#x2F;所有包含name&#x3D;”x”属性的元素<br>这些基本的选择器可以组合使用：</p><p> span.fatal.error   &#x2F;&#x2F;class中包含”fatal”和”error”的所有<span>元素<br> span[lang&#x3D;”fr”].warning&#x2F;&#x2F;所有使用语法的且其中class中包含”warning”的<span>元素<br>选择器可以指定文档结构：</p><p> #log span  &#x2F;&#x2F;id&#x3D;”log”元素的后代元素中所有<span>元素<br> #log &gt; span &#x2F;&#x2F;id&#x3D;”log”元素的子元素中的所有<span>元素<br> body&gt;h1:first-child &#x2F;&#x2F;<body>中的子元素中的第一个h1元素<br>获取匹配一个给定选择器的元素的JavaScript方法。该API的关键是Document方法querySelectorAll()。它接受包含一个CSS选择器的字符串参数，返回一个表示文档中匹配选择器的所有NodeList对象。与前面描述的选取元素的方法不同，querySelectorAll()返回的NodeList对象并不是实时的：它包含在调用时刻选择器所匹配的元素，但它并不更新后续文档的变化。如果没有匹配的元素，querySelectorAll()将返回一个空的NodeList对象。如果选择器字符串非法，querySelectorAll()将抛出一个异常。</p><p>所有当前的浏览器都支持querySelector()和querySelectorAll()方法。但是注意，这些方法的规范并不要求支持CSS3选择器：鼓励浏览器支持和在样式表中一样的选择器集合。</p><h2 id="文档结构和遍历"><a href="#文档结构和遍历" class="headerlink" title="文档结构和遍历"></a>文档结构和遍历</h2><p>一旦从文档中选取了一个元素，有时需要查找文档中与之在结构上相关的部分(父亲、兄弟和子女)。文档从概念上可以看做是一颗节点对象树。</p><h3 id="作为父节点树的文档"><a href="#作为父节点树的文档" class="headerlink" title="作为父节点树的文档"></a>作为父节点树的文档</h3><p>Documenet对象、它的Element对象和文档中表示文本的Text对象都是Node对象。Node定义了一下重要的属性：</p><ul><li>parentNode</li></ul><p> 该节点的父亲节点，或针对类似Document对象应该是null，因为它没有父亲节点。</p><ul><li>childNodes</li></ul><p> 只读的类数组对象(NodeList对象)，它是该节点的子节点的实时表示。</p><ul><li>firstChild、lastChild</li></ul><p> 该节点的子节点中的第一个和最后一个，如果该节点没有子节点则为null。</p><ul><li>nextSibling、previoursSibling</li></ul><p> 该节点的兄弟节点中的前一个和下一个。具有相同父节点的两个节点为兄弟节点。节点的顺序反映了它们在文档中出现的顺序。这两个属性将节点之间以双向链表的形式链接起来。</p><ul><li>nodeType</li></ul><p> 该节点的类型。9代表Document节点，1代表Element节点，3代表Text节点，8代表Comment节点，11代表DocumentFragment节点。</p><ul><li>nodeValue</li></ul><p> Text节点或Comment节点的文本内容。</p><ul><li>nodeName</li></ul><p> 元素的标签名，以大写形式表示</p><h3 id="作为元素树的文档"><a href="#作为元素树的文档" class="headerlink" title="作为元素树的文档"></a>作为元素树的文档</h3><p>将文档看做是Element对象树，忽略部分文档，Text和Comment节点。</p><p>基于元素的文档遍历API的第二部分是Element属性，后者类似Node对象的子属性和兄弟属性:</p><ul><li>firstElementChild,lastElementChild</li></ul><p> 类似firstChild和LastChild，但只代表子Element</p><ul><li>nextElementSibling,previousElementSibling</li></ul><p> 类似nextSibling和previousSibling但只代表兄弟Element。</p><ul><li>childElementCount</li></ul><p> 子元素的数量。返回的值和children.length值相等。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>HTML元素由一个标签和一组称为属性(attribute)的名&#x2F;值对组成。DOM还定义了另外的API来获取或设置XML属性值和非标准的HTML属性。</p><h3 id="HTML属性作为Element的属性"><a href="#HTML属性作为Element的属性" class="headerlink" title="HTML属性作为Element的属性"></a>HTML属性作为Element的属性</h3><p>表示HTML文档元素的HTMLElement对象定义了读&#x2F;写属性，它们映射了元素的HTML属性。HTMLElement定义了通用的HTTP属性。<br>例如：查询一张图片的URL，可以使用表示&lt;img&gt;元素的HTMLElement对象的src属性：</p><p> var img &#x3D; document.getElementById(“myimage”);<br> var imgurl &#x3D; img.src;&#x2F;&#x2F;src属性是图片的URL<br> img.id &#x3D;&#x3D;&#x3D; “myimage”  &#x2F;&#x2F;判定要查找图片的id<br>同样的，可以为一个&lt;form&gt;表单元素设置表单提交属性:</p><p> var f &#x3D; document.forms[0]; &#x2F;&#x2F;文档中的第一个<form><br> f.action &#x3D; “<a href="http://wwww.example.com/submit.do&quot;;//%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E8%87%B3%E7%9A%84URL">http://wwww.example.com/submit.do&quot;;//设置提交至的URL</a><br> f.method &#x3D; “POST”;  &#x2F;&#x2F;HTTP请求类型<br>HTML属性名不区分大小写，但JavaScript属性名则大小敏感。从HTML属性名转换到JavaScript属性名应该采用小写。但是，如果属性包含不止一个单词，则将除了第一个单词以外的单词的首字母大写。</p><h3 id="获取和设置非标准HTML属性"><a href="#获取和设置非标准HTML属性" class="headerlink" title="获取和设置非标准HTML属性"></a>获取和设置非标准HTML属性</h3><p>HTMLElement和其子类型定义了一些属性，它们对应于元素的标准HTML属性。Element类型还定义了getAttribute()和setAttribute()方法来查询和设置非标准的HTML属性，也可以用来查询和设置XML文档中元素上的属性。</p><p> var image &#x3D; document.images[0];<br> var width &#x3D; parseInt(image.getAttribute(“WIDTH”));<br> image.setAttribute(“class”,”thumbnail”);</p><h3 id="数据集属性"><a href="#数据集属性" class="headerlink" title="数据集属性"></a>数据集属性</h3><p>可以用getAttribute()和setAttribute()来读和写非标准属性的值。但为此付出的代价是文档将不再是合法有效的HTML。</p><h3 id="作为Attr节点的属性"><a href="#作为Attr节点的属性" class="headerlink" title="作为Attr节点的属性"></a>作为Attr节点的属性</h3><p>还有一种使用Element的属性的方法。Node类型定义了attributes属性。针对Element对象的任何节点，该属性为null。对于Element对象，attributes属性是只读的类数组对象。</p><p> document.body.attributes[0]  &#x2F;&#x2F;<body>元素的第一个属性<br> document.body.attributes.bgcolor &#x2F;&#x2F;<body>元素的bgcolor属性<br> document.body.attributes[“ONLOAD”] &#x2F;&#x2F;<body>元素的onload属性<br>当索引attributes对象时得到的值是Attr对象。Attr对象是一类特殊的Node，但从来不会像Node一样去用。Attr的name和value属性返回该属性的名字和值。</p><h2 id="元素的内容"><a href="#元素的内容" class="headerlink" title="元素的内容"></a>元素的内容</h2><ul><li><p>内容是HTML字符串”Thise is a &lt;i&gt;simple &lt;i&gt; document”。</p></li><li><p>内容是纯文本字符串”This is a simple document”。</p></li><li><p>内容是一个Text节点、一个包含了一个Text子节点的Element节点和另外一个Text节点。</p></li></ul><h3 id="作为HTML的元素内容"><a href="#作为HTML的元素内容" class="headerlink" title="作为HTML的元素内容"></a>作为HTML的元素内容</h3><p>Element的innerHTML属性作为字符串标记返回那个元素的内容。</p><p>Web浏览器很擅长解析HTML，通常设置innerHTML效率非常高。甚至在指定的值需要解析时效率也相当不错。</p><h3 id="作为纯文本的元素内容"><a href="#作为纯文本的元素内容" class="headerlink" title="作为纯文本的元素内容"></a>作为纯文本的元素内容</h3><p>有时需要查询纯文本形式的元素内容，或者在文档中插入纯文本(不必转义HTML标记中使用的尖括号和&amp;符号)</p><p> var para &#x3D; document.getElementsByTagName<a href="0">“p”</a>; &#x2F;&#x2F;文档中第一个<p><br> var text &#x3D; para.textContent;   &#x2F;&#x2F;文本是”This is a simple document.”<br> para.textContent &#x3D; “Hello World!”;  &#x2F;&#x2F;修改段落内容<br>textContent除了IE浏览器都支持，在IE中，可以使用Element的innerText属性来代替。</p><h3 id="作为Text节点的元素内容"><a href="#作为Text节点的元素内容" class="headerlink" title="作为Text节点的元素内容"></a>作为Text节点的元素内容</h3><p>还有一种方法处理元素的内容是当做一个子节点列表，每个子节点可能有它自己的一组子节点。当考虑元素的内容时，通常感兴趣的是它的Text的子类型。使用nodeValue。</p><h2 id="创建、插入和删除节点"><a href="#创建、插入和删除节点" class="headerlink" title="创建、插入和删除节点"></a>创建、插入和删除节点</h2><p>我们已经看到了HTML和纯文本字符串如何来查询和修改文档内容，也已经看到我们能够遍历Document来检查组成Document的每一个Element和Text节点。</p><p>Docuement类定义了创建Element和Text对象的方法，Node类型定义了在节点树种插入、删除和替换的方法。</p><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p>可以使用document.createElement()方法。给方法传递元素的标签名，对HTML文档来说不区分大小写。对XML文档区分大小写。</p><p>Text节点用类似的方法创建：</p><p> var newnode &#x3D; document.createTextNode(“text node content”);<br>Document也定义了一些其他的工厂方法，如不经常使用的createComment()和createDocumentFragment()方法。</p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>一旦create出了node节点，就可以使用Node的方法appendChild()或insertBefore()将它插入到文档中。<br>appendChild()是在需要插入的Element节点上调用的。它插入指定的节点使其成为那个节点的最后一个子节点。</p><p>insertBefore()就像appendChild()一样，除了它接受两个参数。第一个参数就是待插入的节点，第二个参数是已存在的节点，新节点将插入该节点的前面。该方法应该是在新节点的父节点上调用，方法第二个的参数必须是父节点的子节点，如果传递null作为第二个参数，insertBefore()的行为类似appendChild()，它将节点插入在最后。</p><h3 id="删除和替换节点"><a href="#删除和替换节点" class="headerlink" title="删除和替换节点"></a>删除和替换节点</h3><p>removeChild()方法实是从文档树中删除一个节点。但是请小心：该方法不是在待删除的节点上调用，而是在其父节点上调用。</p><p>  n.parentNode.removeChild(n);&#x2F;&#x2F;删除自己<br>replaceChild()方法删除一个子节点并用一个新的节点取而代之。在父节点上调用该方法，第一个参数是新节点，第二个参数是需要被代替的节点。</p><p> n.parentNode.replaceChild(document.createTextNode(“[REDACTED]”),n);</p><h3 id="使用DocumentFragment"><a href="#使用DocumentFragment" class="headerlink" title="使用DocumentFragment"></a>使用DocumentFragment</h3><p>DocumentFragment是一种特殊的Node，它作为其他节点的一个临时的容器。像这样创建一个DocumnetFragment:</p><p> var frag &#x3D; document.createDocumentFragment();<br>像Docunment节点一样，DocumnentFragment是独立的，而不是任何其他文档的一部分。它的parentNode总是为null。但类似Element，它可以有任意多的子节点。可以用appendChild()、insertBefore()等方法来操作它们。</p><p><strong>后续的生成目录表、文档和元素的几何形状和滚动、HTML表单、其他文档特性后续会补上。</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Window对象</title>
    <link href="/2021/04/10/JavaScript-Window/"/>
    <url>/2021/04/10/JavaScript-Window/</url>
    
    <content type="html"><![CDATA[<h1 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h1><p>Window对象在客户端的JavaScript中扮演核心角色：它是客户端JavaScript程序的全局对象。</p><h2 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h2><p>setTimeout()和setInterval()可以用来注册在指定的时间之后单次或重复调用的函数。<br>因为它们都是客户端JavaScript中的重要全局函数，所以定义为Window对象的方法，但作为通用函数，其实不会对窗口做什么事情。</p><p>Window对象的setTimeout()方法用来实现一个函数在指定的毫秒数之后运行。</p><p>setTimeout()返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。</p><p>setInterval()和setTimeout()一样，只不过这个函数会在指定毫秒数的间隔里重复调用：</p><p> setInterval(udpateClock,6000);&#x2F;&#x2F;每60秒调用一次updateClock()</p><h2 id="浏览器定位和导航"><a href="#浏览器定位和导航" class="headerlink" title="浏览器定位和导航"></a>浏览器定位和导航</h2><p>Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL，并定义了方法来使窗口载入新的文档。</p><p>Document对象的location属性也引用到Location对象：</p><p> window.location &#x3D;&#x3D;&#x3D; document.location &#x2F;&#x2F;true</p><p>Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串。</p><h3 id="解析URL"><a href="#解析URL" class="headerlink" title="解析URL"></a>解析URL</h3><p>Window对象的location属性引用的是Location对象，它表示该窗口中当前显示的文档的URL。Location对象的href属性是一个字符串，后者包含URL的完整文本。Location对象的toString()方法返回href属性的值，因此在会隐式调用toString()的情况下，可以使用location代替location.href。</p><p>这个对象的其他属性——protocol，host，hostname，port，partname和search。分别表示URL的各个部分。这些是“URL分解”属性。</p><p>Location对象的hash和search属性比较有趣。如果有的话，hash属性返回URL中的”片段标识符”部分。search属性也类似，它返回的是问号之后的URL，这部分通常是某种类型的查询符串。一般来说，这部分内容是用来参数化URL并在其中嵌入参数的。</p><h3 id="载入新的文档"><a href="#载入新的文档" class="headerlink" title="载入新的文档"></a>载入新的文档</h3><p>Location对象的assign()可以使窗口载入并显示你指定的URL中的文档。replace()方法也类似，但它在载入新文档之前会从浏览历史中把当前文档删除。如果脚本无条件地载入一个新文档，replace()方法可能是比assgin()方法更好的选择。</p><p> &#x2F;&#x2F;如果浏览器不支持XMLHttpRequest对象<br> &#x2F;&#x2F;则将其重定向到一个不需要Ajax的静态页面<br> if (!XMLHttpRequest) location.replace(“staticpage.html”);</p><p>这个例子中传入replace()的一个相对URL。相对URL是相当于当前页面所在目录来解析的，就像将它们用于一个超链接中。除了assgin()和replace()方法，Loading对象还定义了reload()方法，后者可以让浏览器重新载入当前文档。</p><p>使用浏览器跳转到新页面的一种更新传统的方法是直接把新的URL赋给location属性：</p><p> location &#x3D; “<a href="http://www.oreilly.com&quot;;//%E5%9C%A8%E6%AD%A4%E7%BD%91%E7%AB%99">http://www.oreilly.com&quot;;//在此网站</a><br> location &#x3D; “page2.html”；&#x2F;&#x2F;载入下一个页面</p><p> location &#x3D; “#top”; &#x2F;&#x2F;跳转到文档的顶部</p><p> location.search &#x3D; “?page&#x3D;” + (pagenum+1);&#x2F;&#x2F;载入下一个页面</p><h3 id="浏览历史"><a href="#浏览历史" class="headerlink" title="浏览历史"></a>浏览历史</h3><p>Window对象的history属性引用的是该窗口的History对象。History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的length属性表示浏览历史列表中的元素数量。</p><p> history.go(-2); &#x2F;&#x2F;后退两个历史记录，相当于单击”后退”按钮两次</p><h2 id="浏览器和屏幕信息"><a href="#浏览器和屏幕信息" class="headerlink" title="浏览器和屏幕信息"></a>浏览器和屏幕信息</h2><p>脚本有时候需要获取和它们所在的Web浏览器或浏览器所在的桌面相关的信息。<br>比如Window对象的navigator和screen属性。它们分别引用的是Navigator和Screen对象。</p><h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><p>Window对象的navigator属性引用的是包含浏览器厂商版本信息的Navigator对象。<br>Navigator对象的命名是为了纪念Netscape之后Navigator浏览器，不过所有其他浏览器也支持它。</p><ul><li>appName</li></ul><p> Web浏览器的全称。IE中，这就是”Microsoft Internet Explorer”。在Firefox中，该属性就是”Netscape”。为了兼容现存的浏览器嗅探代码，其他浏览器通常也取值为”Netscape”。</p><ul><li>appVersion</li></ul><p> 此属性通常以数字开始，并跟着包含浏览器厂商和版本信息的详细字符串。字符串前面的数字通常是4.0或5.0，表示第4或第5带兼容的浏览器。appVersion字符串没有标准的格式，所以，没有办法直接用它来判断浏览器的类型。</p><ul><li>userAgent</li></ul><p> 浏览器在它的USER-AGENT HTTP头部中发送的字符串。这个属性通常包含appVersion中的所有信息没并且常常也可能包含其他的细节。</p><ul><li>platform</li></ul><p> 在其上运行浏览器的操作系统(并且可能是硬件)的字符串。</p><h3 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h3><p>Window对象的screen属性引用的是Screen对象。它提供有关窗口显示的大小和可用的颜色数量的信息。属性withd和height指定的是以像素为单位的窗口大小。</p><p>属性availWidth和availHeight指定的是实际可用的显示大小，它们排除了像桌面任务栏这样的特性所占用的空间。属性colorDepth指定的是显示的BPP值。</p><p>window.screen属性和它引用的Screen对象都是非标准但广泛实现的。</p><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>Window对象提供了3个方法来向用户显示简单的对话框。</p><p>alert()向用户显示一条消息并等待用户关闭对话框。</p><p>comfirm()也是显示一条消息，要求用户单击”确定”或”取消”按钮，并返回一个布尔值。</p><p>prompt()同样也显示一条消息，等待用户输入字符串，并返回那个字符串。</p><p>尽管alert()、confirm()和prompt()方法都很容易使用，但是良好的设计还是需要有节制地使用它们。<br>除了这三个以外，还要一个更复杂的方法showModalDialog()。显示一个包含HTML格式的”模态对话框”，可以给它传入参数。以及从对话框里面返回值。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Window对象的onerror属性是一个事件处理程序，当未捕获的异常传播到调用栈上时就会调用它，并把错误消息输出到浏览器的JavaScript控制台上。如果给这个属性赋一个函数，那么只要这个窗口中发生了JavaScript错误，就会调用该函数，即它成了窗口的错误程序。</p><p> &#x2F;在一个对话框中弹出错误消息，但不超过三次<br> window.onerror &#x3D; function(msg,url,line){<br>  if(onerror.num++ &lt; onerror.max){<br>   alert(“ERROR:” + msg + “\n” + url + “:” + line);<br>   return true;<br>  }<br> }<br> onerror.max &#x3D; 3;<br> onerror.num &#x3D; 0;</p><h2 id="作为Window对象属性的文档元素"><a href="#作为Window对象属性的文档元素" class="headerlink" title="作为Window对象属性的文档元素"></a>作为Window对象属性的文档元素</h2><p>如果在HTML文档中用id属性来为元素命名，并且如果Window对象没有此名字的属性，Window对象会赋予一个属性，它的名字是id属性的值，而它们的值指向表示文档元素的HTMLElement对象。</p><p>Window对象是全局对象的形式存在于作用域链的最上层，这就意味着在HTML文档中使用的id属性会成为可以被脚本访问的全局变量。如果文档包含一个&lt;button id&#x3D;”okay” &gt;元素，可以通过全局变量okay来引用元素。</p><p>但是，如果是已经具有此名字的属性，就不会发生如id是”history”、”location”或”navigator”的元素，就不会以全局变量的形式出现。</p><h2 id="多窗口和窗体"><a href="#多窗口和窗体" class="headerlink" title="多窗口和窗体"></a>多窗口和窗体</h2><p>一个Web浏览器窗口可能在桌面上包含多个标签页，每一个标签页都是独立的”浏览上下文”，每一个上下文都有独立的Window对象，而且相互之间互不干扰。</p><h3 id="打开和关闭窗口"><a href="#打开和关闭窗口" class="headerlink" title="打开和关闭窗口"></a>打开和关闭窗口</h3><p>使用Window对象的open()方法可以打开一个新的浏览器窗口(或标签页，这通常和浏览器的配置选项有关)。Window.open()载入指定的URL到新的或已经存在的窗口中，并返回代表那个窗口的Window对象。</p><p>open()的第一个参数是在新文档中显示文档的URL，如果这个参数省略了，或是空字符串，那么就会使用空白页的URL about:blank。</p><p>open()第二个参数是重新打开窗口的名字。如果指定的是一个已经存在的窗口的名字(并且脚本允许跳转到那个窗口)会直接使用已经存在的窗口。否则会打开新的窗口，并将这个指定的名字赋值给它。如果此参数省略，会使用指定的名字”_blank”打开一个新的、未命名的窗口。</p><p>open()第三个可选参数是一个以逗号分隔的列表，包含大小和各种属性，用以表明新窗口是如何打开的。如果省略这个参数，那么新窗口就会用一个默认的大小，而且带有一整组标准的UI组件，即菜单栏、状态栏、工具栏等。</p><p> var w &#x3D; window.open(“Smallwin.html”,”smallwin”,”width&#x3D;400,height&#x3D;350,status&#x3D;yes,resizable&#x3D;yes”);</p><p>open()第四个参数只在第二个参数命名的是一个已经存在的窗口中才有用，它是一个布尔值，声明了由第一个参数指定的URL是应用替换掉窗口浏览历史的当前条目(true),还是应该在窗口浏览历史中创建一个新的条目(false),后者是默认值。</p><p> var w &#x3D; window.open();   &#x2F;&#x2F;打开一个新的空白窗口<br> w.alert(“About to visit htp:&#x2F;&#x2F;example.com”);&#x2F;&#x2F;调用alert()方法<br> w.location &#x3D; “<a href="http://example.com/">http://example.com</a>“; &#x2F;&#x2F;设置它的location属性。</p><p>关闭窗口</p><p>就像方法open()打开一个新窗口一样，方法close()将关闭一个窗口。如果已经创建了window对象w，可以直接使用</p><p> w.close() &#x2F;&#x2F;将w关闭</p><h3 id="窗体之间的关系"><a href="#窗体之间的关系" class="headerlink" title="窗体之间的关系"></a>窗体之间的关系</h3><p>我们已经知道Window对象的方法open()返回代表新建的窗口的Window对象。而且这个新窗口具有opener属性，该属性可以打开它的原始窗口。这样，两个窗口就可以相互引用，彼此都可以读取对方的属性或调用对方的方法。窗体也是这样的。</p><p>任何窗口或窗体中的JavaScript代码都可以将自己的窗口和窗体引用为window或self。窗体可以用parent属性引用包含它的窗口或窗体的Window对象:</p><p> parent.histor.back();<br>如果一个窗口是顶级窗口或标签，而不是窗体，呢么其parent属性引用的就是这个窗口本身：</p><p> parent &#x3D;&#x3D; self;&#x2F;&#x2F;只有顶级窗口才会返回true</p><h3 id="交互窗口中的JavaScript"><a href="#交互窗口中的JavaScript" class="headerlink" title="交互窗口中的JavaScript"></a>交互窗口中的JavaScript</h3><p>每个窗口和窗体都是它自身的JavaScript执行上下文，以Windwo作为全局对象。但是如果一个窗口或窗体中的代码可以应用到其他窗口或窗体，那么一个窗体或脚本就可以和其他窗口或窗体中的脚本进行交互。</p><p>设想一个Web页面里有两个iframe元素，分别叫A和B，并假设这些窗体包含的文档来自同一个服务器，并且包含交互脚本。窗体A里面脚本定义了一个变量i:</p><p> var i &#x3D; 3;<br>这个变量只是全局对象的一个属性，也是Window对象的一个属性。窗体A中的代码可以用标识符i来引用变量，或者用window对象显式地引用这个变量：</p><p> window.i<br>由于B窗体中的脚本可以引用窗体A的Window的对象，因此它也可以引用那个Window对象的属性：</p><p> parent.A.i &#x3D; 4;&#x2F;&#x2F;改变窗体A中的变量i值。</p><p> parent.B.f()&#x2F;&#x2F;调用B窗体中定义的一个函数</p><p> var f &#x3D; parent.B.f;&#x2F;&#x2F;A窗体中使用B窗体的函数f</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>客户端的JavaScript(浏览器中的JavaScript)</title>
    <link href="/2021/04/08/JavaScriptbrowser/"/>
    <url>/2021/04/08/JavaScriptbrowser/</url>
    
    <content type="html"><![CDATA[<h1 id="客户端的JavaScript-浏览器中的JavaScript"><a href="#客户端的JavaScript-浏览器中的JavaScript" class="headerlink" title="客户端的JavaScript(浏览器中的JavaScript)"></a>客户端的JavaScript(浏览器中的JavaScript)</h1><p>之前我们学习了JavaScript的语言核心。以及JavaScript在服务端的应用（简单粗糙的了解），现在，让我们把目光从基础语言核心拿到实际应用上来。</p><p>JavaScript在客户端的应用中，我们会介绍大量的脚本宿主对象，这些对象可以表示浏览器窗口、文档树和文档的内容等。</p><h2 id="客户端JavaScript"><a href="#客户端JavaScript" class="headerlink" title="客户端JavaScript"></a>客户端JavaScript</h2><p>Window对象是所有客户端JavaScript特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符window来引用它。Windo对象定义了一些属性，比如，指代Location对象的location属性，Location对象指定当前显示在窗口中的URL，并允许脚本往窗口里载入新的URL；</p><p> &#x2F;&#x2F;设置location属性，从而跳转到新的Web页面<br> window.location &#x3D; “<a href="http://www.oreilly.com/">http://www.oreilly.com/</a>“;<br>Window对象还定义了一些方法，比如alert(),还有setTimeout(),可以注册一个函数，在给定的一段时间之后触发一个回调；</p><p> &#x2F;&#x2F;等待两秒钟,然后说hello<br> setTimeout(function(){alert(“hello”);},2000);<br>这两个方法，都没有显式地使用window属性。在客户端的JavaScript中，Window对象也是全局对象。这意味着Window对象处于作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。</p><h3 id="Web文档里的JavaScript"><a href="#Web文档里的JavaScript" class="headerlink" title="Web文档里的JavaScript"></a>Web文档里的JavaScript</h3><p>JavaScript程序可以通过Document对象和它包含的Element对象遍历和管理文档内容。它可以通过操作CSS样式和类，修改文档内容的呈现。</p><p>也可以通过注册适当的事件处理程序来定义文档元素的行为。内容、呈现和行为的组合叫做动态HTML或DHTML。</p><p>Web文档里应当少量地使用JavaScript，因为JavaScript真正的角色是增强用户的浏览体验，使信息的获取和传递更容易。用户的体验不应依赖于JavaScript，但JavaScript可以增强体验。</p><p>增强体验的方式有如下三种方式</p><ul><li>创建动画和其他视觉效果，巧妙地引导和帮助用户进行页面导航</li><li>对表格的列进行分组，让用户更容易找到所需要的。</li><li>隐藏某些内容，当用户”深入”到内容里面时，再逐渐展示详细信息。</li></ul><h3 id="Web应用里的JavaScript"><a href="#Web应用里的JavaScript" class="headerlink" title="Web应用里的JavaScript"></a>Web应用里的JavaScript</h3><p>Web浏览器已经有了很好的发展，现在已经不仅仅是作为显示文档的工具角色了，而逐渐变成了一个简易的操作系统。<br>Web浏览器允许在工具栏和文件夹中组织书签(表示文档和Web应用)。系统可以在一个窗口里运行多个应用；</p><p>操作系统定义了很多底层网络API、提供绘制图像、保存文件等功能。Web浏览器也定义了底层网络API、保存数据和绘制图像。</p><p>谨记Web浏览器简单的操作系统的概念，就可以把Web应用定义为用JavaScript访问更多浏览器提供的高级服务（比如网络、图像和数据存储）的Web页面。</p><p>浏览器也有很多其他特性的API，如地理位置信息、历史管理和后台线程。</p><p>JavaScript增强了Web文档，但是设计良好的文档需要在禁用JavaScript后还能继续工作。Web应用本质上就是JavaScript程序，后者使用由Wbe浏览器提供操作系统类型的服务，并且不用期望它们在禁用浏览器脚本后还能正常工作。</p><h3 id="在HTML里嵌入JavaScript"><a href="#在HTML里嵌入JavaScript" class="headerlink" title="在HTML里嵌入JavaScript"></a>在HTML里嵌入JavaScript</h3><p>在HTML文档里嵌入客户端JavaScript代码有4种方法：</p><ul><li>内联，放置在&lt;script&gt;和&lt;&#x2F;script&gt;标签对之间。</li><li>放置在由&lt;script&amp;gt;标签的src属性指定的外部文件中。</li><li>放置在HTML事件处理程序中，该事件处理程序由onclick或onmouseover这样的HTML属性值指定。</li><li>放在一个URL里，这个URL使用特殊的”javascript:”协议。<br>接下来的小节会逐一解释这4中JavaScript前提高技术。但是，HTML事件处理程序属性和JavaScript:URL这两种方式在现在JavaScript代码已经很少使用(它们在Web早期多少有点通用)。</li></ul><h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a>&lt;script&gt;元素</h3><p>JavaScript代码可以以内联的形式出现在HTML文件里&lt;script&gt;和&lt;&#x2F;script&gt;标签之间。会被当做其他内容一样对待。会被解释成XML标记。</p><h3 id="src形式导入"><a href="#src形式导入" class="headerlink" title="src形式导入"></a>src形式导入</h3><p>src的优点：</p><ul><li>可以把大块JavaScript代码从HTML文件中删除，这有助于保持内容和行为的分离，从而简化HTML文件</li><li>如果多个Web页面共用相同的JavaScript代码，用src属性可以让你只管理一份代码，而不用在代码改变时，编辑每一个HTML文件。</li><li>如果一个JavaScript代码文件由多个页面共享，只需要下载它一次，通过使用它的第一个页面——随后的页面可以从浏览器缓存检索它。</li><li>由src属性的值可以是任意的URL，因此，来自一个Web服务器的JavaScript程序或Web页面可以使用由另一个Web服务器输出的代码。很多互联网广告依赖于此。</li><li>从其他网站载入脚本的能力，可以让我们更好地利用缓存。</li></ul><h3 id="HTML中的事件处理程序"><a href="#HTML中的事件处理程序" class="headerlink" title="HTML中的事件处理程序"></a>HTML中的事件处理程序</h3><p>当脚本所在的HTML文件被载入浏览器时，这个脚本里的JavaScript代码只会执行一次。为了交互，JavaScript程序必须定义事件处理程序——Web浏览器先注册JavaScript函数，并在调用它作为事件的响应(比如用户输入)。</p><h3 id="URL中的JavaScript"><a href="#URL中的JavaScript" class="headerlink" title="URL中的JavaScript"></a>URL中的JavaScript</h3> <a href= "javascript:new Date().toLocaleTimeString();">  What time os ot?</a><h2 id="JavaScript程序的执行"><a href="#JavaScript程序的执行" class="headerlink" title="JavaScript程序的执行"></a>JavaScript程序的执行</h2><p>客户端JavaScript程序没有严格的定义。我们可以说JavaScript程序是右Web页面中所包含的所有JavaScript代码(内联脚本、HTML事件处理程序和javas：URL)和通过src引用外部代码组成。所有这些单独的代码共用同一个全局Window对象。这意味着它们可以看到相同的Document对象，可以共享相同的全局函数和变量的集合;如果一个脚本定义了新的全局变量或函数，那么这个变量或函数会在脚本执行之后对任意JavaScript代码可见。</p><p>JavaScript程序的执行有两个阶段。</p><p>第一阶段，载入文档内容，并执行&lt;script&gt;元素离的代码(包括内联脚本和外部脚本)。脚本通常会按照它们在文档里的出现顺序执行。所有脚本里的JavaScript代码都是从上往下，按照它在条件、循环以及其他控制语句中出现的顺序执行。</p><p>第二阶段，这个阶段是异步的，是由事件驱动的。在事件驱动阶段，Web浏览器调用事件处理程序函数(由第一阶段里执行的脚本指定的HTML事件处理程序，或之前调用的事件处理程序来定义)，来响应异步发生的事件。调用事件处理程序通常是响应用户输入(如单击鼠标，键盘按下等)。还可以由网络活动、运行时间或者JavaScript代码中的错误来触发。</p><h3 id="同步、异步和延迟的脚本"><a href="#同步、异步和延迟的脚本" class="headerlink" title="同步、异步和延迟的脚本"></a>同步、异步和延迟的脚本</h3><p>JavaScript第一次添加到Web浏览器时，还没有API可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript影响文档内容的唯一方法是快速生成内容。它使用document.write()方法来完成上述任务。</p><p>脚本的执行只在默认情况下是同步和阻塞的。&lt;script&gt;标签可以有defer和async属性，在浏览器里，可以改变脚本的执行方式，这些都是布尔属性，没有值；直接使用出现即可。<br>defer和async属性就像在告诉浏览器链接进来的脚本不会使用document.write()也不会生成文档内容，因此浏览器可以在下载脚本时继续解析和渲染文档。defer属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。async属性使得浏览器可以尽快地执行脚本，而不用在下载脚本时阻塞文档解析。</p><h3 id="事件驱动的JavaScript"><a href="#事件驱动的JavaScript" class="headerlink" title="事件驱动的JavaScript"></a>事件驱动的JavaScript</h3><p>古老的JavaScript程序是同步载入的程序：在页面载入时开始执行，生成一些输出，然后结束。这种类型的程序在今天已经不常见了。反之，我们通过注册事件处理程序来写程序，之后在注册的事件发生时异步调用这个些函数。</p><p>对于大部分浏览器中的大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息。比如，传递给单击事件的对象，会有一个属性说明鼠标的哪个按钮被单击。</p><h3 id="客户端JavaScript线程模型"><a href="#客户端JavaScript线程模型" class="headerlink" title="客户端JavaScript线程模型"></a>客户端JavaScript线程模型</h3><p>JavaScript语言核心并不包含任何线程机制，并且客户端JavaScript传统上也没有定义任何线程机制。HTML5定义了一种作为后台线程的”WebWorker”,但是客户端JavaScript还像严格的单线程一样工作。甚至可能并发执行的时候，客户端JavaScript也不会知晓是否真的有并行逻辑的执行。</p><h3 id="客户端JavaScript时间线"><a href="#客户端JavaScript时间线" class="headerlink" title="客户端JavaScript时间线"></a>客户端JavaScript时间线</h3><p>我们已经看到了，JavaScript程序从脚本执行阶段开始，然后切换到事件处理阶段。</p><ol><li>Web浏览器创建Document对象，并且返回开始解析Web页面，解析HTML元素和它们的文本内容后添加Element对象和Text节点到文档中。在这个阶段document.readystate属性值是”loading”。</li><li>当HTML解析器遇到没有async和defer属性的&lt;script&gt;元素时，它把这些元素添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行解析器会暂停。这样脚本就可以用document.write()来把文档插入到输出流中。解析器恢复时这些文本会成为文档的一部分。同步脚本经常简单定义函数和注册后面使用的注册事件处理程序，但它们可以遍历和操作文档树，因为在它们执行时已经存在了。</li><li>当解析器遇到设置了async属性的&lt;script&gt;时，它开始下载脚本文本，并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器没有停下等它下载。异步脚本禁止使用document.write()方法。它们可以看到自己的&lt;script&gt;元素和它之前的文档元素，并且可能或干脆可能访问其他的文档内容。</li><li>当文档完成解析，document.readyState属性变成”interactive”。</li><li>所有由defer属性的脚本，会按他么在文档里的出现顺序执行。异步脚本可能也会在这个时间执行。延迟脚本能访问完整的文档树，禁止使用document.write()方法</li><li>浏览器对象上触发DOMContentLoaded事件。这标志着程序执行从同步脚本执行阶段转换到异步事件驱动阶段。但要注意，这时可能还有异步脚本没有执行完成。</li><li>这是，文档已经完全解析完成，但是浏览器可能还在等待其他内容载入，比如图片。当所有这些内容完成载入时，并且所有异步脚本完成载入和执行，document.readyState属性改变为”complete”,Web浏览器触发Window事件对象上的load事件。</li><li>从此刻起，会调用异步事件，以异步响应用户输入事件、网络事件、计时器过期等。</li></ol><p>注：兼容性和互用性、可访问性、安全性、客户端框架，这些后面会单独介绍。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器端JavaScript</title>
    <link href="/2021/04/07/JavaScript-service-use/"/>
    <url>/2021/04/07/JavaScript-service-use/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器端JavaScript"><a href="#服务器端JavaScript" class="headerlink" title="服务器端JavaScript"></a>服务器端JavaScript</h1><h2 id="Rhino脚本话java"><a href="#Rhino脚本话java" class="headerlink" title="Rhino脚本话java"></a>Rhino脚本话java</h2><p>Rhino是一种用java编写的JavaScript解释器，其设计目标是借助强大的java平台API实现轻松编写JavaScript程序。Rhino能自动完成JavaScript原生类型的Java原生类型之间的相互转换，因此JavaScript脚本可以设置、查询java属性并调用java方法。</p><p>Rhino定义了少量重要的全局函数，不过它们都不是JavaScript的核心组成部分。</p><p> &#x2F;&#x2F;特定于嵌入的全局函数：输入help()获取更多的rhino提示<br> print(x);    &#x2F;&#x2F;全局输出函数，将内容输出到控制台<br> version(170);   &#x2F;&#x2F;告诉Rihno需要使用JS 1.7的语言特性<br> load(filename,…);  &#x2F;&#x2F;加载并执行1个或多个JavaScript代码文件<br> readFile(file);   &#x2F;&#x2F;读取文本文件，并以字符串形式返回内容<br> readUrl(url);   &#x2F;&#x2F;读取URL的原文内容，并以字符串的形式返回内容<br> spawn(f);      &#x2F;&#x2F;运行f()或者在一个新线程中加载执行文件f<br> runCommand(cmd,[args…]);&#x2F;&#x2F;使用o或多个命令参数来运行系统命令<br> quit()     &#x2F;&#x2F;退出Rhino</p><p>Rhino会将Java包和类表示成JavaScript对象：</p><p> &#x2F;&#x2F;全局变量packages是Java包层次机构的根<br> Packages.any.package.name  &#x2F;&#x2F;任何来自Java CLASSPATH的包<br> java.lang     &#x2F;&#x2F;全局变量java是Package.java的短名<br> javax.swing    &#x2F;&#x2F;javax是package.javax的短名</p><p> &#x2F;&#x2F;类：能像包的属性一样存取<br> var System &#x3D; java.lang.System;<br> var JFrame &#x3D; javax.swing.JFrame;</p><p>由于Rhino把包和类表示为JavaScript对象，因此可以将它们赋值给变量从而得到相应的短名。如果愿意，也可以正式导入它们：</p><p> var ArrayList &#x3D; java.util.ArrayList;&#x2F;&#x2F;为类创建短名<br> importClass(java.util.HashMap);  &#x2F;&#x2F;其等同于:var HashMap &#x3D; java.util.HashMap</p><p> &#x2F;&#x2F;使用importPackage()导入包(惰性地)<br> &#x2F;&#x2F;不要导入java.lang：太多的名字和JavaScript全局变量有冲突<br> importPackage(java.util);<br> importPackage(java.net);</p><p> &#x2F;&#x2F;另一技术：传入任意数量的类和包给JavaImport()<br> &#x2F;&#x2F;并在with语句中使用它返回的对象</p><p> var guipkgs &#x3D; JavaImporter(java.awt.event,Packages.javax.swing);<br> with(guipks){<br>  &#x2F;<em>这里定义Font、ActionListener和JFrame等类</em>&#x2F;<br> }</p><p> Java类能使用new进行实例化，就像JavaScript类一样:</p><p> &#x2F;&#x2F;对象：使用new实例化Java类<br> var f &#x3D; new java.io.File(“&#x2F;tmp&#x2F;test”);&#x2F;&#x2F;我们将在后面使用这些对象<br> var out &#x3D; new java.io.FileWriter(f);<br>Rhino让JavaScript的instanceof云算符能用于Java对象和类：<br> f instanceof java.io.File   &#x2F;&#x2F; &#x3D;&gt; true<br> out instanceof java.io.Reader  &#x2F;&#x2F; &#x3D;&gt; false:它是Writer而非Reader<br> out instanceof java.io.Closeable &#x2F;&#x2F; &#x3D;&gt; true:Write实现Closeable</p><h2 id="用node实现异步I-x2F-O"><a href="#用node实现异步I-x2F-O" class="headerlink" title="用node实现异步I&#x2F;O"></a>用node实现异步I&#x2F;O</h2><p>Node是基于C++的高速JavaScript解释器，绑定了用于进程、文件和网络套接字等底层Unix API，还绑定了HTTP客户端和服务器API。除了一些专门命名的同步方法外，Node的绑定都是异步的，且Node程序默认绝不阻塞，这意味着它们通常具有强大的可伸缩能力并能有效地处理高负荷。由于API是异步的，因此Node依赖事件处理程序，通常使用嵌套函数和闭包来实现。</p><p>我们之前从print()和load()函数开始介绍Rhino。Node也是类似函数，只是名字不同：</p><p> &#x2F;&#x2F;Node定义了console.log(),可以像在浏览器中那样调试代码输出<br> console.log(“Hello Node”);&#x2F;&#x2F;调试输出到控制台</p><p> &#x2F;&#x2F;使用require()替代load()<br> &#x2F;&#x2F;它加载并执行(只有一次)命名模块，返回包含其导出标示符(exported symbol)的对象<br> var fs &#x3D; require(“fs”);&#x2F;&#x2F;加载”fs”模块，并返回其API对象</p><p>Node 在其全局对象实现了所有标准的ECMAScript5构造函数、属性和函数。除此之外，它也支持客户端的计时器函数集setTimeout()、setInterval()、clearTimeout()和clearInterval():</p><p> &#x2F;&#x2F;1秒钟后输出”Hello World”<br> setTimeout(function(){ console.log(“Hello World”);},1000);</p><p>Node在process名字空间中定义了其他重要的全局属性。这里有该对象的一些属性：</p><p> process.version  &#x2F;&#x2F;Node的版本字符串信息<br> process.argv &#x2F;&#x2F;“node”命令行的数组参数，arfv[0]是”node”<br> process.env  &#x2F;&#x2F;环境变量对象。例如:process.env.PATH<br> process.pid  &#x2F;&#x2F;进程id<br> process.getuid() &#x2F;&#x2F;返回用户id<br> process.cwd() &#x2F;&#x2F;返回当前的工作目录<br> process.chdir() &#x2F;&#x2F;改变目录<br> process.exit() &#x2F;&#x2F;退出(运行shutdown命令之后)<br>由于Node的函数和方法都是异步的，因此，当它们等待运算完成时并不产生阻塞。非阻塞方法的返回值无法返回异步运算的结果给你。如果想要获取结果，或想知道完成运算的时间，当结果准备好或完成运算(或发生错误)时，就必须提供Node能调用的一个函数。</p><p>Node的设计目标示高性能I&#x2F;O,因此其流API常被用到。当数据准备好时，可读流会触发事件。在下面代码中，假设s是在其他地方得到的可读流。下面我们将看到如何从文件和网络套接字中得到流对象。</p><p> &#x2F;&#x2F;输入流s<br> s.on(“data”,f);  &#x2F;&#x2F;当数据可用时，把它作为参数传给f<br> s.on(“end”,f); &#x2F;&#x2F;当不再有数据到达，在文件结束(EOF)时会触发“end”事件<br> s.on(“error”,f) &#x2F;&#x2F;如果发生错误，把异常传给f()<br> s.readable  &#x2F;&#x2F;如果它是依旧打开的可读流，返回true；<br> s.pasus()  &#x2F;&#x2F;“暂停”data事件，例如，为了限制上次上传<br> s.resume();  &#x2F;&#x2F;再次恢复</p><p> &#x2F;&#x2F;如果想把字符串传给”data”事件处理程序，请指定编码<br> s.setEncoding(enc);  &#x2F;&#x2F;如何对字节编码:”utf-8”、”ascii”或”base64”<br>可写流比可读流的核心事件少，使用write()方法发送数据，当所有数据写入完毕后，使用end()方法结束流。write()方法绝不会阻塞。若Node无法立即写入数据而不得不在内部缓存它，则write()方法返回false</p><p> &#x2F;&#x2F;输出流s<br> s.write(buffer);  &#x2F;&#x2F;写入二进制数据<br> s.write(string,encodeing)&#x2F;&#x2F;写入字符串数据，默认编码是”utf-8’<br> s.end()     &#x2F;&#x2F;结束流<br> s.end(buffer);   &#x2F;&#x2F;写入最后的二进制数据块并结束<br> s.end(str,encoding); &#x2F;&#x2F;写入最后的字符串并结束所有流<br> s.writeable;   &#x2F;&#x2F;如果流依旧打开且可写入，返回true<br> s.on(“drain”,f)   &#x2F;&#x2F;当内部缓冲区为空，调用f()<br>如上所示，Node的流能处理二进制数据和文本数据。文本传输使用的是普通JavaScript字符串，字节使用Node特定的缓冲区来处理。Node的缓冲区是有固定长度的类数组对象，其元素数量必须在0~255之间。</p><p>好了，关于JavaScript的服务端，先写这么多，感觉node是越来越火了，后续会对node进行一波学习。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS的子集和扩展</title>
    <link href="/2021/04/06/JavaScript-chidl-and-expand/"/>
    <url>/2021/04/06/JavaScript-chidl-and-expand/</url>
    
    <content type="html"><![CDATA[<h1 id="JS的子集和扩展"><a href="#JS的子集和扩展" class="headerlink" title="JS的子集和扩展"></a>JS的子集和扩展</h1><p>参照ECMAScript3和ECMAScript 5中的标准规范完整地讨论了JavaScript这门官方语言。本章将讨论JavaScript的子集和超集。其中子集的定义大部分都是出于安全考虑，只有使用这门语言的一个安全的子集编写脚本，才能让代码执行得更安全、更稳定，比如如何更安全地执行一段由不可信第三方提供的广告代码。</p><h3 id="JS的子集"><a href="#JS的子集" class="headerlink" title="JS的子集"></a>JS的子集</h3><p>大多数语言都会定义它们的子集，用以更安全地执行不可信的第三方代码。这里有一个很有趣的子集，定义这个子集的原因有些特殊。我们首先来看这个有趣的子集，然后再讨论安全的语言子集。</p><h3 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h3><p>多数编程语言都有精华部分和鸡肋部分，如果只使用精华部分而避免使用鸡肋部分，可以让我们成为更好的程序员。<br>提倡函数定义表达式而不是函数定义语句来定义函数。该子集要求：循环体和条件分支都使用花括号括起来，它不允许在循环体和条件分支中只包含一条语句时省略花括号，任何语句只要不是以花括号结束都应当使用分号做结尾。</p><p>《JavaScript:The Good Parts》中为我们提炼出的子集部分对var语句做了限制，var语句只能出现在函数体的顶部，并要求程序员将函数内所有的变量声明写在一条单独的var语句中，作为函数体的第一条语句。在子集中禁止使用所有全局变量，但这个限制只是编程约定，并不是真正语言上的限制。</p><p>在线代码质量检测工具JSLint，可以通过<a href="http://jslint.com访问这个工具.这个工具提供了很多选项来增强代码的一致性检查.除了确保代码使用了子集推荐的特性之外,jslint工具还对编码风格做了一些强制约定,比如合理的缩进等./">http://jslint.com访问这个工具。这个工具提供了很多选项来增强代码的一致性检查。除了确保代码使用了子集推荐的特性之外，JSLint工具还对编码风格做了一些强制约定，比如合理的缩进等。</a></p><h3 id="子集的安全性"><a href="#子集的安全性" class="headerlink" title="子集的安全性"></a>子集的安全性</h3><p>利用”精华部分”的一个语言子集可以设计出更具美感的程序并提升程序员的开发效率。</p><p>每一个子集都带有一个静态的检查器，可以对代码进行解析检查以确保代码是符合子集规范的。</p><p>为了让JS代码静态地通过安全检查，必须移除一些js特性</p><ul><li>eval()和Function()构造函数在任何安全子集里都是禁止使用的，因为他们可以执行任意代码，而且JS无法对这些代码做静态分析</li><li>禁止使用this关键字，因为函数(非严格模式中)可以通过this访问全局对象。而沙箱系统的一个重要目的就是阻止对全局对象的访问.</li><li>禁止使用with语句，因为with语句增加了静态代码检查的难度</li><li>禁止使用某些全局变量</li></ul><h3 id="常量和局部变量"><a href="#常量和局部变量" class="headerlink" title="常量和局部变量"></a>常量和局部变量</h3><p>在js1.5以及以后的版本中使用const关键字来定义常量。常量可以看成不可重复赋值的变量,对常量的重复声明会报错。<br>因为JavaScript中没有块级作用域，因此常量会被提前至函数定义的顶部。</p><p>JavaScript中的变量缺少块级作用域的支持被普遍认为是JavaScript的短板，JavaScript1.7中针对这个缺陷增加了关键字let，关键字const一直都是JavaScript的保留字(没有使用)。</p><p>关键字let有4种使用方式：</p><ul><li>可以作为变量声明，和var一样；</li><li>在for或for&#x2F;in循环中，作为var的替代方案</li><li>在语句块中定义一个新变量并显示指向它的作用域；</li><li>定义一个在表达式内部作用域中的变量，这个变量只在表达式内可用。</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>可能在Python或Ruby中接触过这个概念，在解构赋值中，等号右侧是一个数组或对象(一个结构化的值)，指定左侧一个或朵儿变量的语法和右侧的数组和对象直接量的语法保持一致。</p><p> let [x,y] &#x3D; [1.2]; &#x2F;&#x2F;等价于 let x&#x3D;1,y &#x3D;2<br> [x,y] &#x3D; [x+1,y+1]; &#x2F;&#x2F;等价于x &#x3D; x +1,y &#x3D; y+1<br> [x,y] &#x3D; [y,x];   &#x2F;&#x2F;交换两个变量的值<br> console.log([x,y]);  &#x2F;&#x2F;输出[3,2]</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Mozilla的JS扩展引入了一些新的迭代机制，包括for&#x2F;each循环和Python风格迭代器和生成器。</p><h2 id="for-x2F-each"><a href="#for-x2F-each" class="headerlink" title="for&#x2F;each"></a>for&#x2F;each</h2><p>for&#x2F;each循环是由E4X规范定义的一种新的循环语句。E4X是语言的扩展，它允许JS程序中直接出现XML标签，并添加了操作XML数据的语法和API。for&#x2F;each和for&#x2F;in循环非常相似。但for&#x2F;each并不是遍历对象的属性，而是遍历对象的属性的值:</p><p> let o &#x3D;{one:1,two :2,three:3}<br> for(let p in o)console.log(p);&#x2F;&#x2F;for&#x2F;in: 输出’one’,’two’,’three’<br> for each (let v in o )console.log(v);&#x2F;&#x2F;for&#x2F;each：输出1~3</p><p>当使用数组时for&#x2F;each循环遍历循环的元素(而不是索引)。它通常按竖直顺序枚举他们，但实际上这并不是标准化或必需的:</p><p> a&#x3D;[‘one’,’two’,’three’];<br> for(let p in o)<br>  console.log(p);&#x2F;&#x2F;prints array indexes 0,1,2</p><p> for each (let v in o )<br>  console.log(v);&#x2F;&#x2F;prints array elts ‘one’,’two’,’three’</p><p>注意：for&#x2F;each循环并不仅仅针对数字本身的元素进行遍历，也会遍历数组中所有可枚举属性的值，包括由数组继承来的可枚举方法。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个对象，这个对象允许对它的值集合进行遍历，并保持任何必要的状态以便能够跟踪到当前遍历的“位置”。</p><p>迭代器必须包含next()方法，这迭代器每次调用next()都返回集合中的下一个值。比如下面counter()函数返回一个迭代器，这个地带器每次调用next()都会返回连续递增的整数。</p><p>当迭代器用于有限的集合时，当遍历完所有并且没有多余的值可迭代时，再调用next()方法会抛出StopIteration。它的值是一个普通的对象(它自身没有属性)，只是为了终结迭代的目的而保留的一个对象。<br>注意，这里的循环使用一个迭代器对象，并且显示处理Stopiteration方法，这种方式非常糟糕，因此我们不经常直接使用迭代器对象，而是使用可迭代的对象。可迭代对象表示一组可迭代处理的值，可迭代对象必须定义一个名叫_iterator_()的方法，用以返回这个集合的迭代器对象。</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器是JS1.7的特性，这里用到了一个新的关键字yield,使用这个关键字时代码必须显示指定JS1.7,关键字yield在函数内使用，用法和return类似，返回函数中的一个值。</p><h3 id="数组推导"><a href="#数组推导" class="headerlink" title="数组推导"></a>数组推导</h3><p>JS中 的数组推导，也是从Python中借用过来的一个概念。它是一种利用另外一种数组或可迭代对象来初始化数组元素的技术。数组推导的语法是基于定义元素集合的数字模型的，也就是说，表达式从句的写法和js程序员期望的不一致，但不必担心，因为花不了太多时间就可以掌握这种新式写法，一旦掌握，威力无穷。</p><h3 id="生成器的表达式"><a href="#生成器的表达式" class="headerlink" title="生成器的表达式"></a>生成器的表达式</h3><p>在js中，将数组推导中的方括号替换成圆括号，它将成立一个生成器表达式。生成器表达式和数组推导非常类似(两者在圆括号内的语法几乎完全一样)，只是它的返回值是一个生成器对象，而不是一个数组。</p><h2 id="函数简写"><a href="#函数简写" class="headerlink" title="函数简写"></a>函数简写</h2><p>对于函数简写，js引入了一种简写像是：表达式闭包。如果函数只计算一个表达式并返回它的值，关键字 return和花括号可以省略，并将待计算的表达式紧接着放在参数列表之后，这里有一例子：</p><p> let succ &#x3D; function(x)x+1,yes&#x3D;function() true,no&#x3D;function() false;<br>这只是一种简写的快捷写法，用这种形式定义的函数，其实和带花括号和关键字return的函数完全一样。</p><h3 id="多catch从句"><a href="#多catch从句" class="headerlink" title="多catch从句"></a>多catch从句</h3><p>try&#x2F;catch语句已经可以使用多catch从句了，在catch从句的参数中加入关键字if以及一个条件判断表达式：<br> try{<br>  &#x2F;&#x2F;这里可能会抛出多种类型的异常<br>  Throw 1;<br> }<br> catch(e if e instanceof ReferenceError){<br>  &#x2F;&#x2F;这里处理引用错误<br> }…</p><h3 id="E4X-ECMAScript-for-XML"><a href="#E4X-ECMAScript-for-XML" class="headerlink" title="E4X:ECMAScript for XML"></a>E4X:ECMAScript for XML</h3><p>E4X将XML文档(或者XML文档的元素或属性)视为一个XML对象，将XML片段(在常见的弗雷对象中包含多个XML元素)，视为一个紧密相关的XML列表对象。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript正则表达式的模式匹配</title>
    <link href="/2021/04/05/JavaScript-Regexp/"/>
    <url>/2021/04/05/JavaScript-Regexp/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript正则表达式的模式匹配"><a href="#JavaScript正则表达式的模式匹配" class="headerlink" title="JavaScript正则表达式的模式匹配"></a>JavaScript正则表达式的模式匹配</h1><p>正则表达式(regular expression)是一个描述字符模式的对象。JavaScript的RegExp表示正则表达式，String和RegExp都定义了方法，后者使用正则进行强大的模式匹配和文本检索与替换功能。JavaScript的正则表达式语法是Perl5的正则表达式语法的大型子集，所以对于有Perl编程经验人来说，学习JavaScript的正则表达式是很简单的。</p><h2 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h2><p>JavaScript中正则表达式用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp对象。不过RegExp对象更多的是通过一种特殊的直接量语法来创建。</p><p>就像通过引号包裹字符的方式来定义字符串直接量一样，正则表达式直接量定义为包含在一对斜杠(&#x2F;)之间的字符。</p><p> 例如：var  pattern &#x3D; &#x2F;s$&#x2F;;</p><h3 id="RegExp直接量和对象的创建"><a href="#RegExp直接量和对象的创建" class="headerlink" title="RegExp直接量和对象的创建"></a>RegExp直接量和对象的创建</h3><p>就像字符串和数字一样，程序中每个取值相同的原始类型直接量均表示相同的值，这是显而易见的。程序运行每次遇到对象直接量(初始化表达式)诸如{}和[]的时候都会创建新对象。比如，若果在循环体中写var a&#x3D;[],则每次遍历都会创建一个新的空数组。</p><p>正则表达式直接量则与此不同，ECMS3规范规定，一个正则表达式直接量会在执行到它时转换一个未RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMS5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。IE一直都是按照ECMS5规范实现的，多数最新版本的浏览器也开始遵循ECMS5，尽管目前该标准并未全面广泛推行。</p><h3 id="直接量字符"><a href="#直接量字符" class="headerlink" title="直接量字符"></a>直接量字符</h3><p>正则表达式中的所有字母和数字都是按照字面含义进行匹配的。JS正则表达式语法也支持非字母字符匹配，这些字符需要通过反斜杠()作为前缀进行转义。</p><p> 字符    匹配<br> 字母和数字字符  本身</p><p> \o   NUL字符(\u0000)<br> \n   换行符(\u000A)<br> \t   制表符(\u0009)<br> \v   垂直制表符(\u00B)<br> \f   换页符(\u000C)<br> \r   回车符(\u000D)<br> \xnn  由十六进制nn指定的拉丁字符如\xOA&#x3D;\n<br> \uxxx  由十六进制指定Unicode字符，如\u0009&#x3D;\t<br> \cX   控制字符^X，例如，\cJ&#x3D;换行符\n</p><p>在正则表达式中，许多标点符号具有特殊含义，它们是：</p><p> ^ $ . * + ? &#x3D; ! : | \ &#x2F; ( ) [ ] { }</p><p>如果想在正则表达式中使用这些字符的直接量进行匹配，则必须使用前缀\，这是一条通行规则。<br>如果不记得哪些标点符号需要反斜线转义，可以在每个标点符号前都加上反斜杠。另外，需要注意，许多字母和数字在有反斜线做前缀是也有特殊含义，所以对于想按照直接量进行匹配反斜线本身，则必须使用反斜线来将其转义。</p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>将直接量字符单独放进方括号内就组成了字符类。一个字符类可以匹配它所有包含的任意字符。正则表达式&#x2F;[abc]&#x2F;就和字母”a”、”b”、”c”中任意一个都匹配，另外，通过”^”来定义否定字符类，它匹配所有不包含在方括号内的字符。</p><p>正则表达式字符类</p><p> 字符  匹配<br> […]  方括号内的任意字符<br> [^…] 不在方括号内的任意字符<br> .  除换行符和<br> \w  任何ASCEII字符组成的单词等价于[a-zA-Z0-9]<br> \W  任何不是ASCII字符组成的单词，等价于[^a-Za-z-0-9]<br> \s  任何Unicode空白符<br> \S  任何非Unicode空白符的字符，注意\W和\S不同<br> \d  任何ASCII数字，等价于[0-9]<br> \D  除了ASCII数字之外的任何字符，等价于[^0-9]<br> [\b] 退格直接量(特例)</p><p>注意，在方括号之内也可以写这些特殊转义字符，比如\s匹配所有的空白字符，\d匹配所有的数字，因此&#x2F;[\s\d]&#x2F;就匹配任意空白字符或者数字。</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>可以把两位数描述成&#x2F;\d\d&#x2F;,四位数描述成&#x2F;\d\d\d\d&#x2F;。我们在正则模式之后跟随用以指定字符重复的标记。<br>正则表达式的重复字符语法</p><p> 字符  含义<br> {n,m} 匹配前一项至少n次，但不能超过m次<br> {n,} 匹配前一项n次或者更多次<br> {n}  匹配前一项n次<br> ?  匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1}</p><ul><li><p>匹配钱一项一次或多次，等价于{1,}</p></li><li><p>匹配前一项0次或多次，等价于{01}</p></li></ul><p>例子：</p><p> &#x2F;\d{2,4}&#x2F;   &#x2F;&#x2F;匹配2~4个数字<br> &#x2F;\w{3}\d?&#x2F; &#x2F;&#x2F;精确匹配三个单词和一个可选的数字<br> &#x2F;\s+java\s+&#x2F;  &#x2F;&#x2F;匹配前后带有一个或者多个空格的字符串”java”<br> &#x2F;[^(]*&#x2F;  &#x2F;&#x2F;匹配一个或者多个非左括号的字符</p><p>非贪婪的重复</p><p>上面列出的匹配重复字符是尽可能多地匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为”贪婪的”匹配。</p><p>我们同样可以使用正则表达式进行非贪婪匹配。<br>只需在待匹配的字符后面跟随一个问号即可:”??”、”?+”、”*?”或”{1,5}?”。比如，正则表达式&#x2F;a+&#x2F;可以匹配一个或多个连续的字母a。</p><h3 id="选择、分组和引用"><a href="#选择、分组和引用" class="headerlink" title="选择、分组和引用"></a>选择、分组和引用</h3><p>正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符。字符”|”用于分隔供选择的字符。</p><p> 字符  含义<br> |  选择，匹配的是该符号左边的子表达式或右边的子表达式<br> (…)  组合，将几个项组合为一个单元，这个单元可通过”*”、”+”、”?”和”|”等等符号加以修饰，<br>   而且可以记住和这个组合匹配的字符串以供此后的引用使用</p><p> (?:…) 只组合，把项组合到一个单元，但不记忆与该组合相匹配的字符<br> \n  和第n个分组第一次匹配的字符相匹配，组是圆括号中的子表达式(也有可能是嵌套的),<br>   组索引是从左到右的左括号数,”(?:”形式的分组不编码</p><h3 id="指定匹配位置"><a href="#指定匹配位置" class="headerlink" title="指定匹配位置"></a>指定匹配位置</h3><p>正如前面所介绍的，正则表达式中的多个元素才能够匹配字符串的一个字符。例如，\s匹配的只是一个空白符。</p><p>正则表达式中的锚字符</p><p> 字符   含义<br> ^   匹配字符串的开头，在多行检索中，匹配一行的开头<br> $   匹配字符串的结尾，在多行检索中，匹配一行的结尾<br> \b   匹配一个单词的边界，简言之，就是位于字符\w和\W之间的位置，<br>    或位于字符\w和字符串的结尾或开头之间的位置(但需要注意，[\b]匹配的是退格符)<br> \B   匹配非单词边界的位置<br> (?&#x3D;p)  零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符<br> (?!p)  零宽负向先行断言，要求接下来的字符不与p匹配</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>正则表达式中的语法还有最后一个知识点，即正则表达式的修饰符，用以说明高级匹配模式的规则。</p><p> 字符  含义<br> i  执行不区分大小写的匹配<br> g  执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止<br> m  多行匹配模式，^匹配一行的开头和字符串的开头，$匹配行的结束和字符串的结束</p><h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><p>正则表达式是通过RegExp对象来表示的。除了RegExp()构造函数之外，RegExp对象还支持三个方法和一些属性。接下来的两节会对RegEep模式匹配方法和属性展开讲述。</p><p>&#x2F;&#x2F;全局匹配字符串中的5个数字，注意这里使用了”\”，而不是”\”</p><p> var zipcode &#x3D;new RegExp(“\d{5}”,”g”);</p><h3 id="RegExp的属性"><a href="#RegExp的属性" class="headerlink" title="RegExp的属性"></a>RegExp的属性</h3><p>每个RegExp对象都包含5个属性。属性source是一个只读的字符串，包含正则表达式的文本。属性global是一个只读的布尔值，用以说明这个正则表达式是否带有修饰符g。</p><h3 id="RegExp的方法"><a href="#RegExp的方法" class="headerlink" title="RegExp的方法"></a>RegExp的方法</h3><p>RegExp对象定义了两个用于执行模式匹配操作的方法。它们的行为和上文介绍过的String方法很类似。</p><p>RegExp最主要的执行模式匹配的方法是exec()，它与10.2节介绍过的String方法match()相似，只是RegExp方法的参数是一个字符串，而String方法的参数是一个RegExp对象。</p><p>exec()方法对一个指定的字符串执行一个正则表达式，简言之，就是在一个字符串中执行匹配检索。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言核心——JavaScript中的类和模块</title>
    <link href="/2021/04/04/JavaScript-Class-and-Modul/"/>
    <url>/2021/04/04/JavaScript-Class-and-Modul/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript中的类和模块"><a href="#JavaScript中的类和模块" class="headerlink" title="JavaScript中的类和模块"></a>JavaScript中的类和模块</h2><p>之前的第二篇中学过了JavaScript对象，每个JavaScript对象都是一个属性集合，相互之间没有任何联系。JavaScript中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为(方法);</p><p>在JavaScript中，类的实现是基于其原型继承机制的，如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。</p><p>如果两个对象继承自同一个原型，往往意味着(但不是绝对)它们是由同一个构造函数创建并初始化。</p><h3 id="类和原型"><a href="#类和原型" class="headerlink" title="类和原型"></a>类和原型</h3><p>在js中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。一个函数可以看成一个类，原型是所有类都有的一个属性，原型的作用就是给这个类的每一个对象都添加一个统一的方法</p><h3 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h3><p>定义构造函数就是定义类，并且类名首字母要大写，而普通的函数和方法都是首字母小写。构造函数是用来初始化新创建的对象的。</p><h4 id="构造函数和类的标识"><a href="#构造函数和类的标识" class="headerlink" title="构造函数和类的标识"></a>构造函数和类的标识</h4><p>原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例。</p><h5 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h5><p>任何js函数都可以用做构造函数，并且调用构造函数是需要用到一个prototye属性的，因此，每个js函数都自动拥有一个prototype属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性constructor。</p><h5 id="Constructor属性值是一个函数对象"><a href="#Constructor属性值是一个函数对象" class="headerlink" title="Constructor属性值是一个函数对象"></a>Constructor属性值是一个函数对象</h5><p> var F&#x3D;function(){};  &#x2F;&#x2F;这是一个函数对象<br> var p &#x3D;F.prototype;  &#x2F;&#x2F;这是F相关联的原型对象<br> var c&#x3D;p.constructor; &#x2F;&#x2F;这是与原型相关联的函数<br> c&#x3D;&#x3D;&#x3D;F    &#x2F;&#x2F;true</p><p>可以看出，构造函数的原型中存在预先定义好的constructor属性。</p><h5 id="js中的java式的类继承"><a href="#js中的java式的类继承" class="headerlink" title="js中的java式的类继承"></a>js中的java式的类继承</h5><p>Js和java的不同之处在于，js中的函数都是以值的形式出现的，方法和字段之间并没有太大的区别。如果属性值是函数，那么这个属性就兴义一个方法；否则，它只是一个普通的属性或字段，尽管存在出多差异，我们还是可以用js模拟出java的四种成员类型。</p><p>Js中类牵扯出三种不同的对象，三种对象的属性的行为和下面三种类成员非常相似：</p><ol><li>构造函数对象</li></ol><p> 构造函数 (对象)是js的类定义了名字。任何添加到这个构造函数对象中的属性都是类字段和类方法(如果属性值是函数的话就是类方法)。</p><ol start="2"><li>原型对象</li></ol><p> 原型对象的属性被类的所有实例所继承没如果原型对象的属性值是函数的话这个函数就作为类的实例的方法来调用。<br>3. 实例对象</p><p> 类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的，定义在实例上的非函数属性，实际上是实例的字段。</p><h4 id="类的扩充"><a href="#类的扩充" class="headerlink" title="类的扩充"></a>类的扩充</h4><p>Js基于原型的继承机制是动态的，对象从其原型继承属性没如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象</p><h4 id="类和类型"><a href="#类和类型" class="headerlink" title="类和类型"></a>类和类型</h4><p>js定义了少量的数据类型：null,undefined,布尔值,数字,字符串,函数和对象。</p><p>instanceof运算符,左操作数是待检测其类的对象，右操作数是定义类的构造函数。如果o继承自c.prototype，则表达式o instanceof c值为true。</p><p>constructor属性是某个类的方法是使用constructor属性。</p><p>使用instanceof运算符和constructor属性来检测对象所属的类有一个主要问题，在多个执行上下文中存在构造函数的多个副本的时候，这两种方法的检测结果会出错。</p><h4 id="js中的面向对象技术"><a href="#js中的面向对象技术" class="headerlink" title="js中的面向对象技术"></a>js中的面向对象技术</h4><p>如何利用js的类进行编程。</p><ol><li><p>集合类的一个例子：</p></li><li><p>枚举类型</p></li><li><p>标准转换方法：toString();toLocaleString();valueOf();toJSON()</p></li><li><p>比较方法 :</p></li></ol><p> equals()方法对其参数执行了类型检查，</p><p> compareTo()方法并没有返回一个表示”这两个值不能比较，由于咩有对象参数做任何类型检查，因此如果给compareTo()方法传入错误类型的参数，往往会抛出异常</p><ol start="5"><li>方法借用</li></ol><p> Js中方法没有什么特别的，无非是一些简单的函数，赋值给了队形的属性，可以通过对象来调用它，一个函数可以赋值给两个属性，然后作为两个方法来调用它。</p><ol start="6"><li>私有状态</li></ol><p> 在经典的面向对象编程中，经常需要将对象的某个状态封装或隐藏在对象内，只有通过对象的方法才能访问这些状态，对外值暴露一些重要的状态变量可以直接读写。</p><ol start="7"><li>构造函数的重载和工厂方法</li></ol><p> 有时候，我们希望对象的初始化有多种方式，通过重载(overload)这个构造函数让它根据传入参数的不同来执行不同的初始化方法。</p><h4 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h4><p>A是父类，B是子类,B的实例从A继承了所有的实例方法，，类B可以定义自己的实例方法，有些方法可以重载类A中的同名方法，如果B的方法重载了A中的方法，B中重载方法可能会调用A中的重载方法，这种做法称为”方法链”</p><h5 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h5><p>JS的对象可以从类的原型对象中继承属性。B.prototype &#x3D; inherit(A.prototype);&#x2F;&#x2F;子类派生自父类 B.prototype.comstructor &#x3D; B;&#x2F;&#x2F;重载继承来的constructor属性</p><h5 id="构造方法和子类链"><a href="#构造方法和子类链" class="headerlink" title="构造方法和子类链"></a>构造方法和子类链</h5><h5 id="组合vs子类"><a href="#组合vs子类" class="headerlink" title="组合vs子类"></a>组合vs子类</h5><p>面向对象编程中一条广为人知的设计原则：“组合优于继承”。这样，可以利用组合的原理定义一个新的集合实现，它“包装”了另一个集合对象，在将受限制的成员过滤掉之后会用到这个(包装的)集合对象。</p><h5 id="类的层次结构和抽象类"><a href="#类的层次结构和抽象类" class="headerlink" title="类的层次结构和抽象类"></a>类的层次结构和抽象类</h5><p>为了将这条原则阐述清楚，创建了Set的子类，这样做的原因是最终得到的类是Set的实例，它将从Set继承有用的辅助方法，比如toString()和equals()。</p><h4 id="ES5中的类"><a href="#ES5中的类" class="headerlink" title="ES5中的类"></a>ES5中的类</h4><p>让属性不可枚举</p><p>定义不可变的类</p><p>除了可以设置属性为不可枚举的，ECMS5还可以设置属性为只读的，当我们希望类的实例都是不可变的，这个特性非常有帮助。</p><h5 id="封装对象状态"><a href="#封装对象状态" class="headerlink" title="封装对象状态"></a>封装对象状态</h5><p>构造函数中的变量和参数可以用做它创建的对象的私有状态</p><h5 id="防止类的扩展"><a href="#防止类的扩展" class="headerlink" title="防止类的扩展"></a>防止类的扩展</h5><p>通常给原型对象添加方法可以动态地对类进行扩展，这是js的特性</p><h5 id="子类和ECMS5"><a href="#子类和ECMS5" class="headerlink" title="子类和ECMS5"></a>子类和ECMS5</h5><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>将代码组织到类中的一个重要的原因是，让代码更加“模块化”，可以在很多不同场景中实现代码的重用。一般来说，模块是一个独立的js文件，模块文件可以包含一个类定义、一组相关的类、一个使用函数库或者是一些待执行的代码。</p><h5 id="用做命名空间的对象"><a href="#用做命名空间的对象" class="headerlink" title="用做命名空间的对象"></a>用做命名空间的对象</h5><p>在模块创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来，而不是定义全局函数和变量。</p><h5 id="作为私有命名空间的函数"><a href="#作为私有命名空间的函数" class="headerlink" title="作为私有命名空间的函数"></a>作为私有命名空间的函数</h5><p>模块对外导出一些共用API，这些API是提供给其他程序员使用的，它包括函数、类、属性和方法。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言核心——表达式、对象、数组、函数</title>
    <link href="/2021/04/02/JavaScript-authority-guiade2/"/>
    <url>/2021/04/02/JavaScript-authority-guiade2/</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript语言核心——表达式、对象、数组、函数"><a href="#JavaScript语言核心——表达式、对象、数组、函数" class="headerlink" title="JavaScript语言核心——表达式、对象、数组、函数"></a>JavaScript语言核心——表达式、对象、数组、函数</h2><p>上一篇文章讲了类型、值和变量，这一篇，我们接着上面的讲，既然讲到了变量，不得不提一下变量的作用域问题</p><h3 id="JavaScript变量作用域-scope"><a href="#JavaScript变量作用域-scope" class="headerlink" title="JavaScript变量作用域(scope)"></a>JavaScript变量作用域(scope)</h3><p>一个变量的作用域是程序源码中定义这个变量的区域。</p><p>全局变量拥有全局作用域，在js中，任何地方都是有定义的。</p><p>在函数内声明的变量只在函数体有定义，它们是局部变量，作用域是局部性的。<br>函数参数也是局部变量，他们只在函数体内有定义，在函数体内，局部变量的优先级高于同名的全局变量，如果在函数内声明一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所覆盖。</p><p>意思是说，全局变量是全局性的，即在JavaScript代码中，它处处都有定义。局部变量的作用域是局部性的，只在函数体内起作用，在函数体内，局部变量优先级高于同名的全局变量，在函数体内对局部变量赋值，会覆盖同名的全局变量。</p><h3 id="JavaScript的表达式与运算符"><a href="#JavaScript的表达式与运算符" class="headerlink" title="JavaScript的表达式与运算符"></a>JavaScript的表达式与运算符</h3><ol><li>表达式是JS的一个短语，js解释器会将表达式计算出一个结果</li></ol><ul><li><p>原始表达式</p></li><li><p>JavaScript原始表达式包含常量、关键字和变量</p></li><li><p>1,1.2,null,aa等</p></li><li><p>对象和数组的初始化表达式</p></li><li><p>由方括号或者大括号和其中逗号隔开的列表构成</p></li><li><p>[1,2,3] ,{x:1,y:2}等</p></li><li><p>函数定义表达式</p></li><li><p>由function跟随一对圆括号再接一对大括号</p></li><li><p>属性访问表达式</p></li><li><p>由点来运算得到一个对象或数组元素的值</p></li><li><p>调用表达式</p></li><li><p>调用函数或方法来得到计算值</p></li><li><p>f(0),Math.max(x,y,z);s.sort()</p></li><li><p>对象创建表达式</p></li><li><p>用new来创建一个对象来得到一个对象</p></li></ul><ol start="2"><li>运算符是用于完成操作的符号</li></ol><ul><li><p>算术运算</p></li><li><p>+、-、×、÷</p></li><li><p>关系运算</p></li><li><p>&lt;、&gt;、&#x3D;、!&#x3D;</p></li><li><p>逻辑运算</p></li><li><p>&amp;&amp;、||、！</p></li><li><p>赋值运算</p></li><li><p>用&#x3D;来江右边的值赋值给左边的变量或对象属性（数组属性）</p></li><li><p>表达式运算</p></li><li><p>eval()</p></li><li><p>eval（）是一个函数，但由于它已经被当成运算符来对待了</p></li><li><p>其他运算符</p></li><li><p>条件运算符(三目运算符) ?   :</p><p> 判断句  ?     true执行语句 :  false执行语句</p></li><li><p>typeof运算符</p><p> 用于返回()内的类型</p></li><li><p>delete运算符</p><p> 一元操作符，删除对象或者数组元素</p></li><li><p>void运算符<br> void最常用在客户端的 URL中&lt;a href&#x3D;”javascript:void window.open():” &gt;打开一个新的窗口  </a>   );</p></li></ul><h3 id="JavaScript的语句"><a href="#JavaScript的语句" class="headerlink" title="JavaScript的语句"></a>JavaScript的语句</h3><ol><li>如果表达式是js中的短语，则语句就是js中的完整的句子或者命令。</li></ol><p> 语句三大类：条件(if和switch)、循环(while和for)、跳转(break、return和throw)</p><ol start="2"><li><p>表达式语句：赋值语句是一类比较重要的表达式语句，delete运算符也是表达式语句的一部分，函数调用也是表达式语句的一大类。</p></li><li><p>复合语句和空语句<br> 多条语句用花括号括起来就可以形成一条复合语句</p></li></ol><p> 语句块注意点：</p><p> 第一，语句块结尾不需要分号。块中语句必须以分号结束</p><p> 第二，语句块中的行都有缩进，但不是必须的。</p><p> 第三，js中没有块级作用域，在语句块中声明的变量并不是语句块私有的</p><ol start="4"><li><p>声明语句<br>  var和function都是声明语句，它们声明或定义变量或函数。</p></li><li><p>条件语句</p></li></ol><ul><li>if是基本的控制语句，它让js程序可以选择执行路径</li><li>switch,if是创建一条分支，并且使用else if来处理多条分支，当所有分支都依赖同一个表达式时，可以用switch和case来创建多条分支，注意switch语句的执行非常高效，没一个case后的执行语句后要加上break来终止case语句块，switch结尾要用default,来保证switch的整个语句块不被跳过。</li></ul><ol start="6"><li>循环语句</li></ol><p> 如果说条件语句是代码的一条条分支路径，则循环语句是程序路径的一条回路。</p><p> (1).do&#x2F;while 与wihle循环相似，只不过它是在循环的尾部而不是顶部检测循环表达式，这就意味着循环体至少会执行一次</p><p> (2). for语句提供了一种比while更方便的循环控制结构。</p><p>  for(initialize;test;increment){<br>   statement<br>  }<br> initialize负责初始化操作，test负责循环条件判断， increment负责计数变量更新</p><p> for&#x2F;in语句也是使用for关键字，但和for循环完全不同的一类</p><p> for(variable  in  object ) {statemenet}</p><p> variable通常是一个变量名，也可以是一个可以产生左值的表达式或者一个通过var语句声明的变量  object是一个表达式，这个表达式的计算结果是一个对象</p><ol start="7"><li>跳转</li></ol><p> Js中的跳转语句，break语句是跳转到循环或者其他语句的结束。</p><p> Continue语句是终止本次循环的执行并开始下一次循环的执行。</p><p> Return语句可以让解释器跳出函数体的执行，并提供本次调用的返回值。</p><p> Throw语句触发或者抛出一个异常，一般与try&#x2F;catch&#x2F;finally语句一同使用，用于捕获异常</p><ol start="8"><li>其他语句类型</li></ol><p> with, debugger 和 use strict</p><p> with语句用于临时扩展作用域链，with(object) statement，将object添加到作用域链的头部，注：在严格模式中禁止使用with，非严格模式中不推荐使用</p><p> debugger语句通常什么也不做，只是用来打断点进行调试</p><p> use strict是ECMAScript 5 引入的一条指令，指令不是语句(非常接近于语句)</p><p> 目的是说明后续的代码将会解析为严格代码<br> 严格模式和非严格模式之间的区别：(前三条尤为重要)</p><pre><code class="hljs">(1).严格模式禁止使用with(2).严格模式中所有变量都要先声明，如果一个未声明的变量、函数、函数参数、catch从句参数或者全局对象属性赋值，将会抛出引用错误异常(在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添一个新属性)(3)在严格模式中，调用的函数中的一个this值是undefined，非严格模式中，调用的函数中的this值总是全局对象。可以利用这种特性来判断js实现是否支持严格模式</code></pre><h3 id="JavaScript中的对象"><a href="#JavaScript中的对象" class="headerlink" title="JavaScript中的对象"></a>JavaScript中的对象</h3><ol><li>对象是js的基本数据类型</li><li>对象是一种复合值，它将很多值(原始值或者其他对象)聚合在一起，通过名字访问这些值。</li><li>对象也可以看成是属性的无序集合，每个属性都是一个名字</li><li>对象的属性名是字符串，所以对象是从字符串到值的映射。也称为“散列”、“散列表”、“字典”、“关联数组”</li><li>对象是动态的，可以添加也可以删除属性，常用来模拟静态类型语言中的“结构体”</li></ol><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>可以通过对象直接量、关键字new和ECMAScript 5中的 Object.create()函数来创建对象</p><p>（1）对象直接量是一个表达式，这个表达式每次运算都创建并初始化一个新的对象，每次计算对象直接量的时候，也都会计算它的没一个属性的值。</p><p>（2）new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用。这里的函数称做构造函数。构造函数用以初始化一个先创建的对象。</p><p>（3）Object.create(Object)可以通过任意原型创建新的对象，也就是说可以是任意对象可继承。</p><h4 id="属性的查询和设置"><a href="#属性的查询和设置" class="headerlink" title="属性的查询和设置"></a>属性的查询和设置</h4><p>可以通过.和[]运算来获取属性的值，已经有的属性可直接赋值</p><p>赋值：</p><p>如果o中的属性p是可读的：不能给只读属性重新赋值</p><p>如果o中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性</p><p>如果o中不存在自有属性p：o也没有使用setter方法继承属性p，并且o的可扩展性是false。</p><p>如果o中不存在p，而且没有setter方法提供调用，则p一定会添加至o中。</p><p>但如果o不是可扩展的，那么在o中不能定义新属性。</p><h4 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h4><p>detele 语句，不能删除那些可配置性为false的属性</p><p>detele  Object.prototype; &#x2F;&#x2F;不能删除，属性不可配置的<br> var  x&#x3D;1;<br> detelet  this.x;&#x2F;&#x2F;不能删除这个属性<br>  function  f(){};<br> detelet  this.f;&#x2F;&#x2F;不能删除这个全局函数</p><p>只能删除自有属性，不能删除继承属性,要删除继承属性必须从定义原型对象上删除它。</p><h4 id="检测属性（in、for-x2F-in）"><a href="#检测属性（in、for-x2F-in）" class="headerlink" title="检测属性（in、for&#x2F;in）"></a>检测属性（in、for&#x2F;in）</h4><ol><li>in运算的左侧是属性名，右侧是对象，如果包含则返回true</li></ol><p>  var o &#x3D;{x:1}<br>  “x” in o&#x2F;&#x2F;true<br>  “y” in o &#x2F;&#x2F;false<br>  “toString” in o &#x2F;&#x2F;true o继承了toString属性</p><ol start="2"><li>hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性,对于继承属性返回false</li></ol><p>  var o &#x3D; {x:1}<br>  o.hasOwnProperty(“x”);  &#x2F;&#x2F;true：o有一个自有属性x<br>  o.hasOwnProperty(“x”); &#x2F;&#x2F;false :o中不存在属性y<br>  o.hasOwnProperty(“x”);&#x2F;&#x2F;false：toString是继承属性</p><ol start="3"><li>propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到自有属性且是可枚举的才返回 true</li></ol><p>  var o &#x3D;inherit { y : 1}<br>  o.x &#x3D; 1;<br>  o.propertyIsEnumerable(“x”);&#x2F;&#x2F;true :o有一个可枚举的自有属性x<br>  o.propertyIsEnumerable(“y”);&#x2F;&#x2F;false:y是继承来的<br>  Object.prototype.propertyIsEnumerable(“toString”);&#x2F;&#x2F;false:不可枚举</p><p>除了in之外，!&#x3D;&#x3D;判断一个属性是否是undefined</p><p> var o &#x3D;{x:1}<br> o.x !&#x3D;&#x3D;undefined;&#x2F;&#x2F;true：o中有属性x<br> o.y !&#x3D;&#x3D;undefined;&#x2F;&#x2F;false：o中没有属性y<br> o.toString !&#x3D;&#x3D; undefined;&#x2F;&#x2F;true o 继承了toString属性</p><h4 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h4><p>for&#x2F;in循环</p><p> var o &#x3D; {x:1,y:2,z:3}<br> for(p in o){console.log(p); }</p><h4 id="属性getter和setter方法"><a href="#属性getter和setter方法" class="headerlink" title="属性getter和setter方法"></a>属性getter和setter方法</h4><p>由getter和setter定义的属性称做“存取器属性”，不同于”数据属性”，数据属性只是一个简单的值<br>当有getter和setter时，说明属性是可读写的存取器属性<br>当只有getter时，说明属性是只读取的属性</p><h4 id="对象的三个属性"><a href="#对象的三个属性" class="headerlink" title="对象的三个属性"></a>对象的三个属性</h4><p>每一个对象都有与之相关的原型(property)、类(class)和可扩展性(extensible attribute)</p><p>原型属性：对象的原型属性是用来继承属性的。是实例对象创建之初就设置好的。</p><p> var p &#x3D;{ x :1};&#x2F;&#x2F;定义一个原型对象<br> var o &#x3D; Object.create(p);&#x2F;&#x2F;使用这个原型创建一个对象<br> p.isPrototypeOf(o)&#x2F;&#x2F;true：o继承自p<br> Object.prototype.isPrototypeOf(o)&#x2F;&#x2F;true:  p继承自Object.prototype<br> isPrototypeOf()方法，检测p是否是o的原型</p><p>类属性：对象的类属性是一个字符串，用以表示对象的类型信息 classof(1)&#x2F;&#x2F;Number</p><p>可扩展的属性</p><p>对象的可扩展属性用以表示是否可以给对象添加新属性。所以内置对象和自定义对象都是显式可扩展的</p><p>Object.preventExtensions（）、Object.seal()、 Object.freeze()</p><p>&#x2F;&#x2F;创建一个封闭对象，包括一个冻结的原型和一个不可枚举的属性</p><p> var o &#x3D; Object.seal(Object.create(Object.freeze({ x : 1}),<br> {y: {value: 2,writable:true}}));</p><h4 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h4><p>是指将对象的状态转换为字符串，也可将字符串还原为对象JSON.stringify()和JSON.parse()来序列化和还原js对象。这些方法都是使用JSON作为数据交换格式，它的语法和js对象和数组直接量的语法非常相近。</p><h4 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h4><p>toString()方法：没有参数，返回表示调用这个方法的对象值的字符串</p><p>toLocaleString()方法：这个方法返回一个表示这个对象的本地化字符串，可以用它对数字、日期和时间做本地化转换</p><p>toJSON()方法：如果在待序列化的对象中存在这个方法，则调用它，返回值即是序列化的结果</p><p>valueOf() 方法:这个方法和toString()方法非常相似，但往往当js需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转化为数字的时候。</p><h3 id="JavaScript中的数组"><a href="#JavaScript中的数组" class="headerlink" title="JavaScript中的数组"></a>JavaScript中的数组</h3><p>数组是值的有序集合</p><p>每一个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。</p><p>数组是JavaScript对象的特殊形式</p><p>ECMAScript  5中可以使用Array.isArray({});和Array.isArray([]);来区判定是否为数组。</p><p>Typeof操作在这帮不上忙(除函数以外的所有对象都是如此)</p><p>.instanceof操作只能用于简单的情形： instanceof的问题是在Web浏览器中有可能有多个窗口或窗体(frame)存在。</p><p>数组也是动态的</p><p>创建数组时无需声明一个固定的大小或者在数组大小变化时无需重新分配空间</p><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>(一)方括号中用逗号将数组元素隔开即可。</p><p>数组中不一定要有常量，他们可以是任意表达式。</p><p>它可以包含对象直接量或者其他数组直接量。</p><p>如果省略数组直接量中的某个值，省略的元素将被赋予undefined值。</p><p>(二)调用构造函数Array()创建数组也是一种方法。有三种方法可以调用构造函数</p><p>方法一：var   a&#x3D;new Array()，等同于直接量[];</p><p>方法二： var  a &#x3D; new Array(10);创建指定长度的数组；</p><p>方法三：显式指定两个或多个数组的一个非数值元素：var a &#x3D; new Array(1,2,3,”adc,aaa”);</p><h4 id="数组元素的读和写"><a href="#数组元素的读和写" class="headerlink" title="数组元素的读和写"></a>数组元素的读和写</h4><p>读数组array[index]</p><p>写数组 array[index]&#x3D;4;</p><h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><p>定义：稀疏数组就是包含从0开始的不连续索引的数组。即数组的length&gt;元素个数<br>足够稀疏的数组通常在实现上比稠密数组更慢、内存利用率更高，在这样的数组中查找元素与常规对象的属性查找时间一样</p><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><p>每一个数组都有一个length属性[].length</p><h4 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h4><p>添加：a.push(“1”);a.push(“1”,”2”);</p><p>删除 delete a[1];注：删除后a在索引1的位置</p><p>不再有元素，数组索引1并未在数组中定义，但delete操作并不影响数组的长度</p><h4 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h4><p>for循环遍历是最常见的遍历方法</p><p> for(var  i&#x3D;0;  i &lt; a.length;  i++ ){<br>  if(!a[i])<br>  continue;&#x2F;&#x2F;跳过null、undefined和不存在的情况<br> }<br> for(var  i  in  a){<br>  if(!a[i])<br>  continue;&#x2F;&#x2F;跳过null、undefined和不存在的情况<br> }</p><p>ECMAScript 5中定义了新的数组遍历的方法:forEach()方法</p><p> a.forEach(function(x){<br>  &#x2F;&#x2F;此处x指a[0]-a[a.length]的遍历<br> })</p><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>Js不支持真正的多维数组，但可以用数组的数组来近似多维数组。</p><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><ol><li><p>join()方法：将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。并不改变原数组join(“-”)指定拼接符</p></li><li><p>reverse()方法：将数组中的元素颠倒顺序，返回逆序的数组，它采取了替换，原先数组改变</p></li><li><p>sort()方法：将数组中的元素排序并返回排序后的数组。改变了原数组</p></li><li><p>concat()方法：创建并返回一个新的数组，他的元素包括调用concat()原始数组的元素和concat()的每个参数。如果这些参数中的任何一个自身是数组，则连接的是数组元素，而非数组本身。例如：var a&#x3D;[1,2],a.concat(4,5)&#x2F;&#x2F;[1,2,4,5]</p></li><li><p>slice()方法：返回指定数组的一个片段或者子数组。</p></li><li><p>splice()方法：数组中插入或者删除元素的通用方法a.splice(index),a.splice(index1,index2)，第一个参数指定了插入或删除的起始位置。第二个参数指定了应该从删除元素的个数。如果第二个参数省略，则从起始位置到数组结尾的元素都将被删除。</p></li><li><p>push()和pop()方法：push()是在数组尾部添加一个或多个元素，并返回新数组的长度。pop()相反，删除数组的最后一个元素，减小数组的长度并返回。</p></li><li><p>unshift()和shift()方法：unshift()和shift()跟push()和pop()相对，从头部增加一个或多个元素，并返回数组长度。shify()删除数组第一个元素，并将其返回，然后把所有随后的元素下一个位置来填补数组头部的空缺.</p></li><li><p>toString()和toLocaleString()方法：toString()针对数组，该方法将每个元素庄花为字符串并输出用逗号分隔字符串列表。toLocaleString()是toString()方法的本地化版本。它调用toLocaleString()方法将每个数组元素转化为字符串，并且使用本地化或自定义分隔将这些字符串连接起来生成最终的字符串。</p></li></ol><h4 id="ECMAScript-5中的数组方法"><a href="#ECMAScript-5中的数组方法" class="headerlink" title="ECMAScript  5中的数组方法"></a>ECMAScript  5中的数组方法</h4><p>(1)forEach()方法从头至尾遍历数组，为每个元素调用指定的函数。</p><p> data.forEach(<br>  function(value){<br>   …<br> })</p><p>注意：无法在所有元素都传递给调用函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try块中，并抛出异常。这样才会提前终止循环。</p><p>(2)map()方法：</p><p>该方法将b&#x3D;a.map(function(x){x*x})&#x2F;&#x2F;调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。例：x表示a[0]~a[a.length]</p><p>(3)filter()方法：</p><p>返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的。如果逻辑判定值是true则输出该元素到一个作为返回值的数组中，false则不返回。多用于压缩空缺并删除undefined元素。</p><p> 例：a&#x3D;[1,2,3,4,5];a.filter(function(x,i){return  i%2});&#x2F;&#x2F;[1,3,5]<br>  a&#x3D;a.filter(function(x){return x!&#x3D;undefined&amp;&amp;x!&#x3D;null});&#x2F;&#x2F;压缩空缺</p><p>(4)every()和some()</p><p>every()当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true</p><p>some()当数组中至少有一个元素满足判定函数，则返回true</p><p>(5)reduce() 和reduceRight()</p><p>reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值，这在函数式编程中是常见的操作。</p><p> 例 var a&#x3D;[1,2,3,4,5];<br> sum&#x3D;a.reduce(function (x,y){return x+y},0);  &#x2F;&#x2F;15  数组求和<br> max&#x3D;a.reduce(function(x,y){return (x&gt;y)?x:y}); &#x2F;&#x2F;5  数组求最大值</p><p>reduce()需要两个参数。第一个是执行化简操作的函数。化简函数的任务是用某种方法把两个数值组合或简化为一个值，并返回化简后的值。第二个(可选)的参数是一个传递给函数的初始值。</p><p>reduceRight()和reduce()的工作原理一样，不同的是它按照数组索引从高到低处理数组，而不是从低到高。</p><p><strong>注意：</strong>reduce()和reduceRight()都能接收一个可选的参数，它指定了化简函数调用是的this关键字的值。<br>可选的初始值人需要占一个位置，如果想让化简函数作为一个特殊对象的方法调用，请参见Function.bind()方法。</p><p>(6)indexOf()和lastIndexOf()</p><p>indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。indexOf()从头至尾搜索，而lastIndexOf()则是反向搜索。</p><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>数组是具有特殊行为的对象。ECMAScript  5中可以使用Array.isArray({});和Array.isArray([]);来区判定是否为数组。</p><p>Typeof操作在这帮不上忙(除函数以外的所有对象都是如此).instanceof操作只能用于简单的情形：</p><p>instanceof的问题是在Web浏览器中有可能有多个窗口或窗体(frame)存在。</p><h4 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h4><p>Js中数组的一些特性是其他对象所没有的：</p><p>当新元素添加到列表时，自动更新length属性。</p><p>设置length为一个较小值将阶段数组。</p><p>Array.prototype中继承一些有用的方法。</p><p>其类属性为Array，这些可以看出数组和常规的对象有明显的区别。</p><p>实践中，类数组对象实际上偶尔出现，虽然它们不能直接调用数组方法或者length属性有什么特殊的行为，但仍然可以针对真正数组遍历的代码来遍历它们。Js数组方法是特意定义为通用的，因此它们不仅应用在真正的数组而且在类数组对象上都能正确工作。</p><h4 id="作为数组的字符串"><a href="#作为数组的字符串" class="headerlink" title="作为数组的字符串"></a>作为数组的字符串</h4><p>在ECMAScript 5中字符串的行为类似于只读的数组。</p><h3 id="JavaScript中的函数"><a href="#JavaScript中的函数" class="headerlink" title="JavaScript中的函数"></a>JavaScript中的函数</h3><p>函数是JavaScript中只定义一次，但可被执行和调用任意次</p><p>函数是参数化的：函数的定义会包括一个称为形参的标识符列表，这些参数在函数体中像局部变量一样工作<br>如果函数挂载在一个对象上，作为对象的一个属性，就称为对象的方法</p><p>函数可以嵌套在其他函数中定义，这样他们就可以访问他们被定义时所处的作用域中的任何变量</p><p>函数给JavaScript带来了强劲的编程能力</p><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><p>使用 function关键字来定义，它可以用在函数定义表达式或者函数申明语句里。两种形式，都是从function关键字开始的。function 后面跟随函数名称标识符，函数名称是函数声明语句不可或缺的部分，它的用途就像是变量的名称，这个名字是可选的，如果存在，该名字只存在于函数体中，并指代该函数本身。</p><p>一对圆括号，其中包含0个多个用逗号隔开的标识符组成的列表，这些标示符是函数的参数名称，它们就像函数体中的局部变量一样。</p><p>一对花括号，其中包含0条或多条js语句，这些语句构成了函数体，一旦调用函数，就会执行这些语句。</p><h4 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h4><p>有四种方法来调用js函数:</p><ol><li>作为函数&#x2F;&#x2F;直接函数名a(x)</li><li>作为方法&#x2F;&#x2F;o.m();</li><li>作为构造函数 &#x2F;&#x2F;函数或方法调用之前带有关键词new</li><li>通过call()和apply()方法间接调用 &#x2F;&#x2F;js中函数也是对象，函数对象也可以包含方法call ()和apply()可以间接的调用函数，且都允许显式指定调用所需的this值。</li></ol><h4 id="函数的实参和形参"><a href="#函数的实参和形参" class="headerlink" title="函数的实参和形参"></a>函数的实参和形参</h4><p>定义时就是形参，调用时就是实参</p><h4 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h4><p>函数也可以作为值传递给一个变量</p><h4 id="作为命名空间的函数"><a href="#作为命名空间的函数" class="headerlink" title="作为命名空间的函数"></a>作为命名空间的函数</h4><p> (function(){<br>   &#x2F;&#x2F;CODE<br> })();&#x2F;&#x2F;最佳的方式是使用匿名函数创建作用域。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>Js也采用词法作用域，也就是说，函数的执行依赖变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。</p><p><strong>注：</strong>严格讲，闭包内的逻辑是可以使用this的，但这个this和当初定义函数时的this不是同一个，即便是同一个this，this的值是随着调用栈的变化而变化的。可以将this转存为一个变量的做法可以避免this的不确定性带来的歧义.</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。在js中可以操控对象一样操控函数，也就是说可以在js中应用函数式编程技术。</p><h4 id="函数的属性、方法和构造函数"><a href="#函数的属性、方法和构造函数" class="headerlink" title="函数的属性、方法和构造函数"></a>函数的属性、方法和构造函数</h4><ol><li>length属性</li></ol><p> arguments.length表示传入函数的参数的个数</p><ol start="2"><li>portotype属性</li></ol><p> 每个函数都包含一个portotype属性,这个属性是指向一个对象的引用，这个对象称作”原型对象”</p><ol start="3"><li>call()方法和apply()方法</li></ol><p> 我们可以将它们看做是某个对象的方法，通过调用方法的形式来间接调用函数。call()和apply()的第一个实参是要调用函数的母对象，他是调用上下文，在函数体内通过this来获得对它的引用。</p><p> 要想以对象o的方法来调用函数f(),可以这样使用call()和apply():f.call(o);和f.apply(o);</p><ol start="4"><li>bind()方法</li></ol><p> bind()是ECMAScript 5中新增的方法，这个方法主要作用是将函数绑定至某个对象。</p><p>  function f(){return  this.x+y;}  &#x2F;&#x2F;这个是待绑定的函数<br>  var o &#x3D;{x:1};    &#x2F;&#x2F;将要绑定的对象<br>  var g&#x3D; f.bind(o);   &#x2F;&#x2F;通过调用g(x)来调用o.f(x)<br>  g(2)</p><ol start="5"><li><p>toString()方法，和js对象一样，函数也有toString()方法，返回一个字符串没这个字符串和哈数声明的语句的语法相关</p></li><li><p>function()构造函数</p></li></ol><p>  var  f&#x3D; new function(“x”,”y”,”return x*y;”);</p><p>  等价于var f&#x3D;function(x,y){return x*y;}</p><p>注：</p><ul><li>function()构造函数允许js在运行时动态创建并编译函数。</li><li>每次调用function()都会解析函数体，并创建新的函数对象，如果在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响，相比之下，循环体中的嵌套函数和函数定义表达式则不会每次执行时都重新编译</li><li>function()构造函数最重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行。因此，构造函数在实际编程过程中很少用到</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript语言核心——数据类型</title>
    <link href="/2021/04/01/JavaScript-authority-guiade/"/>
    <url>/2021/04/01/JavaScript-authority-guiade/</url>
    
    <content type="html"><![CDATA[<h2 id="《JavaScript权威指南-第6版》学习第一部分，JavaScript语言核心"><a href="#《JavaScript权威指南-第6版》学习第一部分，JavaScript语言核心" class="headerlink" title="《JavaScript权威指南 第6版》学习第一部分，JavaScript语言核心"></a>《JavaScript权威指南 第6版》学习第一部分，JavaScript语言核心</h2><p>想成为一名合格的前端攻城狮，不会js肯定不行，前端就像是一个人，HTTML是前端的骨架，负责你的页面的内涵和基础，CSS是人的脸皮，负责你的多高，多胖，脸蛋有多漂亮，而js就像人的肌肉，负责人的运动和胸肌发不发，健不健壮。所以学好JavaScript是很有必要的。页面的动态和与后台的交互，都是交给js来做的。</p><p>JavaScript是面向WEB的编程语言，绝大多数现代网站都使用了JavaScript，并且所有的现代浏览器——基于桌面系统、游戏机、平板电脑和智能手机浏览器——均包含了JavaScript解释器。JavaScript逐渐成为史上使用最广泛地编程语言。</p><h2 id="JavaScript的由来和历史"><a href="#JavaScript的由来和历史" class="headerlink" title="JavaScript的由来和历史"></a>JavaScript的由来和历史</h2><p>JavaScript诞生于1992年，当时，它的主要目的是处理以前由服务器端语言负责的一些验证操作。在js问世之前，必须把表单数据发送到服务器端才能确定用户是否没有填写某个必填项，是否输入有效的值。Nestcape navigator 希望通过JavaScript来解决这一问题。在电话拨号上网的年代，与服务器的每一次交换数据是对用户耐心的一次考验。</p><p>JavaScript是一门非常简单的语言，又是复杂的语言，简单是因为学会使用它只需要片刻功夫，说它复杂，是因为想要完全掌握和理解JavaScript，必须要了解它的本质、历史和局限性。</p><p>Netscape公司为了塔上媒体炒热java的顺风车，将LiveScript改名为JavaScript。随后不久，微软发布了internet Explorer中的Jscript。导致与C及其其他编程语言不同，JavaScript出现两个版本的局面。1997年由欧洲计算机制造协会定义了ECMAScript的新脚本语言的标准。“JavaScript”这个名字经常被误解。除了语法看起来和java类似之外，JavaScript和java是完全不同的两种编程语言。JavaScript早已超出了“脚本语言(scripting-language)”的范畴，成为了一种集健壮性、高效性和通用性为一身的编程语言。</p><p>ECMAScript第3版才是对该标准的第一次真正修改。 ECMAScript第4版对js进行了全面的检核修订。由于js在Web上日益流行。出台后的第4版不仅包含强类型变量、新语句和新数据结构、真正的类和 经典继承，还定义了与数据交互的新方式，由于跨度太大，因此被取消了第4版的发布。 ECMAScript最近一版是第5版,于2009年颁布</p><p>为了有用起见，通常每一种变成语言都有各自的开发平台、标准库或API函数，用来提供诸如基本输入输出的功能。JavaScript语言核心针对文本、数组、日期和正则表达式的操作定义了很少的API，但这些API不包含输入输出功能。输入和输出功能（类似网络、存储和图形相关的复杂性）是由JavaScript所属的“宿主环境(host enviroment)”提供的。</p><h2 id="JavaScript语言核心"><a href="#JavaScript语言核心" class="headerlink" title="JavaScript语言核心"></a>JavaScript语言核心</h2><h4 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h4><ol><li>区分大小写: 关键字、变量、函数名和其他标识符都采取一致的大小写形式</li><li>JavaScript会忽略标识符之间的空格:可以用空格、换行符和格式控制符来调整、缩进</li><li>注释：单行注释&#x2F;&#x2F;,和多行注释&#x2F;**&#x2F;</li><li>直接量：程序中直接使用的数据值（数字、小数、文本字符串、布尔值、正则和空null）</li><li>标识符和保留字：变量命名规则和java一样，必须以字母、下划线（_）或美元符($)开始</li><li>分号可选：和java一样使用；将程序隔开</li></ol><h3 id="类型、值和变量"><a href="#类型、值和变量" class="headerlink" title="类型、值和变量"></a>类型、值和变量</h3><p>计算机程序的运行需要对<strong>值</strong>(value)进行操作。<br>能够表示并操作的值的类型称做数据<strong>类型</strong>(type)，当程序需要将值保存起来以备将来使用时，便将其赋值给一个变量。 <strong>变量</strong>是一个值的符号名称，可以通过名称来获得对值的引用。变量的工作机制是编程语言的另一种基本特性。</p><h4 id="JavaScript中的类型"><a href="#JavaScript中的类型" class="headerlink" title="JavaScript中的类型"></a>JavaScript中的类型</h4><p>JavaScript的数据类型有两种分类：</p><p>第一种：基本类型、特殊类型、复杂类型</p><p> JavaScript数据类型</p><ol><li>基本类型</li></ol><ul><li>Number:数字</li><li>String：字符串</li><li>Boolean：布尔</li></ul><ol start="2"><li>特殊类型</li></ol><ul><li>Null：空</li><li>Undefined：未定义</li></ul><ol start="3"><li>复杂类型<br>  -Function：函数<br>  -Object:对象</li></ol><p>第二种：原始(值)类型、对象类型</p><ol><li>JavaScript数据类型</li></ol><ul><li>原始(值)类型</li><li>数字(Number)</li><li>字符串(String)</li><li>布尔值(Boolean)</li><li>Null、Undefined</li></ul><ol start="2"><li>对象类型</li></ol><ul><li>Object</li><li>函数</li></ul><h4 id="数字（number）类型"><a href="#数字（number）类型" class="headerlink" title="数字（number）类型"></a>数字（number）类型</h4><ol><li>不区分整型数值和浮点型数值</li><li>所有数字都采用64位浮点格式存储，类似于doubule格式</li><li>整数</li></ol><ul><li>10进制的整数由数字的序列组成</li><li>16进制数前面加上0x,八进制前面加0</li></ul><ol start="3"><li>浮点数</li></ol><ul><li>使用小数点记录数据，如:3.4,5.6,.5</li><li>使用指数记录数据，如4.3e23 &#x3D; 4.3 ×10</li></ul><ol start="4"><li>数值范围</li></ol><ul><li>JS 定义了全局变量Infinity和NaN,用来表示正无穷大和非数字值</li><li><code>Infinity</code> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  &#x2F;&#x2F;将一个可读写的变量初始化为infinity</li><li><code>Number.POSITIVE_INFINITY</code>  &amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;同样的值，只读</li><li><code>1/0</code>     &amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;同样的值</li><li><code>Number.MAX_VALUE +1</code>  &amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;计算结果还是Infinity</li><li>同样：<code>-Infinity、-1/0，- Number.MAX_VALUE -1</code> &amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;结果表示负无穷</li><li><code>NaN</code>  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;not a number 非数字类型的</li><li>同样:<code>Number.NaN、0/0</code> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;表示非数字类型</li><li><code>Number.MIN_VALUE/2</code> &amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;发生下溢，结果为0</li><li><code>Number.MIN_VALUE/2</code> &amp;nbsp;&amp;nbsp;&amp;nbsp;&#x2F;&#x2F;负0</li></ul><h4 id="字符串文本（string）类型"><a href="#字符串文本（string）类型" class="headerlink" title="字符串文本（string）类型"></a>字符串文本（string）类型</h4><ol><li>表示文本</li></ol><ul><li>由Unicode字符、数字、标点符号组成的序列</li></ul><ol start="2"><li>首尾由一对单引号或双引号括起</li><li>加号(+)运算符用于数字，表示两数相加，用于字符串，表示二个字符串拼接。</li><li>特殊字符需要转义字符\，如:\n,\,\’,\”</li></ol><ul><li>var aa&#x3D;“\u4f60\u597d\n欢迎来到\”JavaScript的世界\””;alert(aa);</li></ul><ol start="5"><li>字符串具有length属性，表示字符串长度。</li><li>除了length属性，还有很多可调用的方法</li></ol><ul><li><code>charAt(n)</code> &#x2F;&#x2F;表示第n-1个字符</li><li><code>substring(n,m)</code>&#x2F;&#x2F;表示第n,到m-1个字符</li><li><code>slice(n,m)/slice(4)/slice(-n)</code>&#x2F;&#x2F;同上&#x2F;0-3&#x2F;length-n~length</li><li><code>indexOf(“h”)</code>&#x2F;&#x2F;索引h第一次出现的位置</li><li><code>indexOf(“h”,n)</code>&#x2F;&#x2F;n位之后出现h的位置</li><li><code>split(“,”)</code>&#x2F;&#x2F;根据,来切分字符串</li><li><code>replace(“h”,”H”)</code>&#x2F;&#x2F;用H代替h</li><li><code>toUpperCase()</code>&#x2F;&#x2F;全大写</li></ul><p>JS定义了ReExp()构造函数，用来创建文本匹配模式的对象。这些模式称为”正则表达式”。详细后续会详细介绍。</p><h4 id="布尔-Boolean类型"><a href="#布尔-Boolean类型" class="headerlink" title="(布尔)Boolean类型"></a>(布尔)Boolean类型</h4><ol><li>Boolean类型</li></ol><ul><li>仅有两个值</li><li>true：真值</li><li>false：假值</li><li>也代表1和0</li><li>实际运算中true &#x3D;1,false &#x3D; 0;</li></ul><ol start="2"><li>多用于结构控制语句，用于控制分支走向</li></ol><ul><li>If(true or false){}else{}</li><li>while(true or false){}</li></ul><h4 id="JavaScript中特殊类型"><a href="#JavaScript中特殊类型" class="headerlink" title="JavaScript中特殊类型"></a>JavaScript中特殊类型</h4><ol><li>null</li></ol><ul><li>null在程序中表示“无值”或者“无对象”</li><li>可以通过给一个变量赋值 null来清除变量的内容</li></ul><ol start="2"><li>undefined</li></ol><ul><li>声明了变量但从未赋值或者对象属性不存在</li></ul><p><code>注</code>：尽管null和undefined是不同的，但它们都表示”值的空缺”,两者往往可以互换，”&#x3D;&#x3D;”认为两者是相等的,必须要用&#x3D;&#x3D;&#x3D;严格相等来区分</p><h4 id="JavaScript中的对象类型"><a href="#JavaScript中的对象类型" class="headerlink" title="JavaScript中的对象类型"></a>JavaScript中的对象类型</h4><p>对象可以是JavaScript中的重中之重，是整个js的精华所在，任何语言，只要能实现面对对象编程，实现一切皆对象就是高级语言。</p><h5 id="什么是JavaScript对象？"><a href="#什么是JavaScript对象？" class="headerlink" title="什么是JavaScript对象？"></a>什么是JavaScript对象？</h5><p>对象是JS中最重要的元素，由属性和方法封装而成</p><p>用来描述对象特性的一组数据，也就是若干变量，通常称为属性。</p><p>用来操作对象特性的若干动作，也就是若干函数，通常称为方法。</p><ol><li>JS包含多种对象</li></ol><ul><li><p>全局对象<br>global object:全局对象的属性是全局定义的符号，JavaScript程序是可以直接使用，当JavaScript解释器启动时（web浏览器加载新页面的时候），它将创建一个新的全局对象，并给它一组定义的初始属性;</p><p>全局属性，比如undefined、Infinity和NaN；</p><p>全局函数,比如isNaN()、parseInt()和eval()；</p><p>构造函数,比如Date()、RegExp()、String()、Object()、和Array()；</p><p>全局对象，比如Math和JSON</p></li><li><p>内置对象</p><p>Array对象、Boolean对象、Date对象、Math对象、Number对象、Object对象、RegExp对象、String对象、Global对象、Function对象</p></li><li><p>自定义对象</p><p>var object &#x3D; {“name”:”minchao”,”age”:”18”,”sex”:”man”}</p></li><li><p>浏览器对象(常用的浏览器对象)</p><p>applet 当前文档中的小程序</p><p>document 当前窗口中的HTML文档</p><p>event 浏览器中发生的事件</p><p>history 浏览器访问过的url历史记录</p><p>location 浏览器当前显示网页的URL</p><p>mimeType 浏览器支持的特定MIME类型信息</p><p>navigator 当前浏览器</p><p>screen 用户屏幕</p><p>window 浏览器窗口或窗口中的框架</p></li><li><p>HTML DOM对象(跟上面浏览器对象可以合并)</p><p>alert()</p><p>confime()</p><p>prompt()</p></li><li><p>包装对象</p><p>需要注意的是，String(),Number(),Boolean()构造函数来显式创建包装对象</p></li></ul><ol start="2"><li>对象属性的引用</li></ol><ul><li>使用(.)运算符</li></ul><ol start="4"><li>对象方法的引用</li></ol><ul><li>ObjectName.methodName()</li></ul><h4 id="值类型和引用对象类型"><a href="#值类型和引用对象类型" class="headerlink" title="值类型和引用对象类型"></a>值类型和引用对象类型</h4><ol><li><p>原始值(undefined、null、布尔、数字和字符串)</p></li><li><p>对象(包括数组和函数)</p></li><li><p>两者有着根本区别：</p></li></ol><ul><li><p>原始值是不可更改的：任何方法都无法更改一个原始值  例如:字符串中所有的方法看上去返回一个修改后的字符串，实际上返回的是一个新的字符串值。</p></li><li><p>对象是可变的:它们的值是可修改的</p></li><li><p>原始值的比较是值的比较：只有它们的值相等时它们才相等</p></li><li><p>对象的比较是引用的比较，想要比较两个单独的对象或数组，则必须比较它们的属性或元素</p></li></ul><p>值类型理解：变量的交换等于在一个新的地方按照连锁店的规范标准（统一店面理解为相同的变量内容）新开一个分店，这样新开的店与其它旧店互不相关、各自运营。</p><p> function chainStore(){<br>  var store1&#x3D;’Nike China’;<br>  var store2&#x3D;store1;<br>  store1&#x3D;’Nike U.S.A.’;<br>  alert(store2);<br> }<br> chainStore();</p><p>引用类型理解：变量的交换等于把现有一间店的钥匙（变量引用地址）复制一把给了另外一个老板，此时两个老板同时管理一间店，两个老板的行为都有可能对一间店的运营造成影响。</p><p> function chainStore(){<br> var store1&#x3D;[‘Nike China’];<br> var store2&#x3D;store1;<br> alert(store2[0]); &#x2F;&#x2F;Nike China<br> store1[0]&#x3D;’Nike U.S.A.’;<br> alert(store2[0]); &#x2F;&#x2F;Nike U.S.A.<br> }<br> chainStore();</p><h4 id="JavaScript中数据类型的转换"><a href="#JavaScript中数据类型的转换" class="headerlink" title="JavaScript中数据类型的转换"></a>JavaScript中数据类型的转换</h4><ol><li>数据类型的隐式转换（自动转换）</li></ol><ul><li>JavaScript属于松散类型的语言</li><li>变量在声明时不需要指定数据类型</li><li>变量由赋值操作确定数据类型</li><li>不同类型数据在计算过程中会自动进行转换</li><li>数字+字符串——数字转换为字符串，与字符串拼接</li><li>数字+布尔——true转换为1，fasle转换为0</li><li>字符串+布尔值——布尔值转换为字符串true或false</li><li>布尔值+布尔值——布尔值转换为1或0</li></ul><ol start="2"><li>数据类型的显式转换（强转）</li></ol><ul><li>做显式类型转换最简单的方法就是使用Boolean()、Number()、String()或Object()函数。</li><li>toString()</li><li>转换成字符串</li><li>所有数据类型均可转换成字符串</li><li>parseInt()</li><li>强制转换成整数，如果不是则返回NaN</li><li>parsFloat()</li><li>强制转换成浮点数</li><li>typeof()</li><li>查询当前类型(返回string、number、boolean、object、function、undefined)</li><li>isNaN</li><li>用于判断是否为数字</li></ul><p><strong>注：<br>除了null和 undefined之外的任何值都具有 toString()方法。</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML中常见的长度单位</title>
    <link href="/2021/03/05/HTML-Length-px/"/>
    <url>/2021/03/05/HTML-Length-px/</url>
    
    <content type="html"><![CDATA[<h2 id="THML中常见的8种长度"><a href="#THML中常见的8种长度" class="headerlink" title="THML中常见的8种长度"></a>THML中常见的8种长度</h2><h3 id="1、常见的单位"><a href="#1、常见的单位" class="headerlink" title="1、常见的单位"></a>1、常见的单位</h3><p>px：像素（Pixel）,相对于设备的长度单位，像素是相对于显示器屏幕分辨率而言的。譬如，Windows的用户所使用的分辨率一般是96像素&#x2F;英寸。而MAC的用户所使用的分辨率一般是72像素&#x2F;英寸。</p><p>em：相对长度单位。相对于当前对象内文本的字体尺寸。如当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p><p>ex：相对长度单位。相对于字符“x”的高度。此高度通常为字体尺寸的一半。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。</p><p>pt：点（Point），绝对长度单位。</p><p>pc：派卡（Pica），绝对长度单位。相当于我国新四号铅字的尺寸。</p><p>in：英寸（Inch），绝对长度单位。</p><p>mm：毫米（Millimeter），绝对长度单位。</p><p>cm：厘米（Centimeter），绝对长度单位</p><h3 id="2、理解"><a href="#2、理解" class="headerlink" title="2、理解"></a>2、理解</h3><p>cm(厘米)也是随着显示器分辨率变化而变化的。</p><p>对于计算机的屏幕设备而言，像素(Pixel)或者说px是一个最基本的单位，就是一个点。其它所有的单位，都和像素成一个固定的比例换算关系。所有的长度单位基于屏幕进行显示的时候，都统一先换算成为像素的多少，然后进行显示。所以，就计算机的屏幕而言，相对长度和绝对长度没有本质差别。任何单位其实都是像素，差别只是比例不同。</p><p>如果把讨论扩展到其它输出设备，比如打印机，基本的长度单位可能不是像素，而是其它的和生活中的度量单位一致的单位了。</p><p>CSS绝对长度单位是对于输出设备(output device)而言的。拿pt来说，这是一个在文字排版工具(word,adobe等)中非常常用的字体单位，不管你的显示器分辨率是1024×768，还是800×600，同一篇文档打印在纸面上的结果是一样的。</p><p>写网页用哪个长度单位更好，是px还是pt呢？</p><p>我个人比较偏向px，因为px能够精确地表示元素在屏幕中的位置和大小，网页主要是为了屏幕显示，而不是为了打印等其它需要的。</p><h3 id="3、相对长度"><a href="#3、相对长度" class="headerlink" title="3、相对长度"></a>3、相对长度</h3><p>单位   说明</p><p>em   元素的字体高度</p><p>ex   字母x的高度</p><p>px   像素Pixels</p><p>%   百分比Percentage</p><p>4、换算的长度</p><p>转换公式：</p><p>px to em:Example:  12px &#x2F; 16px &#x3D; .75em</p><p>px to %:Example:  12px &#x2F; 16px * 100 &#x3D; 75%</p><p>px to pt:Example:   16px * 72 (72 points &#x3D; 1 inch) &#x2F; 96 (96 pixels per inch in Windows, 72 in Mac) &#x3D; 12pt</p><p>em to px:Example:  .75em * 16px &#x3D; 12px</p><p>em to %:Example:  .75em * 100 &#x3D; 75%</p><p>% to px:Example:   75 * 16px &#x2F; 100 &#x3D; 12px</p><p>% to em:Example:  75 &#x2F; 100 &#x3D; .75em</p><p>pt to px:Example:   12pt * 96ppi &#x2F; 72ppi &#x3D; 16px</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在看来，用px做字体单位在IE下无法用浏览器字体缩放的功能的缺点已经不再是那么重要了。</p><p>因为新版本ie7，ie8都已经支持整个网页的缩放功能，包括火狐默认也是缩放整个网页，而不是缩放css字体，单纯的缩放字体意义不大了。</p><p>另外：CSS3新增了一个相对单位：rem，这个单位引起了广泛的关注，意思是(root em)根em，区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。</p><p>目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。</p><h3 id="Rem的例子"><a href="#Rem的例子" class="headerlink" title="Rem的例子"></a>Rem的例子</h3><p>html { font-size: 62.5%;&#x2F;<em>10 ÷ 16 × 100% &#x3D; 62.5%</em>&#x2F; }</p><p>body { font-size: 1.4rem;&#x2F;<em>1.4 × 10px &#x3D; 14px</em>&#x2F; }</p><p> h1 { font-size: 2.4rem;&#x2F;<em>2.4 × 10px &#x3D; 24px</em>&#x2F; }</p><p> p {font-size:14px; font-size:1.4rem;}</p><p>IE8及之前版本的IE浏览器使用14像素</p><p>根元素中定义了一个基本字体大小为62.5%（也就是10px。设置这个值主要方便计算，如果没有设置，将是以“16px”为基准 ）。</p><p>从上面的计算结果，我们使用“rem尺寸字体”就像使用“px尺寸字体”一样的方便。</p><h3 id="页面加载自动生成meta标签，做屏幕自适应功能"><a href="#页面加载自动生成meta标签，做屏幕自适应功能" class="headerlink" title="页面加载自动生成meta标签，做屏幕自适应功能"></a>页面加载自动生成meta标签，做屏幕自适应功能</h3><p> &#x2F;**<br>  *</p><ul><li>viewport scale根据设备像素比自动生成</li><li>Html根元素font-size根据设备像素比自动生成</li><li>by MC<br>*&#x2F;</li></ul><p> (document.DOMContentLoaded &#x3D; function () {<br>     var meta &#x3D; document.createElement(“meta”),<br>         scale &#x3D; 1.0 &#x2F; window.devicePixelRatio;<br>     meta.name &#x3D; “viewport”;<br>     meta.content &#x3D; “target-densitydpi&#x3D;device-dpi,width&#x3D;device-width,minimum-scale&#x3D;” + scale + “,maximum-scale&#x3D;” + scale + “,initial-scale&#x3D;” + scale + “,user-scalable&#x3D;no”;<br>     document.head.appendChild(meta);<br>     document.documentElement.setAttribute(“style”, “font-size:” + 16 * window.devicePixelRatio + “px”);<br> })();</p>]]></content>
    
    
    <categories>
      
      <category>HTML5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript常用的方法</title>
    <link href="/2021/02/12/JavaScript-normal-functions/"/>
    <url>/2021/02/12/JavaScript-normal-functions/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的js方法"><a href="#常用的js方法" class="headerlink" title="常用的js方法"></a>常用的js方法</h1><h2 id="判断是否是电脑端"><a href="#判断是否是电脑端" class="headerlink" title="判断是否是电脑端"></a>判断是否是电脑端</h2><p> function isPC() {<br>     var userAgentInfo &#x3D; navigator.userAgent,<br>         Agents &#x3D; [“Android”, “iPhone”, “SymbianOS”, “Windows Phone”, “iPad”, “iPod”],<br>         flag &#x3D; true;<br>     for (var v &#x3D; 0; v &lt; Agents.length; v++) {<br>         if (userAgentInfo.indexOf(Agents[v]) &gt; 0) {<br>             flag &#x3D; false;<br>             break;<br>         }<br>     }<br>     return flag;<br> }</p><h2 id="改变url中的某一个参数"><a href="#改变url中的某一个参数" class="headerlink" title="改变url中的某一个参数"></a>改变url中的某一个参数</h2><p> &#x2F;*</p><ul><li>url 目标url</li><li>arg 需要替换的参数名称</li><li>arg_val 替换后的参数的值</li><li>return url 参数替换后的url<br><em>&#x2F;<br> function changeURLArg(url,arg,arg_val){<br>var pattern&#x3D;arg+’&#x3D;([^&amp;]</em>)’;<br>var replaceText&#x3D;arg+’&#x3D;’+arg_val;<br>if(url.match(pattern)){<br> var tmp&#x3D;’&#x2F;(‘+ arg+’&#x3D;)([^&amp;]*)&#x2F;gi’;<br> tmp&#x3D;url.replace(eval(tmp),replaceText);<br> return tmp;<br>}else{<br> if(url.match(‘[?]’)){<br>return url+’&amp;’+replaceText;<br> }else{<br>return url+’?’+replaceText;<br> }<br>}<br>return url+’\n’+arg+’\n’+arg_val;<br> }</li></ul><h2 id="判断当前浏览器类型"><a href="#判断当前浏览器类型" class="headerlink" title="判断当前浏览器类型"></a>判断当前浏览器类型</h2><p> function myBrowser(){</p><pre><code class="hljs">var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断是否Safari浏览器if (isIE) &#123;    var IE5 = IE55 = IE6 = IE7 = IE8 = false;    var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);    reIE.test(userAgent);    var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);    IE55 = fIEVersion == 5.5;    IE6 = fIEVersion == 6.0;    IE7 = fIEVersion == 7.0;    IE8 = fIEVersion == 8.0;    if (IE55) &#123;        return &quot;IE55&quot;;    &#125;    if (IE6) &#123;        return &quot;IE6&quot;;    &#125;    if (IE7) &#123;        return &quot;IE7&quot;;    &#125;    if (IE8) &#123;        return &quot;IE8&quot;;    &#125;&#125;//isIE endif (isFF) &#123;    return &quot;FF&quot;;&#125;if (isOpera) &#123;    return &quot;Opera&quot;;&#125;</code></pre><p> }&#x2F;&#x2F;myBrowser() end<br> &#x2F;&#x2F;以下是调用上面的函数<br> if (myBrowser() &#x3D;&#x3D; “FF”) {<br>     alert(“我是 Firefox”);<br> }<br> if (myBrowser() &#x3D;&#x3D; “Opera”) {<br>     alert(“我是 Opera”);<br> }<br> if (myBrowser() &#x3D;&#x3D; “Safari”) {<br>     alert(“我是 Safari”);<br> }<br> if (myBrowser() &#x3D;&#x3D; “IE55”) {<br>     alert(“我是 IE5.5”);<br> }<br> if (myBrowser() &#x3D;&#x3D; “IE6”) {<br>     alert(“我是 IE6”);<br> }<br> if (myBrowser() &#x3D;&#x3D; “IE7”) {<br>     alert(“我是 IE7”);<br> }<br> if (myBrowser() &#x3D;&#x3D; “IE8”) {<br>     alert(“我是 IE8”);<br> }</p><h2 id="Array相关"><a href="#Array相关" class="headerlink" title="Array相关"></a>Array相关</h2><h3 id="arrayEqual判断两个数组是否相等"><a href="#arrayEqual判断两个数组是否相等" class="headerlink" title="arrayEqual判断两个数组是否相等"></a>arrayEqual判断两个数组是否相等</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 判断两个数组是否相等</li><li>@param {Array} arr1</li><li>@param {Array} arr2</li><li>@return {Boolean}<br>*&#x2F;<br> function arrayEqual(arr1, arr2) {<br>   if (arr1 &#x3D;&#x3D;&#x3D; arr2) return true;<br>   if (arr1.length !&#x3D; arr2.length) return false;<br>   for (var i &#x3D; 0; i &lt; arr1.length; ++i) {<br>   if (arr1[i] !&#x3D;&#x3D; arr2[i]) return false;<br>   }<br>   return true;<br> }</li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="hasClass判断元素是否有某个class"><a href="#hasClass判断元素是否有某个class" class="headerlink" title="hasClass判断元素是否有某个class"></a>hasClass判断元素是否有某个class</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 判断元素是否有某个class</li><li>@param {HTMLElement} ele</li><li>@param {String} cls</li><li>@return {Boolean}<br>*&#x2F;<br> function hasClass(ele, cls) {<br>   return (new RegExp(‘(\s|^)’ + cls + ‘(\s|$)’)).test(ele.className);<br> }</li></ul><h3 id="addClass为元素添加class"><a href="#addClass为元素添加class" class="headerlink" title="addClass为元素添加class"></a>addClass为元素添加class</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   为元素添加class</li><li>@param  {HTMLElement} ele</li><li>@param  {String} cls<br>*&#x2F;<br> function addClass(ele, cls) {<br>   if (!hasClass(ele, cls)) {<br>   ele.className +&#x3D; ‘ ‘ + cls;<br>   }<br> }</li></ul><h3 id="removeClass为元素移除class"><a href="#removeClass为元素移除class" class="headerlink" title="removeClass为元素移除class"></a>removeClass为元素移除class</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 为元素移除class</li><li>@param {HTMLElement} ele</li><li>@param {String} cls<br>*&#x2F;<br> var hasClass &#x3D; require(‘.&#x2F;hasClass’);<br> function removeClass(ele, cls) {<br>   if (hasClass(ele, cls)) {<br>   var reg &#x3D; new RegExp(‘(\s|^)’ + cls + ‘(\s|$)’);<br>   ele.className &#x3D; ele.className.replace(reg, ‘ ‘);<br>   }<br> }</li></ul><h2 id="Cookie操作"><a href="#Cookie操作" class="headerlink" title="Cookie操作"></a>Cookie操作</h2><h3 id="getCookie根据name读取cookie"><a href="#getCookie根据name读取cookie" class="headerlink" title="getCookie根据name读取cookie"></a>getCookie根据name读取cookie</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 根据name读取cookie</li><li>@param  {String} name</li><li>@return {String}<br>*&#x2F;<br> function getCookie(name) {<br>   var arr &#x3D; document.cookie.replace(&#x2F;\s&#x2F;g, “”).split(‘;’);<br>   for (var i &#x3D; 0; i &lt; arr.length; i++) {<br>   var tempArr &#x3D; arr[i].split(‘&#x3D;’);<br>   if (tempArr[0] &#x3D;&#x3D; name) {<br>       return decodeURIComponent(tempArr[1]);<br>   }<br>   }<br>   return ‘’;<br> }</li></ul><h3 id="setCookie-设置Cookie"><a href="#setCookie-设置Cookie" class="headerlink" title="setCookie 设置Cookie"></a>setCookie 设置Cookie</h3><p> &#x2F;**<br>  *</p><ul><li>@desc  设置Cookie</li><li>@param {String} name</li><li>@param {String} value</li><li>@param {Number} days<br>*&#x2F;<br> function setCookie(name, value, days) {<br>   var date &#x3D; new Date();<br>   date.setDate(date.getDate() + days);<br>   document.cookie &#x3D; name + ‘&#x3D;’ + value + ‘;expires&#x3D;’ + date;<br> }</li></ul><h3 id="removeCookie根据name删除cookie"><a href="#removeCookie根据name删除cookie" class="headerlink" title="removeCookie根据name删除cookie"></a>removeCookie根据name删除cookie</h3><p> var setCookie &#x3D; require(‘.&#x2F;setCookie’);<br> &#x2F;**<br>  *</p><ul><li>@desc 根据name删除cookie</li><li>@param  {String} name<br>*&#x2F;<br> function removeCookie(name) {<br>   &#x2F;&#x2F; 设置已过期，系统会立刻删除cookie<br>   setCookie(name, ‘1’, -1);<br> }</li></ul><h2 id="Device设备相关"><a href="#Device设备相关" class="headerlink" title="Device设备相关"></a>Device设备相关</h2><h3 id="getExplore获取浏览器类型和版本"><a href="#getExplore获取浏览器类型和版本" class="headerlink" title="getExplore获取浏览器类型和版本"></a>getExplore获取浏览器类型和版本</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 获取浏览器类型和版本</li><li>@return {String}<br>*&#x2F;<br> function getExplore() {<br>   var sys &#x3D; {},<br>   ua &#x3D; navigator.userAgent.toLowerCase(),<br>   s;<br>   (s &#x3D; ua.match(&#x2F;rv:([\d.]+)) like gecko&#x2F;)) ? sys.ie &#x3D; s[1]:<br>   (s &#x3D; ua.match(&#x2F;msie ([\d.]+)&#x2F;)) ? sys.ie &#x3D; s[1] :<br>   (s &#x3D; ua.match(&#x2F;edge/([\d.]+)&#x2F;)) ? sys.edge &#x3D; s[1] :<br>   (s &#x3D; ua.match(&#x2F;firefox/([\d.]+)&#x2F;)) ? sys.firefox &#x3D; s[1] :<br>   (s &#x3D; ua.match(&#x2F;(?:opera|opr).([\d.]+)&#x2F;)) ? sys.opera &#x3D; s[1] :<br>   (s &#x3D; ua.match(&#x2F;chrome/([\d.]+)&#x2F;)) ? sys.chrome &#x3D; s[1] :<br>   (s &#x3D; ua.match(&#x2F;version/([\d.]+).*safari&#x2F;)) ? sys.safari &#x3D; s[1] : 0;<br>   &#x2F;&#x2F; 根据关系进行判断<br>   if (sys.ie) return (‘IE: ‘ + sys.ie)<br>   if (sys.edge) return (‘EDGE: ‘ + sys.edge)<br>   if (sys.firefox) return (‘Firefox: ‘ + sys.firefox)<br>   if (sys.chrome) return (‘Chrome: ‘ + sys.chrome)<br>   if (sys.opera) return (‘Opera: ‘ + sys.opera)<br>   if (sys.safari) return (‘Safari: ‘ + sys.safari)<br>   return ‘Unkonwn’<br> }</li></ul><h3 id="getOS获取操作系统类型"><a href="#getOS获取操作系统类型" class="headerlink" title="getOS获取操作系统类型"></a>getOS获取操作系统类型</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 获取操作系统类型</li><li>@return {String}<br>*&#x2F;<br> function getOS() {<br>   var userAgent &#x3D; ‘navigator’ in window &amp;&amp; ‘userAgent’ in navigator &amp;&amp; navigator.userAgent.toLowerCase() || ‘’;<br>   var vendor &#x3D; ‘navigator’ in window &amp;&amp; ‘vendor’ in navigator &amp;&amp; navigator.vendor.toLowerCase() || ‘’;<br>   var appVersion &#x3D; ‘navigator’ in window &amp;&amp; ‘appVersion’ in navigator &amp;&amp; navigator.appVersion.toLowerCase() || ‘’;<br>   if (&#x2F;mac&#x2F;i.test(appVersion)) return ‘MacOSX’<br>   if (&#x2F;win&#x2F;i.test(appVersion)) return ‘windows’<br>   if (&#x2F;linux&#x2F;i.test(appVersion)) return ‘linux’<br>   if (&#x2F;iphone&#x2F;i.test(userAgent) || &#x2F;ipad&#x2F;i.test(userAgent) || &#x2F;ipod&#x2F;i.test(userAgent)) ‘ios’<br>   if (&#x2F;android&#x2F;i.test(userAgent)) return ‘android’<br>   if (&#x2F;win&#x2F;i.test(appVersion) &amp;&amp; &#x2F;phone&#x2F;i.test(userAgent)) return ‘windowsPhone’<br> }</li></ul><h2 id="Dom操作"><a href="#Dom操作" class="headerlink" title="Dom操作"></a>Dom操作</h2><h3 id="getScrollTop-获取滚动条距顶部的距离"><a href="#getScrollTop-获取滚动条距顶部的距离" class="headerlink" title="getScrollTop 获取滚动条距顶部的距离"></a>getScrollTop 获取滚动条距顶部的距离</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 获取滚动条距顶部的距离<br>*&#x2F;<br> function getScrollTop() {<br>   return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;<br> }</li></ul><h3 id="setScrollTop设置滚动条距顶部的距离"><a href="#setScrollTop设置滚动条距顶部的距离" class="headerlink" title="setScrollTop设置滚动条距顶部的距离"></a>setScrollTop设置滚动条距顶部的距离</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 设置滚动条距顶部的距离<br>*&#x2F;<br> function setScrollTop(value) {<br>   window.scrollTo(0, value);<br>   return value;<br> }</li></ul><h3 id="offset获取一个元素的距离文档-document-的位置，类似jQ中的offset"><a href="#offset获取一个元素的距离文档-document-的位置，类似jQ中的offset" class="headerlink" title="offset获取一个元素的距离文档(document)的位置，类似jQ中的offset()"></a>offset获取一个元素的距离文档(document)的位置，类似jQ中的offset()</h3><p> &#x2F;**<br>  *</p><ul><li>@desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()</li><li>@param {HTMLElement} ele</li><li>@returns { {left: number, top: number} }<br>*&#x2F;<br> function offset(ele) {<br>   var pos &#x3D; {<br>   left: 0,<br>   top: 0<br>   };<br>   while (ele) {<br>   pos.left +&#x3D; ele.offsetLeft;<br>   pos.top +&#x3D; ele.offsetTop;<br>   ele &#x3D; ele.offsetParent;<br>   };<br>   return pos;<br> }</li></ul><h3 id="scrollTo-滚动条平滑滚动到-to-指定位置"><a href="#scrollTo-滚动条平滑滚动到-to-指定位置" class="headerlink" title="scrollTo 滚动条平滑滚动到${to}指定位置"></a>scrollTo 滚动条平滑滚动到${to}指定位置</h3><p> var getScrollTop &#x3D; require(‘.&#x2F;getScrollTop’);<br> var setScrollTop &#x3D; require(‘.&#x2F;setScrollTop’);<br> var requestAnimFrame &#x3D; (function () {<br>     return window.requestAnimationFrame ||<br>         window.webkitRequestAnimationFrame ||<br>         window.mozRequestAnimationFrame ||<br>         function (callback) {<br>             window.setTimeout(callback, 1000 &#x2F; 60);<br>         };<br> })();<br> &#x2F;**<br>  *</p><ul><li>@desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置</li><li>@param {Number} to</li><li>@param {Number} duration<br>*&#x2F;<br> function scrollTo(to, duration) {<br>   if (duration &lt; 0) {<br>   setScrollTop(to);<br>   return<br>   }<br>   var diff &#x3D; to - getScrollTop();<br>   if (diff &#x3D;&#x3D;&#x3D; 0) return<br>var step &#x3D; diff &#x2F; duration* 10;<br>   requestAnimationFrame(<br>   function () {<br>       if (Math.abs(step) &gt; Math.abs(diff)) {<br>           setScrollTop(getScrollTop() + diff);<br>           return;<br>       }<br>       setScrollTop(getScrollTop() + step);<br>       if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;&#x3D; to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;&#x3D; to) {<br>           return;<br>       }<br>       scrollTo(to, duration - 16);<br>   });</li></ul><p> }</p><h2 id="Keycode键盘相关"><a href="#Keycode键盘相关" class="headerlink" title="Keycode键盘相关"></a>Keycode键盘相关</h2><p> var keyCodeMap &#x3D; {<br>     8: ‘Backspace’,<br>     9: ‘Tab’,<br>     13: ‘Enter’,<br>     16: ‘Shift’,<br>     17: ‘Ctrl’,<br>     18: ‘Alt’,<br>     19: ‘Pause’,<br>     20: ‘Caps Lock’,<br>     27: ‘Escape’,<br>     32: ‘Space’,<br>     33: ‘Page Up’,<br>     34: ‘Page Down’,<br>     35: ‘End’,<br>     36: ‘Home’,<br>     37: ‘Left’,<br>     38: ‘Up’,<br>     39: ‘Right’,<br>     40: ‘Down’,<br>     42: ‘Print Screen’,<br>     45: ‘Insert’,<br>     46: ‘Delete’,<br>     48: ‘0’,<br>     49: ‘1’,<br>     50: ‘2’,<br>     51: ‘3’,<br>     52: ‘4’,<br>     53: ‘5’,<br>     54: ‘6’,<br>     55: ‘7’,<br>     56: ‘8’,<br>     57: ‘9’,<br>     65: ‘A’,<br>     66: ‘B’,<br>     67: ‘C’,<br>     68: ‘D’,<br>     69: ‘E’,<br>     70: ‘F’,<br>     71: ‘G’,<br>     72: ‘H’,<br>     73: ‘I’,<br>     74: ‘J’,<br>     75: ‘K’,<br>     76: ‘L’,<br>     77: ‘M’,<br>     78: ‘N’,<br>     79: ‘O’,<br>     80: ‘P’,<br>     81: ‘Q’,<br>     82: ‘R’,<br>     83: ‘S’,<br>     84: ‘T’,<br>     85: ‘U’,<br>     86: ‘V’,<br>     87: ‘W’,<br>     88: ‘X’,<br>     89: ‘Y’,<br>     90: ‘Z’,<br>     91: ‘Windows’,<br>     93: ‘Right Click’,<br>     96: ‘Numpad 0’,<br>     97: ‘Numpad 1’,<br>     98: ‘Numpad 2’,<br>     99: ‘Numpad 3’,<br>     100: ‘Numpad 4’,<br>     101: ‘Numpad 5’,<br>     102: ‘Numpad 6’,<br>     103: ‘Numpad 7’,<br>     104: ‘Numpad 8’,<br>     105: ‘Numpad 9’,<br>     106: ‘Numpad <em>‘,<br>     107: ‘Numpad +’,<br>     109: ‘Numpad -‘,<br>     110: ‘Numpad .’,<br>     111: ‘Numpad &#x2F;‘,<br>     112: ‘F1’,<br>     113: ‘F2’,<br>     114: ‘F3’,<br>     115: ‘F4’,<br>     116: ‘F5’,<br>     117: ‘F6’,<br>     118: ‘F7’,<br>     119: ‘F8’,<br>     120: ‘F9’,<br>     121: ‘F10’,<br>     122: ‘F11’,<br>     123: ‘F12’,<br>     144: ‘Num Lock’,<br>     145: ‘Scroll Lock’,<br>     182: ‘My Computer’,<br>     183: ‘My Calculator’,<br>     186: ‘;’,<br>     187: ‘&#x3D;’,<br>     188: ‘,’,<br>     189: ‘-‘,<br>     190: ‘.’,<br>     191: ‘&#x2F;‘,<br>     192: ‘&#96;’,<br>     219: ‘[‘,<br>     220: ‘\‘,<br>     221: ‘]’,<br>     222: ‘&#39;‘<br> };<br> &#x2F;</em>*</p><ul><li>@desc 根据keycode获得键名</li><li>@param  {Number} keycode</li><li>@return {String}<br>*&#x2F;<br> function getKeyName(keycode) {<br>   if (keyCodeMap[keycode]) {<br>   return keyCodeMap[keycode];<br>   } else {<br>   console.log(‘Unknow Key(Key Code:’ + keycode + ‘)’);<br>   return ‘’;<br>   }<br> };</li></ul><h2 id="Object对象操作"><a href="#Object对象操作" class="headerlink" title="Object对象操作"></a>Object对象操作</h2><h3 id="deepClone深拷贝"><a href="#deepClone深拷贝" class="headerlink" title="deepClone深拷贝"></a>deepClone深拷贝</h3><p> &#x2F;**</p><ul><li>@desc 深拷贝，支持常见类型</li><li>@param {Any} values<br>*&#x2F;<br> function deepClone(values) {<br>   var copy;<br>   &#x2F;&#x2F; 处理3个简单类型，null或未定义<br>   if (null &#x3D;&#x3D; values || “object” !&#x3D; typeof values) return values;<br>   &#x2F;&#x2F; 处理日期类型<br>   if (values instanceof Date) {<br>   copy &#x3D; new Date();<br>   copy.setTime(values.getTime());<br>   return copy;<br>   }<br>   &#x2F;&#x2F; 处理数组<br>   if (values instanceof Array) {<br>   copy &#x3D; [];<br>   for (var i &#x3D; 0, len &#x3D; values.length; i &lt; len; i++) {<br>       copy[i] &#x3D; deepClone(values[i]);<br>   }<br>   return copy;<br>   }<br>   &#x2F;&#x2F; 处理对象<br>   if (values instanceof Object) {<br>   copy &#x3D; {};<br>   for (var attr in values) {<br>       if (values.hasOwnProperty(attr)) copy[attr] &#x3D; deepClone(values[attr]);<br>   }<br>   return copy;<br>   }<br>   throw new Error(“Unable to copy values! Its type isn’t supported.”);<br> }</li></ul><h3 id="isEmptyObject-对象判空"><a href="#isEmptyObject-对象判空" class="headerlink" title="isEmptyObject 对象判空"></a>isEmptyObject 对象判空</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   判断<code>obj</code>是否为空</li><li>@param  {Object} obj</li><li>@return {Boolean}<br>*&#x2F;<br> function isEmptyObject(obj) {<br>   if (!obj || typeof obj !&#x3D;&#x3D; ‘object’ || Array.isArray(obj))<br>   return false<br>   return !Object.keys(obj).length<br> }</li></ul><h2 id="Random随机函数的应用"><a href="#Random随机函数的应用" class="headerlink" title="Random随机函数的应用"></a>Random随机函数的应用</h2><h3 id="randomColor随机生成颜色"><a href="#randomColor随机生成颜色" class="headerlink" title="randomColor随机生成颜色"></a>randomColor随机生成颜色</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 随机生成颜色</li><li>@return {String}<br><em>&#x2F;<br> function randomColor() {<br>return ‘#’ + (‘00000’ + (Math.random()</em> 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);<br> }</li></ul><h3 id="randomNum-生成指定范随机数"><a href="#randomNum-生成指定范随机数" class="headerlink" title="randomNum 生成指定范随机数"></a>randomNum 生成指定范随机数</h3><p> &#x2F;**<br>  *</p><ul><li>@desc 生成指定范围随机数</li><li>@param  {Number} min</li><li>@param  {Number} max</li><li>@return {Number}<br><em>&#x2F;<br> function randomNum(min, max) {<br>return Math.floor(min + Math.random()</em> (max - min));<br> }</li></ul><h2 id="Regexp正则对象"><a href="#Regexp正则对象" class="headerlink" title="Regexp正则对象"></a>Regexp正则对象</h2><h3 id="isEmail"><a href="#isEmail" class="headerlink" title="isEmail"></a>isEmail</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   判断是否为邮箱地址</li><li>@param  {String}  str</li><li>@return {Boolean}<br><em>&#x2F;<br> function isEmail(str) {<br>   return &#x2F;\w+([-+.]\w+)</em>@\w+([-.]\w+)<em>.\w+([-.]\w+)</em>&#x2F;.test(str);<br> }</li></ul><h3 id="isIdCard是否为身份证号"><a href="#isIdCard是否为身份证号" class="headerlink" title="isIdCard是否为身份证号"></a>isIdCard是否为身份证号</h3><p> &#x2F;**<br>  *</p><ul><li>@desc  判断是否为身份证号</li><li>@param  {String|Number} str</li><li>@return {Boolean}<br>*&#x2F;<br> function isIdCard(str) {<br>   return &#x2F;^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$&#x2F;.test(str)<br> }</li></ul><h3 id="isUrl是否为URL地址"><a href="#isUrl是否为URL地址" class="headerlink" title="isUrl是否为URL地址"></a>isUrl是否为URL地址</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   判断是否为URL地址</li><li>@param  {String} str</li><li>@return {Boolean}<br><em>&#x2F;<br> function isUrl(str) {<br>   return &#x2F;[-a-zA-Z0-9@:%._+<del>#&#x3D;]{2,256}.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.</del>#?&amp;&#x2F;&#x2F;&#x3D;]</em>)&#x2F;i.test(str);<br> }</li></ul><h2 id="String字符串相关"><a href="#String字符串相关" class="headerlink" title="String字符串相关"></a>String字符串相关</h2><h3 id="digitUppercase现金额转大写"><a href="#digitUppercase现金额转大写" class="headerlink" title="digitUppercase现金额转大写"></a>digitUppercase现金额转大写</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   现金额转大写</li><li>@param  {Number} n</li><li>@return {String}<br>*&#x2F;<br> function digitUppercase(n) {<br>   var fraction &#x3D; [‘角’, ‘分’];<br>   var digit &#x3D; [<br>   ‘零’, ‘壹’, ‘贰’, ‘叁’, ‘肆’,<br>   ‘伍’, ‘陆’, ‘柒’, ‘捌’, ‘玖’<br>   ];<br>   var unit &#x3D; [<br>   [‘元’, ‘万’, ‘亿’],<br>   [‘’, ‘拾’, ‘佰’, ‘仟’]<br>   ];<br>   var head &#x3D; n &lt; 0 ? ‘欠’ : ‘’;<br>   n &#x3D; Math.abs(n);<br>   var s &#x3D; ‘’;<br>   for (var i &#x3D; 0; i &lt; fraction.length; i++) {<br>   s +&#x3D; (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(&#x2F;零.&#x2F;, ‘’);<br>   }<br>   s &#x3D; s || ‘整’;<br>   n &#x3D; Math.floor(n);<br>   for (var i &#x3D; 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {<br>   var p &#x3D; ‘’;<br>   for (var j &#x3D; 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {<br>       p &#x3D; digit[n % 10] + unit[1][j] + p;<br>       n &#x3D; Math.floor(n &#x2F; 10);<br>   }<br>   s &#x3D; p.replace(&#x2F;(零.)*零$&#x2F;, ‘’).replace(&#x2F;^$&#x2F;, ‘零’) + unit[0][i] + s;<br>   }<br>   return head + s.replace(&#x2F;(零.)*零元&#x2F;, ‘元’)<br>   .replace(&#x2F;(零.)+&#x2F;g, ‘零’)<br>   .replace(&#x2F;^整$&#x2F;, ‘零元整’);</li></ul><p> };</p><h2 id="Support浏览器支持类型判断"><a href="#Support浏览器支持类型判断" class="headerlink" title="Support浏览器支持类型判断"></a>Support浏览器支持类型判断</h2><h2 id="isSupportWebP-判断浏览器是否支持webP格式图片"><a href="#isSupportWebP-判断浏览器是否支持webP格式图片" class="headerlink" title="isSupportWebP 判断浏览器是否支持webP格式图片"></a>isSupportWebP 判断浏览器是否支持webP格式图片</h2><p> &#x2F;**<br>  *</p><ul><li>@desc 判断浏览器是否支持webP格式图片</li><li>@return {Boolean}<br>*&#x2F;<br> function isSupportWebP() {<br>   return !![].map &amp;&amp; document.createElement(‘canvas’).toDataURL(‘image&#x2F;webp’).indexOf(‘data:image&#x2F;webp’) &#x3D;&#x3D; 0;<br> }</li></ul><h2 id="Time时间处理"><a href="#Time时间处理" class="headerlink" title="Time时间处理"></a>Time时间处理</h2><h3 id="formatPassTime距现在的已过时间"><a href="#formatPassTime距现在的已过时间" class="headerlink" title="formatPassTime距现在的已过时间"></a>formatPassTime距现在的已过时间</h3><p> &#x2F;**</p><ul><li>@desc   格式化${startTime}距现在的已过时间</li><li>@param  {Date} startTime</li><li>@return {String}<br>*&#x2F;<br> function formatPassTime(startTime) {<br>   var currentTime &#x3D; Date.parse(new Date()),<br>   time &#x3D; currentTime - startTime,</li></ul><p>day &#x3D; parseInt(time &#x2F; (1000* 60 <em>60</em> 24)),<br>         hour &#x3D; parseInt(time &#x2F; (1000 <em>60</em> 60)),<br>         min &#x3D; parseInt(time &#x2F; (1000 * 60)),<br>         month &#x3D; parseInt(day &#x2F; 30),<br>         year &#x3D; parseInt(month &#x2F; 12);<br>     if (year) return year + “年前”<br>     if (month) return month + “个月前”<br>     if (day) return day + “天前”<br>     if (hour) return hour + “小时前”<br>     if (min) return min + “分钟前”<br>     else return ‘刚刚’<br> }</p><h3 id="formatRemainTime距xxx的剩余时间"><a href="#formatRemainTime距xxx的剩余时间" class="headerlink" title="formatRemainTime距xxx的剩余时间"></a>formatRemainTime距xxx的剩余时间</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   格式化现在距${endTime}的剩余时间</li><li>@param  {Date} endTime  </li><li>@return {String}<br>*&#x2F;<br> function formatRemainTime(endTime) {<br>   var startDate &#x3D; new Date(); &#x2F;&#x2F;开始时间<br>   var endDate &#x3D; new Date(endTime); &#x2F;&#x2F;结束时间<br>   var t &#x3D; endDate.getTime() - startDate.getTime(); &#x2F;&#x2F;时间差<br>   var d &#x3D; 0,<br>   h &#x3D; 0,<br>   m &#x3D; 0,<br>   s &#x3D; 0;<br>   if (t &gt;&#x3D; 0) {<br>   d &#x3D; Math.floor(t &#x2F; 1000 &#x2F; 3600 &#x2F; 24);<br>   h &#x3D; Math.floor(t &#x2F; 1000 &#x2F; 60 &#x2F; 60 % 24);<br>   m &#x3D; Math.floor(t &#x2F; 1000 &#x2F; 60 % 60);<br>   s &#x3D; Math.floor(t &#x2F; 1000 % 60);<br>   }<br>   return d + “天 “ + h + “小时 “ + m + “分钟 “ + s + “秒”;<br> }</li></ul><h3 id="Format：格式化"><a href="#Format：格式化" class="headerlink" title="Format：格式化"></a>Format：格式化</h3><p> var d &#x3D; new Date(2013, 0, 1);</p><p> d.toString()<br> &#x2F;&#x2F; “Tue Jan 01 2013 00:00:00 GMT+0800 (CST)”</p><p> d.toUTCString()<br> &#x2F;&#x2F; “Mon, 31 Dec 2012 16:00:00 GMT”</p><p> d.toISOString()<br> &#x2F;&#x2F; “2012-12-31T16:00:00.000Z”</p><p> d.toJSON()<br> &#x2F;&#x2F; “2012-12-31T16:00:00.000Z”</p><p> d.toDateString() &#x2F;&#x2F; “Tue Jan 01 2013”</p><p> d.toTimeString() &#x2F;&#x2F; “00:00:00 GMT+0800 (CST)”</p><p> d.toLocaleDateString()<br> &#x2F;&#x2F; 中文版浏览器为”2013年1月1日”<br> &#x2F;&#x2F; 英文版浏览器为”1&#x2F;1&#x2F;2013”</p><p> d.toLocaleTimeString()<br> &#x2F;&#x2F; 中文版浏览器为”上午12:00:00”<br> &#x2F;&#x2F; 英文版浏览器为”12:00:00 AM”</p><h3 id="Date-Format-fmt"><a href="#Date-Format-fmt" class="headerlink" title="Date.Format(fmt)"></a>Date.Format(fmt)</h3><p> &#x2F;&#x2F; 对Date的扩展，将 Date 转化为指定格式的String<br> &#x2F;&#x2F; 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符，<br> &#x2F;&#x2F; 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字)<br> &#x2F;&#x2F; 例子：<br> &#x2F;&#x2F; (new Date()).Format(“yyyy-MM-dd hh:mm:ss.S”) &#x3D;&#x3D;&gt; 2006-07-02 08:09:04.423<br> &#x2F;&#x2F; (new Date()).Format(“yyyy-M-d h:m:s.S”)      &#x3D;&#x3D;&gt; 2006-7-2 8:9:4.18<br> &#x2F;&#x2F;(new Date()).Format(“yyyy&#x2F;M&#x2F;d h:m:s.S”)      &#x3D;&#x3D;&gt; 2006&#x2F;7&#x2F;2 8:9:4.18<br> Date.prototype.Format &#x3D; function (fmt) { &#x2F;&#x2F;author: meizz<br>     var o &#x3D; {<br>         “M+”: this.getMonth() + 1, &#x2F;&#x2F;月份<br>         “d+”: this.getDate(), &#x2F;&#x2F;日<br>         “h+”: this.getHours(), &#x2F;&#x2F;小时<br>         “m+”: this.getMinutes(), &#x2F;&#x2F;分<br>         “s+”: this.getSeconds(), &#x2F;&#x2F;秒<br>         “q+”: Math.floor((this.getMonth() + 3) &#x2F; 3), &#x2F;&#x2F;季度<br>         “S”: this.getMilliseconds() &#x2F;&#x2F;毫秒<br>     };<br>     if (&#x2F;(y+)&#x2F;.test(fmt)) fmt &#x3D; fmt.replace(RegExp.$1, (this.getFullYear() + “”).substr(4 - RegExp.$1.length));<br>     for (var k in o)<br>     if (new RegExp(“(“ + k + “)”).test(fmt)) fmt &#x3D; fmt.replace(RegExp.$1, (RegExp.$1.length &#x3D;&#x3D; 1) ? (o[k]) : ((“00” + o[k]).substr((“” + o[k]).length)));<br>     return fmt;<br> }</p><p> &#x2F;&#x2F;调用：<br> &#x2F;&#x2F;var time1 &#x3D; new Date().Format(“yyyy-MM-dd”);<br> &#x2F;&#x2F;var time2 &#x3D; new Date().Format(“yyyy-MM-dd hh:mm:ss”);</p><h3 id="Date-pattern年月日季度星期时分秒毫秒"><a href="#Date-pattern年月日季度星期时分秒毫秒" class="headerlink" title="Date.pattern年月日季度星期时分秒毫秒"></a>Date.pattern年月日季度星期时分秒毫秒</h3><p> &#x2F;**</p><ul><li>对Date的扩展，将 Date 转化为指定格式的String <em>月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)<br>可以用 1-2 个占位符</em> 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) <em>eg:</em> (new<br>   Date()).pattern(“yyyy-MM-dd hh:mm:ss.S”)&#x3D;&#x3D;&gt; 2006-07-02 08:09:04.423</li><li>(new Date()).pattern(“yyyy-MM-dd E HH:mm:ss”) &#x3D;&#x3D;&gt; 2009-03-10 二 20:09:04</li><li>(new Date()).pattern(“yyyy-MM-dd EE hh:mm:ss”) &#x3D;&#x3D;&gt; 2009-03-10 周二 08:09:04</li><li>(new Date()).pattern(“yyyy-MM-dd EEE hh:mm:ss”) &#x3D;&#x3D;&gt; 2009-03-10 星期二 08:09:04</li><li>(new Date()).pattern(“yyyy-M-d h:m:s.S”) &#x3D;&#x3D;&gt; 2006-7-2 8:9:4.18<br>**&#x2F;<br> Date.prototype.pattern&#x3D;function(fmt) {<br>   var o &#x3D; {<br>   “M+” : this.getMonth()+1, &#x2F;&#x2F;月份<br>   “d+” : this.getDate(), &#x2F;&#x2F;日<br>   “h+” : this.getHours()%12 &#x3D;&#x3D; 0 ? 12 : this.getHours()%12, &#x2F;&#x2F;小时<br>   “H+” : this.getHours(), &#x2F;&#x2F;小时<br>   “m+” : this.getMinutes(), &#x2F;&#x2F;分<br>   “s+” : this.getSeconds(), &#x2F;&#x2F;秒<br>   “q+” : Math.floor((this.getMonth()+3)&#x2F;3), &#x2F;&#x2F;季度<br>   “S” : this.getMilliseconds() &#x2F;&#x2F;毫秒<br>   };<br>   &#x2F;&#x2F; var week &#x3D; {<br>   &#x2F;&#x2F; “0” : “&#x2F;u65e5”,<br>   &#x2F;&#x2F; “1” : “&#x2F;u4e00”,<br>   &#x2F;&#x2F; “2” : “&#x2F;u4e8c”,<br>   &#x2F;&#x2F; “3” : “&#x2F;u4e09”,<br>   &#x2F;&#x2F; “4” : “&#x2F;u56db”,<br>   &#x2F;&#x2F; “5” : “&#x2F;u4e94”,<br>   &#x2F;&#x2F; “6” : “&#x2F;u516d”<br>   &#x2F;&#x2F; };<br>   var week &#x3D; {<br>   “0” : “日”,<br>   “1” : “一”,<br>   “2” : “二”,<br>   “3” : “三”,<br>   “4” : “四”,<br>   “5” : “五”,<br>   “6” : “六”<br>   };<br>   if(&#x2F;(y+)&#x2F;.test(fmt)){<br>   fmt&#x3D;fmt.replace(RegExp.$1, (this.getFullYear()+””).substr(4 - RegExp.$1.length));<br>   }<br>   if(&#x2F;(E+)&#x2F;.test(fmt)){<br>   fmt&#x3D;fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? “星期” : “周”) : “”)+week[this.getDay()+””]);<br>   }<br>   for(var k in o){<br>   if(new RegExp(“(“+ k +”)”).test(fmt)){<br>       fmt &#x3D; fmt.replace(RegExp.$1, (RegExp.$1.length&#x3D;&#x3D;1) ? (o[k]) : ((“00”+ o[k]).substr((“”+ o[k]).length)));<br>   }<br>   }<br>   return fmt;<br> }</li></ul><p> &#x2F;&#x2F;var date &#x3D; new Date();<br> &#x2F;&#x2F;console.log(date.pattern(“yyyy-MM-dd hh:mm:ss”))<br> &#x2F;&#x2F;console.log(date.pattern(“yyyy-MM-dd E HH:mm:ss”))<br> &#x2F;&#x2F;console.log(date.pattern(“yyyy-MM-dd EE hh:mm:ss”))<br> &#x2F;&#x2F;console.log(date.pattern(“yyyy-MM-dd EEE hh:mm:ss”))<br> &#x2F;&#x2F;console.log(date.pattern(“yyyy-MM-dd hh:mm:ss”))<br> &#x2F;&#x2F;console.log(date.pattern(“q”))</p><h2 id="URL操作"><a href="#URL操作" class="headerlink" title="URL操作"></a>URL操作</h2><h3 id="parseQueryString参数转对象"><a href="#parseQueryString参数转对象" class="headerlink" title="parseQueryString参数转对象"></a>parseQueryString参数转对象</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   url参数转对象</li><li>@param  {String} url  default: window.location.href</li><li>@return {Object}<br>*&#x2F;<br> function parseQueryString(url) {<br>   url &#x3D; url &#x3D;&#x3D; null ? window.location.href : url<br>   var search &#x3D; url.substring(url.lastIndexOf(‘?’) + 1)<br>   if (!search) {<br>   return {}<br>   }<br>   return JSON.parse(‘{“‘ + decodeURIComponent(search).replace(&#x2F;“&#x2F;g, ‘\“‘).replace(&#x2F;&amp;&#x2F;g, ‘“,”‘).replace(&#x2F;&#x3D;&#x2F;g, ‘“:”‘) + ‘“}’)<br> }</li></ul><h3 id="stringfyQueryString对象序列化"><a href="#stringfyQueryString对象序列化" class="headerlink" title="stringfyQueryString对象序列化"></a>stringfyQueryString对象序列化</h3><p> &#x2F;**<br>  *</p><ul><li>@desc   对象序列化</li><li>@param  {Object} obj</li><li>@return {String}<br>*&#x2F;<br> function stringfyQueryString(obj) {<br>   if (!obj) return ‘’;<br>   var pairs &#x3D; [];<br>   for (var key in obj) {<br>   var value &#x3D; obj[key];<br>   if (value instanceof Array) {<br>       for (var i &#x3D; 0; i &lt; value.length; ++i) {<br>           pairs.push(encodeURIComponent(key + ‘[‘ + i + ‘]’) + ‘&#x3D;’ + encodeURIComponent(value[i]));<br>       }<br>       continue;<br>   }<br>   pairs.push(encodeURIComponent(key) + ‘&#x3D;’ + encodeURIComponent(obj[key]));<br>   }<br>   return pairs.join(‘&amp;’);<br> }</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的浏览器兼容性问题及解决办法二</title>
    <link href="/2021/01/05/browser-bug-and-solution-two/"/>
    <url>/2021/01/05/browser-bug-and-solution-two/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器的兼容性"><a href="#浏览器的兼容性" class="headerlink" title="浏览器的兼容性"></a>浏览器的兼容性</h2><p>浏览器的五大厂商：IE 火狐 谷歌 苹果 欧朋</p><p>不同的浏览器有不同的版本；不同的版本有不同的兼容性</p><p>IE的兼容性要求：实际工作一般要求兼容到IE8，IE6的兼容性问题特别喜欢问。</p><p>IE6的兼容性处理好，面试官会认为你的工作经验丰富。</p><h2 id="hack"><a href="#hack" class="headerlink" title="hack"></a>hack</h2><p>hacker：黑客的意思<br>hack的分两类</p><h3 id="1-HTML-hack"><a href="#1-HTML-hack" class="headerlink" title="1. HTML hack"></a>1. HTML hack</h3><p>同一套代码为了让不同的浏览器显示相同的效果，需要加hack来处理浏览器的兼容性问题。</p><p>针对不同的浏览器在同一个html文件里，去写不同的html结构。</p><p>IE浏览器有很多兼容性问题，给我们提供了一些接口</p>  <!--[if lte IE 9]>            <h3>您的浏览器版本太低，请升级高版本</h3>        <![endif]--><p>高级浏览器显示没有效果</p><p>lte:小于或等于该版本</p><p>lt:小于该版本</p><p>gt：大于该版本的显示</p><p>gte:大于或等于该版本</p><p>html hack表示低版本浏览器会认识这个hack，会正常渲染，高版本会认为这个hack是注释</p><p>针对IE6有固定的一个hack</p>  <!--[if IE 6]>            <script type="text/javascript" src="js/png.js"></script>        <![endif]--><p>表示，只有IE6浏览器可以看到里面的内容，其他浏览器会认为是注释</p><h3 id="2-CSS-hack"><a href="#2-CSS-hack" class="headerlink" title="2. CSS hack"></a>2. CSS hack</h3><p>css hack包括值的hack和选择器的hack</p><h3 id="CSS值的hack"><a href="#CSS值的hack" class="headerlink" title="CSS值的hack"></a>CSS值的hack</h3><p> &#x2F;<em>IE 6</em>&#x2F;<br> .selector { _color: blue; }<br> .selector { -color: blue; }</p><p> .box{<br>  width: 300px;<br>  height: 300px;<br>  background: pink;<br>  color:#000;<br>  -color:#fff;&#x2F;<em>这个属性只有IE6能认识</em>&#x2F;<br>  font-size: 30px;8<br> }</p><p>Hack符：-、_</p><p>在属性名的前面加下划线或横线。</p><p>表示这个属性只有IE6认识，其他的都不认识这个属性。</p><p> &#x2F;<em>IE 6&#x2F;7</em>&#x2F;<br>  Hack符：! $ &amp; * ( ) &#x3D; % + @ , . &#x2F; &#96; [ ] # ~ ? : &lt;&gt; |</p><p>  .box{<br>   width: 300px;<br>   height: 300px;<br>   background: pink;<br>   color:#000;<br>   &#x2F;<em>这个属性只能IE6&#x2F;7可以正常加载</em>&#x2F;<br>   !color:#fff;<br>   font-size: 30px;9<br>  }</p><p>表示这个属性只有IE6&#x2F;7认识，其他的都不认识这个属性。</p><p> &#x2F;<em>IE 8&#x2F;9</em>&#x2F;<br>  .selector { color: blue\0&#x2F;; }<br>Hack符：\0&#x2F;。</p><p>需要写在属性值的后面。</p><p>只在IE8、9里认识。</p><p> &#x2F;<em>IE 6&#x2F;7&#x2F;8&#x2F;9&#x2F;10</em>&#x2F;<br>  .selector { color: blue\9; }</p><p> .box{<br>  width: 300px;<br>  height: 300px;<br>  background: pink;<br>  color:#000;<br>  font-size: 20px;<br>  &#x2F;<em>这个属性只能IE6&#x2F;7&#x2F;8&#x2F;9&#x2F;10可以正常加载</em>&#x2F;<br>  background-color:lightblue\9;9<br> }</p><p>Hack符：\9.</p><p>需要写在属性值的后面，分号前。</p><h3 id="选择器的hack"><a href="#选择器的hack" class="headerlink" title="选择器的hack"></a>选择器的hack</h3><h4 id="低于IE-6"><a href="#低于IE-6" class="headerlink" title="低于IE 6"></a>低于IE 6</h4><p> &#x2F;* IE 6 and below *&#x2F; </p><ul><li>html .selector  {}</li></ul><p>这种选择器只在IE6里加载，其他的浏览器认为你的选择器是错的。</p><p>高级浏览器认为html已经是根标签，*不是他的祖先元素。</p><ul><li>html .box{<br>width: 300px;<br>height: 300px;<br>background: lightblue;<br>color:#000;<br>font-size: 20px;7<br> }<br>等价写法：</li></ul><p> .box{<br>  -width: 300px;<br>  -height: 300px;<br>  _color:#000;<br>  _font-size: 20px;<br>  -background-color:lightblue;7<br> }</p><h4 id="低于IE-7"><a href="#低于IE-7" class="headerlink" title="低于IE 7"></a>低于IE 7</h4><p> &#x2F;<em>IE 7 and below</em>&#x2F;<br>  .selector, {}</p><p>这种选择器只在IE7及以下版本里加载，其他的浏览器认为你的选择器是错的。</p><p> .box,{<br>  width: 300px;<br>  height: 300px;<br>  background: pink;<br>  color:#000;<br>  font-size: 20px;<br>  background-color:lightblue\9;8<br> }</p><p>等价写法：</p><p> .box{<br>  !width: 300px;<br>  !height: 300px;<br>  !color:#000;<br>  !font-size: 20px;<br>  !background-color:lightblue;7<br> }</p><h4 id="除了IE-6"><a href="#除了IE-6" class="headerlink" title="除了IE 6"></a>除了IE 6</h4><p> &#x2F;<em>除了IE 6</em>&#x2F;<br>  html &gt; body .selector {}</p><p>这个&gt;子级选择器：只选择儿子级，后代其他级别不选。</p><p>IE6不认识子级选择器。</p><p>除了IE6都能正常加载。</p><p> html&gt;body .box{<br>  width: 300px;<br>  height: 300px;<br>  background: pink;<br>  color:#000;<br>  font-size: 20px;<br> }</p><h2 id="IE6的兼容性"><a href="#IE6的兼容性" class="headerlink" title="IE6的兼容性"></a>IE6的兼容性</h2><h3 id="IE-6的选择器的兼容性"><a href="#IE-6的选择器的兼容性" class="headerlink" title="IE 6的选择器的兼容性"></a>IE 6的选择器的兼容性</h3><p>之前的7种选择器：</p><p>通配符，标签选择器，类选择器，id选择器，（基本选择器）</p><p>后代选择器，交集选择器（div.box），并集选择器。（高级选择器）</p><p>IE6支持以上7种选择器，但是不支持交集选择器中连续类名的书写。</p><p>这种写法IE6不认识；</p><p> div.box.cl{<br>  color:orange;<br>  font-size: 30px;<br> }</p><p>解决办法：不写连续类名的选择器</p><p> div.box{}</p><h3 id="盒模型的兼容问题"><a href="#盒模型的兼容问题" class="headerlink" title="盒模型的兼容问题"></a>盒模型的兼容问题</h3><ol><li>DTD问题</li></ol><p> 如果IE不写DTD他的盒模型是内减的。</p><p> 解决办法：必须DTD</p><ol start="2"><li>最小高度</li></ol><p> 如果盒子高度小于默认字号，不会正常显示。高度会是最小的字号。</p><p> 解决方法：</p><p> 单独给IE6浏览器，强制给个很小的字号。</p><p>  .box{<br>   width: 200px;<br>   height: 4px;<br>   background: pink;<br>   -font-size:0;<br>  }</p><ol start="3"><li>浮动的盒子不会钻到底下</li></ol><p> 情况：一个盒子浮动，一个盒子不浮动，在IE6里，不浮动的盒子不会钻到浮动盒子的下面占领它原来的标准流位置。</p><p>  .box1{<br>   width: 100px;<br>   height: 100px;<br>   background: lightblue;<br>   float: left;<br>   }<br>  .box2{<br>   width: 200px;<br>   height: 200px;<br>   background: pink;11<br>  }</p><p> 解决办法：同级的元素，要么都浮动要么都不浮动。</p><p> 制作压盖效果必须用定位来实现。</p><ol start="4"><li>像素的bug</li></ol><p> 情况：一个浮动，一个不浮动，IE6里两个盒子之间会出现3px的间距。</p><p> 解决办法：给左边的盒子加负数的margin-right</p><p>  .box1{<br>   width: 100px;<br>   height: 100px;<br>   background: lightblue;<br>   float: left;<br>   margin-right:-3px;<br>  }</p><ol start="5"><li>双倍margin问题</li></ol><p> 情况：一些元素浮动，有一个与浮动方向相同的方向的margin，第一个元素会出现双倍边距的问题。</p><p>  .box p{<br>   float: left;<br>   margin-left: 20px;<br>   width: 100px;<br>   height: 100px;<br>   background: pink;<br>  }</p><ol start="6"><li>overflow：hidden失效</li></ol><p> IE6不认识overflow：hidden；引申作用，没法帮我们清浮动，自动撑高盒子。</p><p> IE浏览器加载机制：</p><p> 布局：layout</p><p> 有布局：盒子本身加载的时候，根据自身内容来加载，会强制检测里面的元素，通过里面的元素性质进行自身布局。</p><p> 没有布局：盒子本身加载的时候，根据祖先元素来加载，不会去管内部的元素。</p><p> IE里有很多属性可以触发有布局的机制。触发hasLayout机制，就可以让overflowhidden生效。</p><p> 有一个属性永远触发hasLayout机制。</p><p>  _zoom: 1;</p>]]></content>
    
    
    <categories>
      
      <category>web浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见的浏览器兼容性问题及解决办法</title>
    <link href="/2021/01/04/browser-bug-and-solution/"/>
    <url>/2021/01/04/browser-bug-and-solution/</url>
    
    <content type="html"><![CDATA[<h2 id="WEB前端人员须知的常见浏览器不兼容问题及解决技巧"><a href="#WEB前端人员须知的常见浏览器不兼容问题及解决技巧" class="headerlink" title="WEB前端人员须知的常见浏览器不兼容问题及解决技巧"></a>WEB前端人员须知的常见浏览器不兼容问题及解决技巧</h2><p>所谓的浏览器兼容性问题，是指因为不同的浏览器对同一段代码有不同的解析，造成页面显示效果不统一的情况。在大多数情况下，我们的需求是，无论用户用什么浏览器来查看我们的网站或者登陆我们的系统，都应该是统一的显示效果。所以浏览器的兼容性问题是前端开发人员经常会碰到和必须要解决的问题。这里主要从浏览器解析差异的角度来分析兼容性问题</p><h3 id="兼容性问题一：-不同浏览器的标签默认的外补丁和内补丁不同"><a href="#兼容性问题一：-不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="兼容性问题一： 不同浏览器的标签默认的外补丁和内补丁不同"></a>兼容性问题一： 不同浏览器的标签默认的外补丁和内补丁不同</h3><p>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大</p><p>碰到频率:100%</p><p>解决方案：css里    *{margin:0;padding:0;}</p><p>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的css文件开头都会用通配符*来设置各个标签的内外补丁是0。</p><h3 id="兼容问题二：float布局最常见的浏览器兼容问题"><a href="#兼容问题二：float布局最常见的浏览器兼容问题" class="headerlink" title="兼容问题二：float布局最常见的浏览器兼容问题"></a>兼容问题二：float布局最常见的浏览器兼容问题</h3><p>问题症状:常见症状是ie6中后面的一块被顶到下一行</p><p>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）</p><p>问题原因: 块属性标签float后，又有横行的margin的情况下，在ie6显示margin比设置的大</p><p>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性</p><p>备注：我们最常用的就是div+css布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。</p><h3 id="兼容问题三：设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度"><a href="#兼容问题三：设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度" class="headerlink" title="兼容问题三：设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度"></a>兼容问题三：设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度</h3><p>问题症状：ie6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p><p>碰到频率：60%</p><p>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p><p>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是ie8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p><h3 id="浏览器兼容问题四：行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，ie6间距bug（类似第二种）"><a href="#浏览器兼容问题四：行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，ie6间距bug（类似第二种）" class="headerlink" title="浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，ie6间距bug（类似第二种）"></a>浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，ie6间距bug（类似第二种）</h3><p>问题症状：ie6里的间距比超过设置的间距</p><p>碰到几率：20%</p><p>解决方案：在display:block;后面加入display:inline;display:table;</p><p>备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在ie6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</p><h3 id="浏览器兼容问题五：图片默认有间距"><a href="#浏览器兼容问题五：图片默认有间距" class="headerlink" title="浏览器兼容问题五：图片默认有间距"></a>浏览器兼容问题五：图片默认有间距</h3><p>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p><p>碰到几率：20%</p><p>解决方案：使用float属性为img布局</p><p>备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。</p><p>浏览器兼容问题六：标签最低高度设置min-height不兼容</p><p>问题症状：因为min-height本身就是一个不兼容的css属性，所以设置min-height时不能很好的被各个浏览器兼容</p><p>碰到几率：5%</p><p>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</p><p>备注：在B&#x2F;S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</p><h3 id="CSS-hack"><a href="#CSS-hack" class="headerlink" title="CSS hack"></a>CSS hack</h3><p>使用hacker 我可以吧浏览器分为3类：ie6 ；ie7和遨游；其他（ie8 chrome ff safari opera等）</p><p>ie6认识的hacker 是下划线_ 和星号 *</p><p>ie7 遨游认识的hacker是星号 * （包括上面问题6中的 !important也算是hack的一种。不过实用性较小。）</p><p>比如这样一个css设置</p><p> height:300px;*height:200px;_height:100px;</p><p>ie6浏览器在读到 height:300px的时候会认为高时300px；</p><p>继续往下读，他也认识<em>heihgt， 所以当ie6读到</em>height:200px的时候会覆盖掉前一条的相冲突设置，认为高度是200px。</p><p>继续往下读，ie6还认识_height,所以他又会覆盖掉200px高的设置，把高度设置为100px；<br>ie7和遨游也是一样的从高度300px的设置往下读。</p><p>当它们读到*height200px的时候就停下了，因为它们不认识_height。所以它们会把高度解析为200px；</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的人使用。</p><p>很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。<br>如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。</p><p>因为优先级相同且相冲突的属性设置后一个会覆盖掉前一个，所以书写的次序是很重要的。</p><p>最后说一下，严谨型的开发人员会有一套合适自己的RESET.CSS。结合自己的经验尽量规避容易出现不兼容的问题。以减少hack的使用，尽量符合W3C的标准。</p>]]></content>
    
    
    <categories>
      
      <category>web浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多列和瀑布流总结</title>
    <link href="/2021/01/03/Column-and-Waterfalls/"/>
    <url>/2021/01/03/Column-and-Waterfalls/</url>
    
    <content type="html"><![CDATA[<h2 id="多列与瀑布流"><a href="#多列与瀑布流" class="headerlink" title="多列与瀑布流"></a>多列与瀑布流</h2><h3 id="什么叫多列"><a href="#什么叫多列" class="headerlink" title="什么叫多列"></a>什么叫多列</h3><p>CSS3中出现了新的多列布局(multi-column)是传统HTML网页中块状布局模式的有力扩充。这种语法能够让WEB开发人员轻松的让文本呈现多列显示。我们知道，当一行文字太长时，读者读起来比较费劲。视点从文本的一端移到另一端、然后换到下一行的行首，如果眼球移动浮动过大，他们的注意力就会减退，容易读不下去。所以，为了最大效率的使用大屏幕显示器，页面设计中需要限制文本的宽度，让文本按多列呈现，就像报纸上的新闻排版一样。</p><h3 id="多列-columns-的用法"><a href="#多列-columns-的用法" class="headerlink" title="多列(columns)的用法"></a>多列(columns)的用法</h3><p>多列的属性有下面几种:</p><ol><li>指定多少列</li></ol><p>  column-count:3;<br>  -moz-column-count:3; &#x2F;* Firefox <em>&#x2F;<br>  -webkit-column-count:3; &#x2F;</em> Safari and Chrome *&#x2F;</p><ol start="2"><li>指定列与列之间的间隔</li></ol><p>  column-gap: 100px;<br>  -moz-column-gap: 100px; &#x2F;* Firefox <em>&#x2F;<br>  -webkit-column-gap: 100px; &#x2F;</em> Chrome, Safari, Opera *&#x2F;</p><ol start="3"><li><p>列边框操作</p><p>  -webkit-column-rule-style: solid; &#x2F;* Chrome, Safari, Opera <em>&#x2F;<br>  -moz-column-rule-style: solid; &#x2F;</em> Firefox *&#x2F;<br>  column-rule-style: solid;</p><p>  -webkit-column-rule-width: 1px; &#x2F;* Chrome, Safari, Opera <em>&#x2F;<br>  -moz-column-rule-width: 1px; &#x2F;</em> Firefox *&#x2F;<br>  column-rule-width: 1px;</p></li></ol><p>  -webkit-column-rule-color: lightblue; &#x2F;* Chrome, Safari, Opera <em>&#x2F;<br>     -moz-column-rule-color: lightblue; &#x2F;</em> Firefox *&#x2F;<br>     column-rule-color: lightblue;</p><p>   &#x2F;<em>合在一起写法</em>&#x2F;<br>   -webkit-column-rule: 1px solid lightblue;<br>   -moz-column-rule: 1px solid lightblue;<br>   column-rule: 1px solid lightblue;</p><ol start="4"><li>指定列的宽度</li></ol><p>  -webkit-column-width: 100px; &#x2F;* Chrome, Safari, Opera *&#x2F;<br>      column-width: 100px;</p><ol start="5"><li>指定元素横跨多少列</li></ol><p>  column-span:all;<br>  -webkit-column-span:all; &#x2F;* Safari and Chrome *&#x2F;</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CSS3的多列布局(columns)是一种方便WEB开发者高效利用宽屏显示器的非常有用的功能特征。你会发现在很多地方都需要用到它们，特别是需要自动平衡列高度的地方(如报纸，杂志排版时)。</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="hljs">&lt;style&gt; </code></pre><p> .newspaper<br> {<br>  &#x2F;<em>&#x2F;指定多少列</em>&#x2F;<br>  column-count:3;<br>  -moz-column-count:3; &#x2F;* Firefox <em>&#x2F;<br>  -webkit-column-count:3; &#x2F;</em> Safari and Chrome <em>&#x2F;<br>  &#x2F;<em>指定列与列之间的间隔</em>&#x2F;<br>  -webkit-column-gap: 100px; &#x2F;</em> Chrome, Safari, Opera <em>&#x2F;<br>     -moz-column-gap: 100px; &#x2F;</em> Firefox *&#x2F;<br>     column-gap: 100px;</p><p>   -webkit-column-rule: 1px solid lightblue;<br>     -moz-column-rule: 1px solid lightblue;<br>     column-rule: 1px solid lightblue;</p><pre><code class="hljs"> /*指定列的宽度*/  -webkit-column-width: 100px; /* Chrome, Safari, Opera */  column-width: 100px;</code></pre><p> }<br> h2<br> {<br>  &#x2F;<em>指定元素横跨多少列</em>&#x2F;<br>  column-span:all;<br>  -webkit-column-span:all; &#x2F;* Safari and Chrome *&#x2F;<br> }<br> </style></p> <div class="newspaper"> <h2>报纸的多列布局11111111111111111111111111111111111111111111111</h2> 当我年轻的时候，我梦想改变这个世界；当我成熟以后，我发现我不能够改变这个世界，我将目光缩短了些，决定只改变我的国家；当我进入暮年以后，我发现我不能够改变我们的国家，我的最后愿望仅仅是改变一下我的家庭，但是，这也不可能。当我现在躺在床上，行将就木时，我突然意识到：如果一开始我仅仅去改变我自己，然后，我可能改变我的家庭；在家人的帮助和鼓励下，我可能为国家做一些事情；然后，谁知道呢?我甚至可能改变这个世界。 </div><h2 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h2><h3 id="什么是瀑布流"><a href="#什么是瀑布流" class="headerlink" title="什么是瀑布流"></a>什么是瀑布流</h3><p>参差不齐的多列布局就是瀑布流。像淘宝商品的展示，似乎一夜之间出现在国内外大大小小的网站上，这种布局适合小数据块，每个数据块的内容相近且没有侧重。通常，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部，就像瀑布一样不会断开。所以，我们给这样的布局起了这个形象的名字，——瀑布流布局 </p><h3 id="如何实现瀑布流"><a href="#如何实现瀑布流" class="headerlink" title="如何实现瀑布流"></a>如何实现瀑布流</h3><h4 id="1-传统浮动，各列固定宽度，并且左浮动"><a href="#1-传统浮动，各列固定宽度，并且左浮动" class="headerlink" title="1. 传统浮动，各列固定宽度，并且左浮动"></a>1. 传统浮动，各列固定宽度，并且左浮动</h4>  <style>  .wrap{   width:100%;  }  .box{   width:30%;   float: left;   padding: 10px;  }  </style>  <div class="wrap">   <div class="box">...</div>    <div class="box">...</div>    <div class="box">...</div>  </div><p>特点：布局简单，不用明确数据块的高度，当数据块中有图片时，也不需要指定图片的高度</p><p>缺点:<br>列数固定，扩展不易，当浏览器窗口大小变化时，只能固定列数。</p><p>如果要添加一列很难调整数据块的排列</p><p>当滚动加载数据时，还要指定插入第几列中，不是很方便。</p><h4 id="2-CSS3定义多列实现方式"><a href="#2-CSS3定义多列实现方式" class="headerlink" title="2. CSS3定义多列实现方式"></a>2. CSS3定义多列实现方式</h4><p> 指定容器的列数</p><p>  .container {<br>   -webkit-column-count: 5；<br>   &#x2F;<em>-webkit-column-gap: 20px；</em>&#x2F;<br>   -webkit-column-rule: 5px solid #333；<br>   -webkit-column-width: 20%；</p><p>   -moz-column-count: 5；<br>   &#x2F;<em>-moz-column-gap: 20px；</em>&#x2F;<br>   -moz-column-rule: 5px solid #333；<br>   -moz-column-width: 20%；</p><p>   column-count: 5；<br>   &#x2F;<em>column-gap: 20px；</em>&#x2F;<br>   column-rule: 5px solid #333；<br>   column-width: 20%；<br>  }</p><p>优点：方便，直接定义css样式，扩展方便，直接往容器里面添加内容即可</p><p>缺点：</p><ul><li><p>当他的数据块排列是从上到下排列到一定高度后，会把剩余元素一次排列到下一列。</p></li><li><p>只有高级浏览器能用,更适合文字的多栏排列</p></li></ul><h4 id="3-绝对定位，通过js排版"><a href="#3-绝对定位，通过js排版" class="headerlink" title="3. 绝对定位，通过js排版"></a>3. 绝对定位，通过js排版</h4><ul><li><p>设置父级container样式：水平居中</p></li><li><p>设置每个块框box的样式：绝对定位</p></li><li><p>设置窗口滚动事件的监听函数：读取数据添加块框</p> <style>  #container {   margin:100px auto;/* 居中 */     position:relative;  }  #container .box{   position:absolute;  } </style> <div id="container">  <div class="box">   <div class="info">    <div class="pic"><img src="images/1.jpg"></div>    <div class="title"><a href=""></a></div>   </div>  </div> </div> <script>   ... </script></li></ul><p>另外：还有封装好的js插件可供选择</p><ol><li>masonry.pkgd.min.js</li></ol><p> 引入js后，js调用</p><p>  $(‘#container’).masonry({<br>      itemSelector: ‘.item’,<br>      isAnimated: true,<br>      &#x2F;&#x2F; columnWidth: 450,<br>      isFitWidth: true     &#x2F;&#x2F; 自适应宽度<br>    });  </p><ol start="2"><li>jaliswall.js</li></ol><p> 引入js后，调用</p><p>   $(‘.Pbl-wrap’).jaliswall({ item: ‘.Pbl-item’ });</p><p>本文中详细demo请见demo部分的瀑布流部分</p>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字体和文本效果</title>
    <link href="/2020/12/15/font-and-text/"/>
    <url>/2020/12/15/font-and-text/</url>
    
    <content type="html"><![CDATA[<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>css3之前的版本，网页设计师不得不使用用户计算机已经安装的字体。  </p><p>使用css3，网页设计师可以使用他&#x2F;她喜欢的任何字体<br>当你发现您要使用的字体文件时，只需要简单的将字体文件包含在网站中，它会自动下载给需要的用户。您所选择的新的css3版本有关于@font-face规则描述。  </p><p>您自己的字体是在css3@font-face规则中定义的。  </p> <style> @font-face { font-family: myFirstFont; src: url('myfont/fontawesome-webfont.ttf')  ,url('myfont/fontawesome-webfont.woff'); /*IE9*/ } div { font-family:myFirstFont; } </style><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3> <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>字体</title> <style> @font-face {<p> font-family: myFirstFont;<br> src: url(‘myfont&#x2F;fontawesome-webfont.ttf’)<br>  ,url(‘myfont&#x2F;fontawesome-webfont.woff’); &#x2F;<em>IE9</em>&#x2F;</p><p> }</p><p> div<br> {</p><p> font-family:myFirstFont;</p><p> }<br> </style><br> </head><br> <body></p> <p style="font-family:'Microsoft YaHei'"> 微软雅黑 Microsoft YaHei  Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'Times New Roman'"> Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'SimSun'"> 宋体  Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'SimHei'"> 黑体   Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:' Microsoft JhengHei'"> 微软正黑体 Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:' NSimSun'"> 新宋体 Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'PMingLiU'"> 新细明体 Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'DFKai-SB'"> 标楷体 Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'FangSong'"> 仿宋 Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'KaiTi'"> 楷体 Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'_GB2312 FangSong_GB2312'">  仿宋_ Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:'_GB2312 KaiTi_GB2312'"> 楷体_ Internet Explorer 9 只支持 .eot 格式的字体.</p> <p style="font-family:myFirstFont;">自定义字体</p> <div> Internet Explorer 9 只支持 .eot 格式的字体. </div> </body> </html><h2 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果"></a>文本效果</h2><h3 id="text-shadow-字体阴影"><a href="#text-shadow-字体阴影" class="headerlink" title="text-shadow:字体阴影"></a>text-shadow:字体阴影</h3><p> .text{</p><p> text-shadow:5 px 5px 5px #FF0000;</p><p> }</p><h5 id="指定-水平阴影、垂直阴影、模糊的距离，以及阴影的颜色"><a href="#指定-水平阴影、垂直阴影、模糊的距离，以及阴影的颜色" class="headerlink" title="指定:水平阴影、垂直阴影、模糊的距离，以及阴影的颜色"></a>指定:水平阴影、垂直阴影、模糊的距离，以及阴影的颜色</h5><h3 id="box-shadow-背景阴影"><a href="#box-shadow-背景阴影" class="headerlink" title="box-shadow:背景阴影"></a>box-shadow:背景阴影</h3><p>text-overflow:<br>文字溢出</p><p> .text{</p><p> text-overflow:clip|ellipsis;</p><p> }</p><p>word-wrap:<br>剪切|…替代</p><p>如果某个单词太长，不适合在一个区域内，它扩展到外面：css3中，自动切换属性允许强制文本换行-即使这意味着分裂它中间的一个字。</p><p> .text{</p><p> word-wrap:break-word;</p><p> }</p><p>word-break:规定非中日韩文本的换行规则</p><p>css3单词拆分换行属性指定换行规则：</p><p> .text{<br>  word-break:keep-all|break-all;<br> }</p><h2 id="新文本属性"><a href="#新文本属性" class="headerlink" title="新文本属性"></a>新文本属性</h2><p>hanqing-punctuation:规定标点字符是否位于线框之外</p><p>punctuation-trim:规定是否对标点字符进行修剪</p><p>text-align-last：设置如何对齐最后一行或紧挨着强制换行符之前的行</p><p>Text-emphasis:向元素的文本应用重点标记以及重点标记的前背景色</p><p>Text-justify:规定当text-align设置为“justify”时所使用的对齐方法</p><p>Text-outline:规定文本的轮廓</p><h2 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h2> <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>文本效果</title> <style> h1 {<p> text-shadow: 10px 10px 5px #888;</p><p> }<br> div.test<br> {</p><p> white-space:nowrap;<br> width:12em;<br> overflow:hidden;<br> border:1px solid #000000;</p><p> }</p><p> </style><br> </head><br> <body></p> <h1>文字阴影效果</h1> <p>以下 div 容器内的文本无法完全显示，可以看到它被裁剪了。</p> <p>div 使用 &quot;text-overflow:ellipsis&quot;:</p> <div class="test" style="text-overflow:ellipsis;">This is some long text that will not fit in the box</div> <p>div 使用 &quot;text-overflow:clip&quot;:</p> <div class="test" style="text-overflow:clip;">This is some long text that will not fit in the box</div> <p>div 使用自定义字符串 &quot;text-overflow: &gt;&gt;&quot;(只在 Firefox 浏览器下有效):</p> <div class="test" style="text-overflow:'>>';">This is some long text that will not fit in the box</div> <p><b>注意:</b> Internet Explorer 9 以及更早版本的浏览器不支持 text-shadow属性.</p> </body> </html>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渐变</title>
    <link href="/2020/12/13/gradual-change/"/>
    <url>/2020/12/13/gradual-change/</url>
    
    <content type="html"><![CDATA[<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><p>语法：background: linear-gradient(direction, color-stop1, color-stop2, …);</p><h3 id="从上到下"><a href="#从上到下" class="headerlink" title="从上到下"></a>从上到下</h3><p> #grad1 {<br>     height: 200px;<br>     background: -webkit-linear-gradient(#000, #888); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-linear-gradient(#000, #888); &#x2F;<em>Opera 11.1 - 12.0</em>&#x2F;<br>     background: -moz-linear-gradient(#000, #888); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: linear-gradient(#000, #888); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</p><h3 id="从左到右"><a href="#从左到右" class="headerlink" title="从左到右"></a>从左到右</h3><p> #grad2 {<br>     height: 200px;<br>     background: -webkit-linear-gradient(left, red , blue); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-linear-gradient(right, red, blue); &#x2F;<em>Opera 11.1 - 12.0</em>&#x2F;<br>     background: -moz-linear-gradient(right, red, blue); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: linear-gradient(to right, red , blue); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</p><h3 id="从左上到右下"><a href="#从左上到右下" class="headerlink" title="从左上到右下"></a>从左上到右下</h3><h2 id="grad3-height-200px-background-webkit-linear-gradient-left-top-000-888-x2F-Safari-5-1-6-0-x2F-background-o-linear-gradient-bottom-right-000-888-x2F-Opera-11-1-12-0-x2F-background-moz-linear-gradient-bottom-right-000-888-x2F-Firefox-3-6-15-x2F-background-linear-gradient-to-bottom-right-000-888-x2F-标准的语法（必须放在最后）-x2F"><a href="#grad3-height-200px-background-webkit-linear-gradient-left-top-000-888-x2F-Safari-5-1-6-0-x2F-background-o-linear-gradient-bottom-right-000-888-x2F-Opera-11-1-12-0-x2F-background-moz-linear-gradient-bottom-right-000-888-x2F-Firefox-3-6-15-x2F-background-linear-gradient-to-bottom-right-000-888-x2F-标准的语法（必须放在最后）-x2F" class="headerlink" title="#grad3 {     height: 200px;     background: -webkit-linear-gradient(left top, #000 , #888); &#x2F;Safari 5.1 - 6.0&#x2F;     background: -o-linear-gradient(bottom right, #000, #888); &#x2F;Opera 11.1 - 12.0&#x2F;     background: -moz-linear-gradient(bottom right, #000, #888); &#x2F;Firefox 3.6 - 15&#x2F;     background: linear-gradient(to bottom right, #000 , #888); &#x2F;标准的语法（必须放在最后）&#x2F; }"></a>#grad3 {<br>     height: 200px;<br>     background: -webkit-linear-gradient(left top, #000 , #888); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-linear-gradient(bottom right, #000, #888); &#x2F;<em>Opera 11.1 - 12.0</em>&#x2F;<br>     background: -moz-linear-gradient(bottom right, #000, #888); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: linear-gradient(to bottom right, #000 , #888); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</h2><h2 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h2><p>语法: background: radial-gradient(center, shape size, start-color, …, last-color);</p><p> #grad6 {<br>     height: 150px;<br>     width: 200px;<br>     background: -webkit-radial-gradient(red, green, blue); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-radial-gradient(red, green, blue); &#x2F;<em>Opera 11.6 - 12.0</em>&#x2F;<br>     background: -moz-radial-gradient(red, green, blue); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: radial-gradient(red, green, blue); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</p><h3 id="不均匀分布"><a href="#不均匀分布" class="headerlink" title="不均匀分布"></a>不均匀分布</h3><p> #grad7 {<br>     height: 150px;<br>     width: 200px;<br>     background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-radial-gradient(red 5%, green 15%, blue 60%); &#x2F;<em>Opera 11.6 - 12.0</em>&#x2F;<br>     background: -moz-radial-gradient(red 5%, green 15%, blue 60%); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: radial-gradient(red 5%, green 15%, blue 60%); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</p><h3 id="椭圆形-默认"><a href="#椭圆形-默认" class="headerlink" title="椭圆形  默认"></a>椭圆形  默认</h3><p> #grad8 {<br>     height: 150px;<br>     width: 200px;<br>     background: -webkit-radial-gradient(red, yellow, green); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-radial-gradient(red, yellow, green); &#x2F;<em>Opera 11.6 - 12.0</em>&#x2F;<br>     background: -moz-radial-gradient(red, yellow, green); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: radial-gradient(red, yellow, green); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</p><h3 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h3><p> #grad9 {<br>     height: 150px;<br>     width: 200px;<br>     background: -webkit-radial-gradient(circle, red, yellow, green); &#x2F;<em>Safari 5.1 - 6.0</em>&#x2F;<br>     background: -o-radial-gradient(circle, red, yellow, green); &#x2F;<em>Opera 11.6 - 12.0</em>&#x2F;<br>     background: -moz-radial-gradient(circle, red, yellow, green); &#x2F;<em>Firefox 3.6 - 15</em>&#x2F;<br>     background: radial-gradient(circle, red, yellow, green); &#x2F;<em>标准的语法（必须放在最后）</em>&#x2F;<br> }</p><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p> #grad10 {</p><pre><code class="hljs"> height: 150px; width: 200px;</code></pre><p>  background: -moz-repeating-radial-gradient(#ace, #ace 5px, #f96 5px, #f96 10px);<br>  background: -webkit-repeating-radial-gradient(#ace, #ace 5px, #f96 5px, #f96 10px);<br>  background: -moz-repeating-linear-gradient(top left -45deg, #ace, #ace 5px, #f96 5px, #f96 10px);<br>  background: -webkit-repeating-linear-gradient(top left -45deg, #ace, #ace 5px, #f96 5px, #f96 10px);</p><p> }</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2> <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>渐变</title> <style> /*从上到下*/ #grad1 {<pre><code class="hljs">height: 200px;background: -webkit-linear-gradient(#000, #888); /* Safari 5.1 - 6.0 */background: -o-linear-gradient(#000, #888); /* Opera 11.1 - 12.0 */background: -moz-linear-gradient(#000, #888); /* Firefox 3.6 - 15 */background: linear-gradient(#000, #888); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>从左到右</em>&#x2F;<br> #grad2 {</p><pre><code class="hljs">height: 200px;background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */background: linear-gradient(to right, red , blue); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>从左上到右下</em>&#x2F;<br> #grad3 {</p><pre><code class="hljs">height: 200px;background: -webkit-linear-gradient(left top, #000 , #888); /* Safari 5.1 - 6.0 */background: -o-linear-gradient(bottom right, #000, #888); /* Opera 11.1 - 12.0 */background: -moz-linear-gradient(bottom right, #000, #888); /* Firefox 3.6 - 15 */background: linear-gradient(to bottom right, #000 , #888); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>彩虹渐变</em>&#x2F;<br> #grad4 {</p><pre><code class="hljs">height: 55px;background: -webkit-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Safari 5.1 - 6.0 */background: -o-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Opera 11.1 - 12.0 */background: -moz-linear-gradient(left, red, orange, yellow, green, blue, indigo, violet); /* Firefox 3.6 - 15 */background: linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> #grad5 {</p><pre><code class="hljs">height: 200px;background: -webkit-linear-gradient(left, rgba(255,0,0,0), rgba(255,0,0,1)); /* Safari 5.1 - 6.0 */background: -o-linear-gradient(right, rgba(255,0,0,0), rgba(255,0,0,1)); /* Opera 11.1 - 12.0 */background: -moz-linear-gradient(right, rgba(255,0,0,0), rgba(255,0,0,1)); /* Firefox 3.6 - 15 */background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>径向渐变</em>&#x2F;<br> &#x2F;<em>均匀分布</em>&#x2F;<br> #grad6 {</p><pre><code class="hljs">height: 150px;width: 200px;background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */background: radial-gradient(red, green, blue); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>不均匀分布</em>&#x2F;<br> #grad7 {</p><pre><code class="hljs">height: 150px;width: 200px;background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>椭圆形  默认</em>&#x2F;<br> #grad8 {</p><pre><code class="hljs">height: 150px;width: 200px;background: -webkit-radial-gradient(red, yellow, green); /* Safari 5.1 - 6.0 */background: -o-radial-gradient(red, yellow, green); /* Opera 11.6 - 12.0 */background: -moz-radial-gradient(red, yellow, green); /* Firefox 3.6 - 15 */background: radial-gradient(red, yellow, green); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>圆形</em>&#x2F;<br> #grad9 {</p><pre><code class="hljs">height: 150px;width: 200px;background: -webkit-radial-gradient(circle, red, yellow, green); /* Safari 5.1 - 6.0 */background: -o-radial-gradient(circle, red, yellow, green); /* Opera 11.6 - 12.0 */background: -moz-radial-gradient(circle, red, yellow, green); /* Firefox 3.6 - 15 */background: radial-gradient(circle, red, yellow, green); /* 标准的语法（必须放在最后） */</code></pre><p> }<br> &#x2F;<em>重复</em>&#x2F;<br> #grad10 {</p><pre><code class="hljs">height: 150px;width: 200px;</code></pre><p> background: -moz-repeating-radial-gradient(#ace, #ace 5px, #f96 5px, #f96 10px);<br> background: -webkit-repeating-radial-gradient(#ace, #ace 5px, #f96 5px, #f96 10px);<br> background: -moz-repeating-linear-gradient(top left -45deg, #ace, #ace 5px, #f96 5px, #f96 10px);<br> background: -webkit-repeating-linear-gradient(top left -45deg, #ace, #ace 5px, #f96 5px, #f96 10px);</p><p> }</p><p> .flex-box{<br>  display: flex;<br> }<br> .flex-item{<br>  margin-left: 30px;<br> }<br> </style><br> </head><br> <body></p> <h3>线性渐变 - 从上到右</h3> <div id="grad1"></div> <h3>线性渐变 - 从左到右</h3> <div id="grad2"></div> <h3>线性渐变 - 从左上到右下</h3> <div id="grad3"></div> <h3>彩虹渐变</h3> <div id="grad4" style="text-align:center;margin:auto;color:#999;font-size:40px;font-weight:bold">渐变背景</div> <h3>线性渐变 - 透明度</h3> <p>为了添加透明度，我们使用 rgba() 函数来定义颜色结点。rgba() 函数中的最后一个参数可以是从 0 到 1 的值，它定义了颜色的透明度：0 表示完全透明，1 表示完全不透明。</p> <div id="grad5"></div> <h1 style="text-align:center;margin:auto;color:#333;font-weight:bold">径向渐变</h1> <div class="flex-box">  <div class="flex-item">  <h3>径向渐变 - 颜色结点均匀分布</h3>  <div id="grad6"></div>  </div>  <div class="flex-item">  <h3>径向渐变 - 颜色结点不均匀分布</h3>  <div id="grad7"></div>  </div>  <div class="flex-item">  <p><strong>椭圆形 Ellipse（默认）：</strong></p>  <div id="grad8"></div>  </div>  <div class="flex-item">  <p><strong>圆形 Circle：</strong></p>  <div id="grad9"></div>  </div>  <div class="flex-item">  <p><strong>重复：</strong></p>  <div id="grad10"></div>  </div> </div> <p><strong>注意：</strong> Internet Explorer 9 及之前的版本不支持渐变。</p> </body> </html>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局的用法</title>
    <link href="/2020/12/11/flex-layout/"/>
    <url>/2020/12/11/flex-layout/</url>
    
    <content type="html"><![CDATA[<h2 id="Css3的flex布局用法"><a href="#Css3的flex布局用法" class="headerlink" title="Css3的flex布局用法"></a>Css3的flex布局用法</h2><p>Flex意为“弹性布局”，英文flexible box的缩写，flex布局使css盒模型变得更加强大和灵活，flex布局主要用在webapp和移动端中使用，移动端flex布局，将使的布局变得异常简单。<br> 任何一个容器都可以指定为flex布局；<br>行内元素也可以使用flex布局。</p><p> .box{<br>  display:inline-flex;<br> }</p><p>Webkit内核的浏览器，必须加上-webkit前缀</p><p> .box{<br>  display:-webkit;&#x2F;<em>Safari</em>&#x2F;display:flex;<br> }</p><p>设为flex布局后，子元素的float、clear、和vertical-align属性将失效。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用css3 flex布局的元素,称为flex容器，它的所有子元素自动称为容器成员，称为(flex item)<br>容器默认存在两根轴:水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置(与边框的交叉点)叫main start,结束位置叫做 main end；交叉抽的开始位置叫做cross start,结束位置叫做cross end;</p><h3 id="容器的6个属性"><a href="#容器的6个属性" class="headerlink" title="容器的6个属性"></a>容器的6个属性</h3><ol><li>flex-direction:</li></ol><p> 决定主轴的方向（即项目排列的方向）  </p><p> 用法：</p><p>  .box{<br>    flex-direction:row|row-reverse|column|column-reverse<br>  }  </p><p> 值：</p><p>  row:默认值 水平从左向右<br>  row-reverse:水平从右向左<br>  column:竖直从上往下<br>  column-reverse：竖直从下往上  </p><ol start="2"><li>flex-wrap:</li></ol><p> 默认情况下项目都排在一条（轴线）线上,flex-warp属性定义，如果一条轴线排不下，如何换行。  </p><p> 用法：</p><p>  .box{<br>   flex- wrap:nowrap| wrap | wrap -reverse;<br>  }  </p><p> 值:</p><p>  nowrap:默认不换行<br>  wrap：换行，第一行在上<br>  wrap -reverse：换行，第一行在下方  </p><ol start="3"><li>flex-flow:</li></ol><p> flex-flow属性是flex-direction属性和flex- wrap属性的简写形式，默认值是row no wrap。  </p><p> 用法:</p><p>  .box{<br>    flex-flow:<flex-direction> || <flex-wrap><br>  }</p><ol start="4"><li>justify-content:</li></ol><p> 定义了项目在主轴的对齐方式  </p><p> 用法：</p><p>  .box{<br>   justify-content:flex-start | flex-end | center | space-between | space-around;<br>  }<br>  值：</p><p>  flex-start:左对齐<br>  flex-end:右对齐<br>  center:居中<br>  space-between:两端对齐，项目之间的间隔都相等<br>  space-around: 每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍  </p><ol start="5"><li>align-items:</li></ol><p> 定义项目在交叉轴上如何对齐  </p><p> 用法：</p><p>  . box{<br>   align-items:flex-satrt |flex-end|center|baseline|stretch<br>  }  </p><p> 它可能取5个值，具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下  </p><p>  flex-start:交叉轴的起点对齐  </p><p>  flex-end:交叉轴的终点对齐  </p><p>  center:交叉轴中点对齐  </p><p>  baseline:项目中第一行文字的基线对齐  </p><p>  stretch（默认值）：如果项目未设置高度或者为auto，将占满整个容器的高度  </p><ol start="6"><li>align-content</li></ol><p> 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。  </p><p> 用法：</p><p>  .box{<br>   align-content:flex-start 或 flex-end 或 center 或 space-between 或 space-around 或 stretch<br>  }<br> 值:</p><p>  flex-start:与交叉轴起点对齐<br>  flex-end:与交叉轴终点对齐<br>  center：与交叉轴中点对齐<br>  space-between:与交叉轴两端对齐，轴线之间的间隔平均分布<br>  space-around:每根轴线两侧的间隔都相等，所以，轴线之间的间隔与边框的间隔大一倍<br>  stretch(默认):轴线占满整个交叉轴  </p><h3 id="项目的6个属性"><a href="#项目的6个属性" class="headerlink" title="项目的6个属性"></a>项目的6个属性</h3><ol><li>order:</li></ol><p> 定义项目的排列顺序，数值越小，排列越靠前，默认为0  </p><p> 用法:</p><p>  .item{<br>   order:interger;<br>  }  </p><ol start="2"><li>flex-grow</li></ol><p> 定义项目的放大比例，默认为0，如果存在剩余空间，也不放大  </p><p>  用法 ：</p><p>  .item{<br>    flex-grow:<number>&#x2F;<em>default 0</em>&#x2F;<br>  }  </p><ol start="3"><li>flex-shrink</li></ol><p> 定义了项目的缩小比例，默认为1，即如果控件不足，该项目将缩小  </p><p> 用法：</p><p>  .item{<br>   flex-shrink:number;&#x2F;<em>default 1</em>&#x2F;<br>  }  </p><ol start="4"><li>flex-basis</li></ol><p> 定义了在分配多余控件之前，项目占据的主轴控件(main size)浏览器根据这个属性,计算主轴是否有多余控件,它的默认值是auto,即项目的本来大小.  </p><p> 用法：</p><p>  .item{<br>   flex-basis:length 或 auto;&#x2F;<em>default auto</em>&#x2F;<br>  }  </p><p> 它可以设为跟width或height属性一样的值(比如350px)，则项目将占据固定控件  </p><ol start="5"><li>flex</li></ol><p> 属性是flex-grow,flex-shrink和flex-basis的简写，默认值为 0 1 auto;后两个属性可选  </p><p> 用法：</p><p>  .item{<br>   flex:none | flew-grow | flex-shrink | flex-basis<br>  }  </p><p> 该属性有两个快捷值： auto(1 1 auto)和none(0 0 auto)  </p><p> 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值  </p><ol start="6"><li>align-self:</li></ol><p>  允许单个项目与其他项目不一样的对齐方式，可覆盖align-items属性，默认值是auto，表示继承父类元素的align-items属性，如果没有父元素，则等同于stretch。  </p><p> 用法:</p><p> .item{<br>  align-self:auto 或 flex-start 或 flex-end 或 center 或 baseline 或 stretch<br> }</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2> <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>flex Box</title> <style> .flex-container {     /*给容器设置布局为flex布局*/     display: -webkit-flex;/*Safari*/     display: flex;<pre><code class="hljs"> /*1.flex-direction: 参数有row|row-reverse|column|column-reverse*/ /*flex-direction:row;*/ /*2.flex-wrap:参数有nowrap|wrap|wrap-reverse;*/ /*flex-wrap:wrap;*/ /*3.flex-flow是flex-direction和flex-wrap的集合*/ flex-flow:row wrap; /*4.justify-content: 参数有 flex-start|flex-end|center|space-between|space-around*/ /*justify-content:space-around;*/ /*5.align-items：参数有 flex-start|flex-end|center|baseline|stretch*/ /*align-items:flex-end;*/ /*6.align-content:参数有 flex-start|flex-end|center|space-between|space-around|stretch;*/ align-content:space-around; height:400px; /*background-color: lightgrey;*/</code></pre><p> }</p><p> .flex-item {<br>     background-color: cornflowerblue;<br>     width: 200px;<br>     height: 100px;<br>     margin: 5px;<br> }</p><p> .flex-item1{<br>   order: 3;<br>   flexs-shrink:0;<br> }<br> .flex-item3{<br>   order: 4;<br>   &#x2F;<em>flex-grow:1.5;</em>&#x2F;<br> }<br> .flex-item4{<br>   &#x2F;<em>flex-basis:600px;</em>&#x2F;<br> }<br> .flex-item5{<br>   &#x2F;<em>flex属性是flex-grow,flex-shrink和flex-basis 的简写，默认值是0 1 auto 后两个属性可选</em>&#x2F;<br>   &#x2F;<em>flex:0 1 auto;</em>&#x2F;<br>   flex:auto;  &#x2F;<em>1 1 auto</em>&#x2F;<br> }<br> .flex-item6{<br>   &#x2F;<em>align-self:参数有 auto(默认)|flex-start|flex-end|center|baseline|stretch|</em>&#x2F;<br>   &#x2F;<em>align-self:center;</em>&#x2F;<br> }</p><p> </style><br> </head><br> <body></p> <div class="flex-container">   <div class="flex-item flex-item1">flex item 1</div>   <div class="flex-item flex-item2">flex item 2</div>   <div class="flex-item flex-item3">flex item 3</div>   <div class="flex-item flex-item4">flex item 4 </div>     <div class="flex-item flex-item5">flex item 5 </div>     <div class="flex-item flex-item6">flex item 6</div> </div> </body> </html>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>边框和背景</title>
    <link href="/2020/12/10/border-and-background/"/>
    <url>/2020/12/10/border-and-background/</url>
    
    <content type="html"><![CDATA[<h2 id="css的边框和背景详解"><a href="#css的边框和背景详解" class="headerlink" title="css的边框和背景详解"></a>css的边框和背景详解</h2><h3 id="css边框的三个属性"><a href="#css边框的三个属性" class="headerlink" title="css边框的三个属性"></a>css边框的三个属性</h3><p>border:<br>用法：.box{ border:border-width||border-style||border-color;}(第三个颜色使可选的)  </p><p>css3中可以创建圆角边框，添加阴影框，并作为边框的形象而不使用设计程序  </p><ol><li>border-radius:</li></ol><p>用法 ：.box{ border-radius:25px;}</p><ol start="2"><li>border-shadow:</li></ol><p>用法 ：.box{ box-shadow:10px 10px 5px #888888;}</p><p>第一个参数是X轴偏移量，第二个参数是Y轴偏移量，第三个是阴影的尺寸，第四个是颜色</p><ol start="3"><li>border-image:</li></ol><p>用法 ：<br> .box{<br>  border- image:url() 30 30 round;<br>  -webkit-border-image:url() 30 30 round;&#x2F;<em>Safari and  older</em>&#x2F;<br>  -o-border-image:url() 30 30 round;&#x2F;<em>Opera</em>&#x2F;<br> }</p><p>总结:  </p> <!DOCTYPE html> <html> <head> <meta charset="utf-8"> <title>边框</title> <style> .flex-container {     display: -webkit-flex;     display: flex;     flex-flow:row wrap;     justify-content:stretch;     /*align-items:baseline;*/     align-content:stretch;     /*width: 400px;*/<pre><code class="hljs"> height:400px; background-color: lightgrey;</code></pre><p> }</p><p> .flex-item {<br>     background-color: cornflowerblue;<br>     width: 200px;<br>     height: 100px;<br>     margin: auto;<br>     margin-right: 10px;<br>     border:1px solid red;<br>     border-radius:5px 15px 20px 35px;<br> &#x2F;<em>边框阴影</em>&#x2F;<br>     -moz-box-shadow: 10px 10px 5px #888888; &#x2F;<em>老的 Firefox</em>&#x2F;<br>     box-shadow: 10px 10px 5px #888888;<br> }<br> .flex-item:hover{<br> &#x2F;<em>-webkit-flex-shrink:0.5;<br>   flex-shrink:2;</em>&#x2F;<br>   flex-grow:1.2;<br>   border-color: green;<br> }</p><p> </style><br> </head><br> <body></p> <div class="flex-container">   <div class="flex-item">flex item 1</div>   <div class="flex-item">flex item 2</div>   <div class="flex-item">flex item 3</div>   <div class="flex-item">flex item 4</div>     <div class="flex-item">flex item 5</div>     <div class="flex-item">flex item 6</div>   <div class="flex-item">flex item 7</div>   <div class="flex-item">flex item 8</div>   <div class="flex-item">flex item 9</div>     <div class="flex-item">flex item 10</div> </body> </html>  <h3 id="CSS3中包含几个新的背景属性，提供更大的背景元素控制"><a href="#CSS3中包含几个新的背景属性，提供更大的背景元素控制" class="headerlink" title="CSS3中包含几个新的背景属性，提供更大的背景元素控制"></a>CSS3中包含几个新的背景属性，提供更大的背景元素控制</h3><p> 1.background-image:<br>  .box{<br>  background-image:url();<br>  background-position:left bottom;<br> }<br>背景图片，背景图片的位置</p><p> 2.background-size:<br>  .box{<br>  background-size:100% 100%;<br> }<br>背景图片的大小  </p><p> 3.background-orgin:<br>  .box{<br>  background:border-box或content-box或padding-box<br> }<br>是指背景显示的区域，或者说背景是从哪个区域开始绘制的(边框、补白或内容区域)  </p><p> 4.background-clip:<br>  .box{<br>  background-clip:content-box或padding-box或border-box;<br> }<br>该属性指定了背景在哪些区域可以显示，但与背景开始绘制的位置无关，背景的绘制的位置可以出现在不显示背景的区域，这时就相当于背景图片被不显示背景的区域裁剪了一部分一样。  </p><p> 5.background-attachment:<br>scroll:默认值，背景图相对于元素固定，背景随页面滚动而移动，即背景和内容绑定。</p><p>fixed：背景图相对于视口固定，所以随页面滚动背景不动，相当于背景被设置在了body上。</p><p>local：背景图相对于元素内容固定，</p><p>inhert:继承，没什么说的。</p>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《HTML5移动Web开发实战》</title>
    <link href="/2020/11/12/h5web-learn/"/>
    <url>/2020/11/12/h5web-learn/</url>
    
    <content type="html"><![CDATA[<h1 id="《HTML5移动Web开发实战》"><a href="#《HTML5移动Web开发实战》" class="headerlink" title="《HTML5移动Web开发实战》"></a>《HTML5移动Web开发实战》</h1><p>第一章：HTML5与移动网站，介绍HTML5和移动网站的基本概念，包括一些模拟器和仿真器</p><p>第二章：移动端的配置和优化，讨论针对多种移动设备的配置和优化，例如禁用文字缩放和优化可视宽度</p><p>第三章：移动设备的交互方式，讨论了手势事件等移动交互</p><p>第四章：构建快速响应式移动互联网站点，介绍了各种构建快速响应式网站的方法</p><p>第五章：移动设备访问，讨论了基于地理位置的移动互联网站和其他HTML5针对设备的功能</p><p>第六章：移动富媒体，介绍了可用于移动浏览器的HTML5富媒体元素</p><p>第七章：移动设备调试，讲解了如何在移动设备屏幕尺寸的限制下有效地调试移动网站和应用</p><p>第八章：服务端性能调优，关注移动网站的服务器性能调优</p><p>第九章：移动性能调试，讲解了各种可用于移动性能调优的工具和技术</p><p>第十章：拥抱移动互联网特性，讲解了ECMAScript5等一些针对移动设备的功能及性能优化。</p><h1 id="HTML5与移动网站"><a href="#HTML5与移动网站" class="headerlink" title="HTML5与移动网站"></a>HTML5与移动网站</h1><p>为什么HTML5没有版本号？</p><ol><li>浏览器并不针对HTML的某个版本做支持，而是针对某个功能做支持。就是说如果浏览器支持你使用的某个功能，即使你把文档申明为HTML4，浏览器仍然会按照HTML5的标准来显示页面。</li><li>名字可以很简洁</li></ol><h1 id="HTML5与移动网站——配置和优化"><a href="#HTML5与移动网站——配置和优化" class="headerlink" title="HTML5与移动网站——配置和优化"></a>HTML5与移动网站——配置和优化</h1><h2 id="通过界面图标启动Web应用"><a href="#通过界面图标启动Web应用" class="headerlink" title="通过界面图标启动Web应用"></a>通过界面图标启动Web应用</h2> <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,initial-scale=1.0,user-scalable=no" /><pre><code class="hljs">&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot; href=&quot;icons/apple-touch-icon-114x114-precomposed.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot; href=&quot;icons/apple-touch-icon-72x72-precomposed.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;57x57&quot; href=&quot;icons/apple-touch-icon-57x57-precomposed.png&quot;&gt;&lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;icons/apple-touch-icon-precomposed.png&quot;&gt;</code></pre> <link rel="shortcut icon" href="icons/apple-touch-icon.png"><h2 id="避免文本字体大小重置"><a href="#避免文本字体大小重置" class="headerlink" title="避免文本字体大小重置"></a>避免文本字体大小重置</h2><p> html{<br>  -webkit-text-size-adjust:100%;<br>  -ms-text-size-adjust:100%;<br>  text-size-adjust:100%;<br> }</p><h3 id="px-em-哪个更好？"><a href="#px-em-哪个更好？" class="headerlink" title="px,em 哪个更好？"></a>px,em 哪个更好？</h3><p>在Web开发领域，关于应该使用px(像素)还是em(相对长度单位，相对于当前对象内文本的字体尺寸)的争论不绝于耳，但是，这个问题在移动互联网开发领域，争论并没有那么激烈，Yahoo！的用户接口原本使用的单位是em，他们这么做的原因是IE6不支持px级别的缩放。但是，这在移动互联网开发领域，并不是问题，因为，使用IE6的用户已经越来越少了。因此，在大部分场景下，你都可以使用像素来设置字体大小，抛开使用em遇到的各种问题和烦人的计算。</p><h2 id="优化浏览器视口宽度设置"><a href="#优化浏览器视口宽度设置" class="headerlink" title="优化浏览器视口宽度设置"></a>优化浏览器视口宽度设置</h2> <meta content="width=device-width name="viewport"><h2 id="修复移动版Safari的re-flow-scale问题"><a href="#修复移动版Safari的re-flow-scale问题" class="headerlink" title="修复移动版Safari的re-flow scale问题"></a>修复移动版Safari的re-flow scale问题</h2>   <meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">控制手势缩放<h2 id="iphone下全屏模式启动"><a href="#iphone下全屏模式启动" class="headerlink" title="iphone下全屏模式启动"></a>iphone下全屏模式启动</h2><p>适用设备： iOS设备</p><p>为了让一个Web应用看起来更像一个原生应用，iPhone为Web应用开发这提供了很多独有的特性，你可以全屏模式下启动Web应用，可以添加一个启动界面，甚至添加一个加载进度条之类的，或者为你的Web应用定义一个预加载的页面。</p> <meta name="apple-mobile-web-app-capable" content="yes" /><p>这段代码的意思是当Web应用从界面图标启动时，以全屏模式启动，隐藏浏览器上部的工具栏、地址栏和底部的加载状态栏</p> <meta name="apple-mobile-web-app-status-bar-style" content="black" />这段代码的作用是在浏览器顶部显示一个状态栏 <link rel="apple-touch-startup-image" href = "img/1/splash.png">这段代码的作用是，在程序启动、加载的时候，显示一个预加载界面，告诉用户该程序正在加载<p>由于iPad和iPhone因为屏幕大小的差异，因此需要不同大小的预加载界面，因此，如果你希望你的Web可以动态地选择对应的加载界面，你可以使用如下的JavaScript函数做到：</p><p> var filename &#x3D; navigator.platform &#x3D;&#x3D;&#x3D; ‘ipad’?’h&#x2F;‘:’l&#x2F;‘;</p><p> document.write(‘&lt;link rel&#x3D;”apple-touch-start-image” href&#x3D;”&#x2F;img&#x2F;‘+filname +”splash.png” &#x2F;&gt;’);</p><h2 id="防止iOS在聚焦时自动缩进"><a href="#防止iOS在聚焦时自动缩进" class="headerlink" title="防止iOS在聚焦时自动缩进"></a>防止iOS在聚焦时自动缩进</h2><p>略</p><h2 id="禁用或限制部分WebKit特性"><a href="#禁用或限制部分WebKit特性" class="headerlink" title="禁用或限制部分WebKit特性"></a>禁用或限制部分WebKit特性</h2><p>为狭窄的屏幕添加省略号功能</p><p> .ellipsis{<br>  text-overflow:ellipsis;<br>  overflow:hidden;<br>  white-space:nowrap;<br> }</p><h1 id="移动设备的交互方式"><a href="#移动设备的交互方式" class="headerlink" title="移动设备的交互方式"></a>移动设备的交互方式</h1><p>移动设备与桌面设备最大的不同在于交互方式，在桌面设备上，我们利用鼠标移动和点击来交互，而在移动设备上，交互来自触控和手势。</p><h2 id="利用触控来移动页面元素"><a href="#利用触控来移动页面元素" class="headerlink" title="利用触控来移动页面元素"></a>利用触控来移动页面元素</h2><p>利用jQuery来注册touchmove事件。利用touch.pageX和touch.pageY可以获取相对于页面的触摸位置，我们将触摸位置减去div高度和宽度的一半，这样，div的拖动就在它的中心点上。</p><p> var x &#x3D; touch.pageX - elm.left&#x2F;2;<br> var y &#x3D; touch.pageY - elm.top&#x2F;2;</p><p>将x和y的值赋给div的CSS位置属性，它就可以移动了。</p><p> $(this).css(‘left’,x+’px’);<br> $(this).css(‘top’,y+’px’);</p><p>特殊的，移动版Safari不允许event对象touches和changedTouches属性被拷贝给其他对象。我们可以使用e.originalEvent来解决这个问题。</p><p> var touch &#x3D; e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];</p><h3 id="jQuery移动版事件"><a href="#jQuery移动版事件" class="headerlink" title="jQuery移动版事件"></a>jQuery移动版事件</h3><p>jQuery移动版是一系列的组件</p><h3 id="Zepto"><a href="#Zepto" class="headerlink" title="Zepto"></a>Zepto</h3><p>如果你的主要浏览器是基于WebKit，那么你可以考虑Zepto，这个轻量级的jQuery替代品。</p><h2 id="监测和处理横竖屏切换事件"><a href="#监测和处理横竖屏切换事件" class="headerlink" title="监测和处理横竖屏切换事件"></a>监测和处理横竖屏切换事件</h2><p>对于移动浏览器，如果网站是基于流体布局的，那么在横竖屏切换的时候，网站样式也应该有响应的变化。但是对于富交互的网站，有时也需要以特别的方式来处理横竖屏切换。</p><p>通过监听widow.onorientationchange事件，当横竖屏切换事件触发时，orientationchange会被触发，同时我们得到event.orientation作为参数传递给该方法并输出结果。</p><p>有时，你需要禁用横竖屏的自动切换，比如开发游戏，对于原生应用这很容易，但对于网页应用非常困难。</p> <!doctype html> <html>   <head>   <title>锁定页面为横屏模式</title>   <meta charset="utf-8">   <meta name="viewport" content="width=device-width, initial-scale=1.0">   <style>   html, body {    padding: none;    margin: none;   }   </style>     <link rel="stylesheet" href="http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.min.css" />     <script src="http://code.jquery.com/jquery-1.6.4.min.js"></script>     <script src="http://code.jquery.com/mobile/1.0/jquery.mobile-1.0.min.js"></script>   </head>   <body>     <div id="a">     </div>   <script>    var metas = document.getElementsByTagName('meta');    var i;    if (navigator.userAgent.match(/iPhone/i)) {     for (i=0; i<metas.length; i++) {      if (metas[i].name == "viewport") {       metas[i].content = "width=device-width, minimum-scale=1.0, maximum-scale=1.0";      }     }     document.addEventListener("gesturestart", gestureStart, false);    }    function gestureStart() {     for (i=0; i<metas.length; i++) {      if (metas[i].name == "viewport") {       metas[i].content = "width=device-width, minimum-scale=0.25, maximum-scale=1.6";      }     }    }   </script>   <script>       $(window).bind('orientationchange',function(event){         updateOrientation(event.orientation);       })    function updateOrientation(orientation) {         $("#a").html("<p>"+orientation.toUpperCase()+"</p>");    }   </script>  </body> </html><p>使用window.orientation可以检测当前的屏幕模式，它有四个值:-90、0、90、180。横屏时的值为-90或90，竖屏时的值是0或180。</p><p> switch(window.orientation){<br>  case 0 :&#x2F;&#x2F;<br>  case 180 :&#x2F;&#x2F;<br>  case -90 :&#x2F;&#x2F;<br>  case 90 :&#x2F;&#x2F;<br> }</p><h2 id="利用手势来旋转页面元素"><a href="#利用手势来旋转页面元素" class="headerlink" title="利用手势来旋转页面元素"></a>利用手势来旋转页面元素</h2><p>当用户在移动版Safari中，使用两指触控来旋转，我们可以检测到旋转的角度，因此，我们可以使用两指触控来旋转页面元素。</p> <!doctype html> <html>   <head>   <title>Mobile Cookbook</title>   <meta charset="utf-8">   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">   <style>     #main {       text-align:center;     }   #someElm {       margin-top:50px;       margin-left:50px;    width: 200px;    height: 200px;    background:#ccc;    position:absolute;   }   </style>   </head>   <body>     <header>     </header>   <div id="main">    <div id="someElm">    </div>   </div>     <footer>     </footer>   <script>   var rotation =0 ;     var node = document.getElementById('someElm');     node.ongesturechange = function(e){       var node = e.target;       //alert(e.rotation);       node.style.webkitTransform = "rotate(" + ((rotation + e.rotation) % 360) + "deg)";     }     node.ongestureend = function(e){       rotation = (rotation + e.rotation) % 360;     }   </script>  </body> </html><p>只针对Safari有效</p><h2 id="利用滑动来创建图库"><a href="#利用滑动来创建图库" class="headerlink" title="利用滑动来创建图库"></a>利用滑动来创建图库</h2><p>移动设备上常用的功能之一就是滑动。在照片库中浏览照片时，我们会左右滑动来切换照片。在Android设备中，我们会向下滑动来解锁。</p> <!doctype html> <html>   <head>   <title>利用滑动创建图库</title>   <meta charset="utf-8">   <meta name="viewport" content="width=device-width, initial-scale=1.0">   <style>    html, body {     padding:0;     margin:10px auto;    }    #checkbox {     border:5px solid #ccc;     width:30px;     height:30px;    }    #wrapper {     width:210px;     height:100px;     position:relative;     overflow:hidden;     margin:0 auto;    }    #inner {     position:absolute;     width:630px;    }    #inner div {     width:200px;     height:100px;     margin:0 5px;     background:#ccc;     float:left;    }    .full-circle {      background-color: #ccc;      height: 10px;      -moz-border-radius:5px;      -webkit-border-radius: 5px;      width: 10px;      float:left;      margin:5px;    }    .cur {     background-color: #555;    }    #btns {     width:60px;     margin:0 auto;    }   </style>   </head>   <body>     <header>     </header>   <div id="main">    <div id="wrapper">     <div id="inner">      <div></div>      <div></div>      <div></div>     </div>    </div>    <div id="btns">     <div class="full-circle cur"></div>     <div class="full-circle"></div>     <div class="full-circle"></div>    </div>   </div>     <footer>     </footer>   <script src="http://code.jquery.com/jquery-1.5.2.min.js"></script>   <script src="http://code.jquery.com/mobile/1.0a4.1/jquery.mobile-1.0a4.1.min.js"></script>   <script>   var curNum = 0;   $('#wrapper').swipeleft(function () {       //alert('hi');    $('#inner').animate({    left: '-=210'    }, 500, function() {     // Animation complete.     curNum +=1;     $('.full-circle').removeClass('cur');     $('.full-circle').eq(curNum).addClass('cur');    });   });<p>   $(‘#wrapper’).swiperight(function () {<br>    $(‘#inner’).animate({<br>    left: ‘+&#x3D;210’<br>    }, 500, function() {<br>     &#x2F;&#x2F; Animation complete.<br>     curNum -&#x3D;1;<br>     $(‘.full-circle’).removeClass(‘cur’);<br>     $(‘.full-circle’).eq(curNum).addClass(‘cur’);<br>    });<br>   });<br>   </script><br>  </body><br> </html></p><p>在移动浏览器打开，并在灰色区域左右滑动，你可以看到它随着手指滑动在左右移动。</p><h3 id="Zepto框架与滑动事件"><a href="#Zepto框架与滑动事件" class="headerlink" title="Zepto框架与滑动事件"></a>Zepto框架与滑动事件</h3><p>我们可以使用Zepto框架完成类似的功能，他提供了swipe、swipeLeft、swipeRight、swipeDown。</p><h3 id="YUI与手势事件"><a href="#YUI与手势事件" class="headerlink" title="YUI与手势事件"></a>YUI与手势事件</h3><p>YUI提供了手势事件来创建滑动效果</p><h2 id="利用手势进行图片缩放"><a href="#利用手势进行图片缩放" class="headerlink" title="利用手势进行图片缩放"></a>利用手势进行图片缩放</h2> <!doctype html> <html>   <head>   <title>手势放大缩小</title>   <meta charset="utf-8">   <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">   <style>    #frame {     width:100px;     height:100px;     background:#ccc;    }   </style>   </head>   <body>     <header>     </header>   <div id="main">    <div id="frame"></div>   </div>     <footer>     </footer>   <script src="http://code.jquery.com/jquery-1.5.2.min.js"></script>   <script src="http://code.jquery.com/mobile/1.0a4.1/jquery.mobile-1.0a4.1.min.js"></script>   <script>   var width = 100, height = 100;   var node = document.getElementById('frame');   node.ongesturechange = function(e){    var node = e.target;    // scale and rotation are relative values,    // so we wait to change our variables until the gesture ends    node.style.width = (width *e.scale) + "px";node.style.height = (height* e.scale) + "px";   }   node.ongestureend = function(e){    // Update the values for the next time a gesture happens    width *= e.scale;height*= e.scale;   }   </script>  </body> </html><h2 id="加速按钮反馈"><a href="#加速按钮反馈" class="headerlink" title="加速按钮反馈"></a>加速按钮反馈</h2><p>在移动设备浏览器上，Web应用中的按钮的反馈总会比原生应用的按钮反馈慢一点，其实，在移动设备的浏览器上有一个叫做”touchstart”的事件，通过检测该事件来替代按钮点击事件，会让应用更快地得到按钮的反馈。</p><h2 id="优化polyfills脚本的加载速度"><a href="#优化polyfills脚本的加载速度" class="headerlink" title="优化polyfills脚本的加载速度"></a>优化polyfills脚本的加载速度</h2><p>对于任何浏览器来说，加载脚本都是一项很重要且消耗性能的工作，对于移动设备来说更是如此，因为其带宽非常有限。Modernizr为这个问题提供了一个动态加载的解决方案。</p><h2 id="检测用户客户端"><a href="#检测用户客户端" class="headerlink" title="检测用户客户端"></a>检测用户客户端</h2><p>在开发移动互联网站点时，有客户端检测功能将会非常有用，它可以帮我们重定向请求到客户端对应的版本，或者决定是否加载某些脚本或图片。</p><h2 id="使用书签气泡为应用程序添加桌面快捷方式"><a href="#使用书签气泡为应用程序添加桌面快捷方式" class="headerlink" title="使用书签气泡为应用程序添加桌面快捷方式"></a>使用书签气泡为应用程序添加桌面快捷方式</h2><p>在不同设备上添加桌面快捷方式，可以让Web应用看起来更像原生应用。</p><h2 id="构建可自动伸缩的文本输入框"><a href="#构建可自动伸缩的文本输入框" class="headerlink" title="构建可自动伸缩的文本输入框"></a>构建可自动伸缩的文本输入框</h2><h2 id="隐藏浏览器的地址栏"><a href="#隐藏浏览器的地址栏" class="headerlink" title="隐藏浏览器的地址栏"></a>隐藏浏览器的地址栏</h2><h2 id="构建移动互联网的站点地图"><a href="#构建移动互联网的站点地图" class="headerlink" title="构建移动互联网的站点地图"></a>构建移动互联网的站点地图</h2><h1 id="移动设备访问"><a href="#移动设备访问" class="headerlink" title="移动设备访问"></a>移动设备访问</h1><h2 id="获取位置信息"><a href="#获取位置信息" class="headerlink" title="获取位置信息"></a>获取位置信息</h2><p>从地理信息接口开始，网页应用可以拥有丰富的设备感知的功能和体验。一些基于设备访问的绝佳的创意已经开发出来了，从基于麦克风的音频输入访问和基于摄像头的视频输入访问，到本地数据(如联系人和事件)，甚至时重力感应都包括在内。</p><p>基于位置的社交网络，将会从根本上改变用户行为习惯和零售业的运营模式。</p><h2 id="跨浏览器定位"><a href="#跨浏览器定位" class="headerlink" title="跨浏览器定位"></a>跨浏览器定位</h2><p>地理信息接口不一定在所有移动浏览器上都可用，甚至对于支持它的浏览器也一样，浏览器可能有与标准不同的接口。</p><h1 id="第六章，移动富媒体"><a href="#第六章，移动富媒体" class="headerlink" title="第六章，移动富媒体"></a>第六章，移动富媒体</h1><p>多媒体——越来越多的永华直接在线接受音频和观看视频了，我们将为大家介绍如何把这些多媒体元素添加到移动互联网应用中。</p><p>离线和存储——对于移动设备来说，网络链接是非常不稳定的，因此离线使用对移动应用来说是非常重要，</p><p>性能和集成——通过使用Web Workers，我们可以在移动浏览器上得到更好的性能。</p><h2 id="移动设备上播放音频"><a href="#移动设备上播放音频" class="headerlink" title="移动设备上播放音频"></a>移动设备上播放音频</h2><p><a href="/Demo/H5Web/index.html">案例源码</a></p>]]></content>
    
    
    <categories>
      
      <category>HTML5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮动与清除浮动</title>
    <link href="/2020/10/11/CSS-clearfix/"/>
    <url>/2020/10/11/CSS-clearfix/</url>
    
    <content type="html"><![CDATA[<h1 id="浮动与清除浮动"><a href="#浮动与清除浮动" class="headerlink" title="浮动与清除浮动"></a>浮动与清除浮动</h1><h2 id="浮动的性质"><a href="#浮动的性质" class="headerlink" title="浮动的性质"></a>浮动的性质</h2><h2 id="浮动的元素脱离标准流"><a href="#浮动的元素脱离标准流" class="headerlink" title="浮动的元素脱离标准流"></a>浮动的元素脱离标准流</h2><p>浮动的元素脱离标准流，不再区分块级元素和行内元素。能够让浮动的元素并排在一行显示，还可以设置宽高。</p> <head> <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> <title>Document</title> <style type="text/css">  *{   padding:0;   margin:0;  }  div{   float:left;   width:200px;   height:60px;   background-color: pink;  }  span{   float: left;   width:200px;   height:60px;   background-color: lightblue;  } </style> </head> <body>  <div>div</div>  <span>span</span> </body><h2 id="浮动的元素没有margin塌陷"><a href="#浮动的元素没有margin塌陷" class="headerlink" title="浮动的元素没有margin塌陷"></a>浮动的元素没有margin塌陷</h2> <head>  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  <title>Document</title>  <style type="text/css">   *{    padding:0;    margin:0;   }   .box{    width: 300px;    height: 600px;    border:1px solid #ddd;   }   .box .son1{    width: 200px;    height: 200px;    background-color: lightblue;    margin-bottom:50px;    float: left;   }   .box .son2{    float: left;    width: 200px;    height: 200px;    background-color: pink;    margin-top:80px;   }  </style> </head> <body>  <div class="box">   <div class="son1"></div>   <div class="son2"></div>  </div> </body><h2 id="浮动的元素依次贴边"><a href="#浮动的元素依次贴边" class="headerlink" title="浮动的元素依次贴边"></a>浮动的元素依次贴边</h2><p>浮动的元素依次贴边，贴边有方向之分。<br>以左浮动为例：</p><p>1、 贴边顺序：父盒子内侧 ← 子盒子1 ← 子盒子2 ← 子盒子3 ← 子盒子4….</p> <head>  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  <title>Document</title>  <style type="text/css">   /*清除默认样式*/   *{    padding:0;    margin:0;   }   .box{    width: 500px;    height: 300px;    background-color: pink;    border:1px solid #ddd;   }   .box div{    float:left;    width: 100px;    height: 100px;   }   .box div.son1{    background-color: blue;   }   .box div.son2{    background-color: purple;   }   .box div.son3{    background-color: yellowgreen;   }   .box div.son4{    background-color: lightblue;   }  </style> </head> <body>  <div class="box">   <div class="son1">1</div>   <div class="son2">2</div>   <div class="son3">3</div>   <div class="son4">4</div>  </div> </body><p>2、如果前一个盒子剩余的宽度不够，会再前一个贴边。</p> <head>  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  <title>Document</title>  <style type="text/css">   /*清除默认样式*/   *{    padding:0;    margin:0;   }   .box{    width: 500px;    height: 300px;    background-color: pink;    border:1px solid #ddd;   }   .box div{    float:left;    width: 100px;    height: 100px;   }   .box div.son1{    height:200px;    background-color: blue;   }   .box div.son2{    width:200px;    height:150px;    background-color: purple;   }   .box div.son3{    height:130px;    background-color: yellowgreen;   }   .box div.son4{    width:130px;    height:50px;    background-color: lightblue;   }  </style> </head> <body>  <div class="box">   <div class="son1">1</div>   <div class="son2">2</div>   <div class="son3">3</div>   <div class="son4">4</div>  </div> </body><p>3、浮动的元素不会钻盒子：</p> <head>  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  <title>Document</title>  <style type="text/css">   /*清除默认样式*/   *{    padding:0;    margin:0;   }   .box{    width: 500px;    height: 300px;    background-color: pink;    border:1px solid #ddd;   }   .box div{    float:left;    width: 100px;    height: 100px;   }   .box div.son1{    height:230px;    background-color: blue;   }   .box div.son2{    background-color: purple;   }   .box div.son3{    height:190px;    width:290px;    background-color: yellowgreen;   }   .box div.son4{    width:60px;    height:100px;    background-color: lightblue;   }  </style> </head> <body>  <div class="box">   <div class="son1">1</div>   <div class="son2">2</div>   <div class="son3">3</div>   <div class="son4">4</div>  </div> </body><p>4、浮动的元素让出标准流的位置</p> <head>  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  <title>Document</title>  <style type="text/css">   *{    padding:0;    margin:0;   }   .box1{    float:left;    width:100px;    height:100px;    background-color: pink;   }   .box2{    width: 200px;    height: 200px;    background-color: lightblue;   }  </style> </head> <body>  <div class="box1">1</div>  <div class="box2">2</div> </body><h2 id="浮动的影响（浮动存在的问题）"><a href="#浮动的影响（浮动存在的问题）" class="headerlink" title="浮动的影响（浮动存在的问题）"></a>浮动的影响（浮动存在的问题）</h2><ol><li>浮动的元素不能撑高父盒子。</li><li>浮动的元素会影响后面浮动的元素。</li></ol><p>浮动的影响，导致box1和box2没有被撑起，且box2的元素位置错乱</p> <head>  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">  <title>Document</title>  <style type="text/css">   *{    padding:0;    margin:0;   }   .box1,.box2{    width:700px;    border:5px solid #ddd;    margin-bottom:10px;   }   .box1 p,.box2 p{    float: left;    width:100px;    height:100px;    background-color: lightblue;    margin-right:10px;   }  </style> </head> <body>  <div class="box1">   <p>1</p>   <p>2</p>   <p>3</p>   <p>4</p>  </div>  <div class="box2">   <p>5</p>   <p>6</p>   <p>7</p>  </div> </body><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><ol><li>给父盒子直接加高度</li></ol><p> 解决：对后面浮动元素的影响；margin有距离。没解决：高度自适应。</p><ol start="2"><li>加clear属性</li></ol><p>  clear:清除；<br>   属性值：left（清除左浮动元素的影响）<br>   right（清除右浮动元素的影响）<br>   both(清除左右浮动元素的影响)。</p><p> 解决：浮动元素对后面浮动元素的影响。</p><p> 没解决：高度自适应；margin距离</p><ol start="3"><li>隔墙法</li></ol><p> 3.1  外墙法</p><p> 给俩个大盒子之间加一堵清除了浮动，有高度的墙。</p><p> 解决：浮动元素对后面浮动元素的影响；视觉有了距离；</p><p> 没解决：高度自适应</p><p> 3.2  内墙法</p><p> 在两个大盒子的最底部加一堵清除了浮动的墙。</p><p> 解决：都解决了。</p><p> 虽然内墙法解决了我们所有问题，但是增加了很多无意义的标签。影响代码加载速度以及可读性。</p><ol start="4"><li>overflow法</li></ol><p> 给父盒子加overflow:hidden;</p><p>overflow：hidden作用</p><ol><li>强制我们父盒子去检测里面的子盒子的高度，让父盒子的高度等于子盒子的高度。（以后只要看到让盒子高度自适应，就加overflow:hidden）</li><li>强制我们父盒子去检测他里面浮动的子盒子，管住他里面浮动的元素不让他去影响别人。<br>（overflow：hidden;是我们解决浮动存在的问题的最好也是最简单的办法）</li></ol><p>实际工作中：</p><p>我们使用overflow：hidden;解决浮动存在的问题；</p><p>可以在几个大的板块之间加一堵墙；</p>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux命令大全</title>
    <link href="/2020/10/11/linux/"/>
    <url>/2020/10/11/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="linux命令大全"><a href="#linux命令大全" class="headerlink" title="linux命令大全"></a>linux命令大全</h1><h2 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h2><p>Linux系统中如果显示乱码：<br>在窗口中输入</p><p> export LANG&#x3D;zh_CN.UTF-8</p><h2 id="文件的上传下载"><a href="#文件的上传下载" class="headerlink" title="文件的上传下载"></a>文件的上传下载</h2><p>如果有ftp工具，可直接使用，但我们公司由于怕图形化界面多人传文件时容易产生覆盖和文件夹错乱的情况，修改为使用了cp的方法上传和下载</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>创建临时文件夹</p><p> mkdir&#x2F;mnt&#x2F;tmp</p><p> mount -t cifs -o username&#x3D;bm,password&#x3D;bm &#x2F;&#x2F;10.0.0.11&#x2F;ITDeveloper &#x2F;mnt&#x2F;tmp</p><p>绑定mnt&#x2F;tmp文件夹，这里将bm用户上传在10.0.0.11上的ITDeveloper上的文件与linux系统中创建的临时文件绑定，此时你ls可发现tmp中的文件和ITDeveloper中的文件是一模一样的。</p><p>此时，你就可以操作文件，将tmp中的文件放在你的lunx文件系统中的任何位置</p><p> cp -rf &#x2F;复制文件路径&#x2F; &#x2F;你要存放的路径&#x2F;</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>很简单，就是上传的逆操作，就是把文件复制的路径换一下就可以了（此方法通常用来备份文件）</p><h2 id="重启服务器"><a href="#重启服务器" class="headerlink" title="重启服务器"></a>重启服务器</h2><p> &#x2F;opt&#x2F;tomcat-6.0.35-xxx&#x2F;bin&#x2F;kdtomcat-xxx restart</p><p>上传下载文件操作完成之后，一定要重启服务器才能看见效果</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一些linux常见的命令行操作：</p><p>复制文件操作:</p><p> cp -r dir1 dir2<br>把dir1中的所有文件复制到dir2文件夹下，如果dir2不存在，则可以直接使用此命令行。</p><p>如果dir2已经存在，则需要使用</p><p> cp -r dir1&#x2F;. dir2<br>如果仍使用 cp -r dir1 dir2则会使得dir1也复制到dir2中</p><p> cp -rf dir1 dir2<br>会一个一个提示你确认覆盖操作</p><p>copy命令的功能是将给出的文件或目录拷贝到另一文件或目录中，同MSDOS下的copy命令一样，功能十分强大。</p><p>语法： cp [选项] 源文件或目录 目标文件或目录</p><p>说明：该命令把指定的源文件复制到目标文件或把多个源文件复制到目标目录中。</p><p>该命令的各选项含义如下：</p><ol><li><p>-a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。</p></li><li><p>-d 拷贝时保留链接。</p></li><li><p>-f 删除已经存在的目标文件而不提示。</p></li><li><p>-i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。</p></li><li><p>-p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。</p></li><li><p>-r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。</p></li><li><p>-l 不作拷贝，只是链接文件。</p></li></ol><p><strong>需要说明的是，为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名已存在，用cp命令拷贝文件后，这个文件就会被新源文件覆盖，因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。</strong></p><h2 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h2><p>浏览文件的命令  -n 显示文件的时候显示行号  太长的文件不不适合用这个命令</p><h2 id="tac命令"><a href="#tac命令" class="headerlink" title="tac命令"></a>tac命令</h2><p>逆序显示自定文件的内容(cat 倒着写)</p><h2 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h2><p>正序从0行开始查看指定文件的命令 （默认显示文件最前10行）<br>eg:head vi.txt  查看vi.txt的内容<br>eg:head -n 3 vi.txt 查看vi.txt文件的前3行内容。</p><h2 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h2><p>逆序从指定行开始查看指定文件到最后一行的命令（默认显示文件最后10行）-n   -f动态显示<br>eg:tail -n 3 vi.txt   查看vi.txt文件最后3行的内容。</p><h2 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a>ln命令</h2><p>链接命令  link缩写   -s表示是软链接(不加该参数表示是硬链接的意思)</p><p>软链接和硬链接的区别：硬链接相当于复制，会同步更新。硬链接用的文件的-i文件号是一样的。</p><p>eg:ln abc.txt l1   创建一个硬链接l1,l1和abc.txt文件同步。</p><p>eg:ln -s abc.txt l2 创建一个软链l2,l2指向abc.txt文件，像windows里面的快捷方式。</p><p>eg:ln -s &#x2F;home&#x2F;local &#x2F;usr  意思是将 &#x2F;home&#x2F;local 在&#x2F;usr下创建一个快捷方式(在&#x2F;usr下面也能看到local文件夹)。</p><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>文件复制    copy缩写</p><p>cp aaa.txt bbb.txt  将 aaa.txt文件复制(已存在)，并命名为 bbb.txt文件</p><p>cp -rf aaa bbb  将文件夹aaa复制(已存在)，并命名为 bbb文件夹    解释:-rf 这个参数是递归强制的意思</p><h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><p>不同电脑之间的文件复制命令</p><p>scp mongodb-linux-x86_64-2.6.4.tgz <a href="mailto:&#114;&#111;&#x6f;&#x74;&#x40;&#49;&#x31;&#57;&#x2e;&#50;&#53;&#53;&#x2e;&#x32;&#55;&#x2e;&#51;&#56;">&#114;&#111;&#x6f;&#x74;&#x40;&#49;&#x31;&#57;&#x2e;&#50;&#53;&#53;&#x2e;&#x32;&#55;&#x2e;&#51;&#56;</a>:&#x2F;home&#x2F;software&#x2F;将当前系统下的 scp mongodb-linux-x86_64-2.6.4.tgz 复制到119.255.27.38的&#x2F;home&#x2F;software&#x2F;路径下面拷贝一个文件</p><p>scp <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#49;&#x31;&#x39;&#x2e;&#x32;&#53;&#x35;&#46;&#x32;&#x37;&#46;&#x33;&#x38;">&#x72;&#111;&#111;&#116;&#x40;&#49;&#x31;&#x39;&#x2e;&#x32;&#53;&#x35;&#46;&#x32;&#x37;&#46;&#x33;&#x38;</a>:&#x2F;home&#x2F;software&#x2F;jdk-7u60-linux-x64.rpm &#x2F;home&#x2F;software将19.255.27.38系统上的&#x2F;home&#x2F;software&#x2F;jdk-7u60-linux-x64.rpm 文件复制到本地的&#x2F;home&#x2F;software路径下</p><p>scp 断点续传怎么实现？20160310</p><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>移动文件&#x2F;文件夹     move缩写<br>mv   &#x2F;usr&#x2F;local&#x2F;apache-tomcat   &#x2F;usr&#x2F;tomcat   将 &#x2F;usr&#x2F;local&#x2F;apache-tomcat  移动到 &#x2F;usr&#x2F; 下 且重命名为apache-tomcat</p><h2 id="linux下面各色文件文件夹的意思"><a href="#linux下面各色文件文件夹的意思" class="headerlink" title="linux下面各色文件文件夹的意思"></a>linux下面各色文件文件夹的意思</h2><p>  linux上红色背景   白色字的  还一闪一闪是什么意思啊？</p><p>  linux上红色背景 白色字 表示是错误文件或权限过高的文件或者危险文件</p><p>  eg:&#x2F;usr&#x2F;bin&#x2F;passwd  表示权限过高的文件或者危险文件。</p><p>  linux下面红色文件的意思是表示已经断开的链接。</p><p>  文件       白色    没有执行权限</p><p>  文件       绿色    有执行权限</p><p>  文件夹   蓝色</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位体系和媒体查询</title>
    <link href="/2020/10/10/Position-And-media/"/>
    <url>/2020/10/10/Position-And-media/</url>
    
    <content type="html"><![CDATA[<h2 id="position定位与meida媒体查询"><a href="#position定位与meida媒体查询" class="headerlink" title="position定位与meida媒体查询"></a>position定位与meida媒体查询</h2><h3 id="三种定位体系"><a href="#三种定位体系" class="headerlink" title="三种定位体系"></a>三种定位体系</h3><p>影响框( box )布局因素之一，便是定位体系。定位体系也是其最为重要的影响因素。<br>CSS2.1 中，一个框可以根据三种定位体系布局。CSS2.1 中的定位体系帮助作者使他们的文档更容易理解，并不需要使用标记的手段（如，不可见的图片）达到布局的效果。</p><h4 id="常规流-Normal-flow"><a href="#常规流-Normal-flow" class="headerlink" title="常规流( Normal flow )"></a>常规流( Normal flow )</h4><p>常规流，是对 “normal flow” 的直译。<br>之所以称之为常规流，是因为这是相对于后面的浮动和绝对定位的一个概念，浮动和绝对定位元素都脱离了当前的常规流。</p><p>在 CSS2.1中，常规流包括块框( block boxes )的块格式化( block formatting )， 行内框( inline boxes )的行内格式化( inline formatting )，块框或行内框的相对定位，以及插入框的定位。</p><h4 id="浮动-Floats"><a href="#浮动-Floats" class="headerlink" title="浮动( Floats )"></a>浮动( Floats )</h4><p>浮动，顾名思义，相对于常规流来讲，它漂浮在常规流的上方。<br>在浮动模型中，一个框( box )首先根据常规流布局，再将它从流中取出并尽可能地向左或向右偏移。内容可以沿浮动区的侧面排列。 因为它首先要根据常规布局后才偏移，所以效率较常规流低。<br>用 ‘float’ 特性声明浮动，特性值可以是：”none”、”left”、”right”。</p><h4 id="绝对定位-Absolute-positioning"><a href="#绝对定位-Absolute-positioning" class="headerlink" title="绝对定位 ( Absolute positioning)"></a>绝对定位 ( Absolute positioning)</h4><p>在绝对定位模型中，一个框整个地从常规流中脱离（它对后续的兄弟元素没有影响），并根据它的包含块来分配其位置。</p><ul><li>static</li></ul><p> 该框是一个常规框，布局根据常规流。’left’ 、’right’、’bottom’ 和 ‘top’ 属性不适用。</p><ul><li>relative</li></ul><p> 框的位置根据常规流计算（被称为常规流中的位置）。然后框相对于它的常规位置而偏移。既然还属于常规流中，那它后面的兄弟是不受影响，后面的兄弟不会上前占位。</p><ul><li>absolute</li></ul><p> 框的位置（可能还有它的尺寸）是由’left’，’right’，’top’和’bottom’特性决定。这些特性指定了框相对于它包含块的偏移量。 绝对定位的框从常规流向中脱离。这意味着它们对其后的兄弟元素的会向前占位。另外，尽管绝对定位框有外边距(margin)， 它们不会和其它任何外边距发生折叠（Collapsing margins）。</p><ul><li>fixed</li></ul><p> 框位置的计算根据 ‘absolute’ 模型，不过框要额外地根据一些参考而得到固定。跟绝对定位一样，固定定位元素的外边距不会和任何其他外边距发生折叠。 应用于手持终端、投影设备、屏幕、TTY、电视媒体类型时，框相对于可视窗口固定，滚动时不移动。应用于打印媒介类型时，框被渲染于每一页， 并相对于页框固定，就好象是通过可视窗口查看该页一样（例如，打印预览）。对于其他的媒介类型，表现没有被定义。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>absolute和fixed优先级最高，有它存在时，浮动起不了作用。</p></li><li><p>如果display的值是none，那么position和float不起作用，在这种情况下，元素不产生框，因此浮动和定位无效。</p></li><li><p>Position的值是absolution或fixed</p></li></ol><p> 如果position的值是absolution或fixed，框就是绝对定位的，框的位置将由top、right、bottom和left属性和该框的包含确定。</p><ol start="4"><li>‘float’ 的值不是 “none”<br> 如果 ‘float’ 的值不是 “none”，该框浮动并且 ‘display’ 会被按照转换对应表设置。</li></ol><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>@media规则在css2中就有介绍，针对不同媒体颗星可以定制不同的样式规则。例如：你可针对不同的媒体类型(包括显示器、便携设备、电视机等等)设置不同的样式规则。但这些多媒体类型在很多设备上支持还不够友好</p><p> CSS3多媒体查询根据设置自适应显示。媒体查询可用于检测很多事情，例如：</p><p> viweport(视窗)的宽度与高度</p><p> 设备的高度与宽度</p><p> 朝向(智能手机横屏与竖屏)</p><p> 分辨率</p><h4 id="常见的媒体查询"><a href="#常见的媒体查询" class="headerlink" title="常见的媒体查询"></a>常见的媒体查询</h4><p> &#x2F;<em>大屏幕</em>&#x2F;<br> @media screen and (min-width: 1200px) {<br>     body {<br>         background-color: brown;<br>     }<br> }<br> &#x2F;<em>平板电脑与小屏电脑之间的分辨率</em>&#x2F;<br> @media screen and (min-width: 768px) and (max-width:979px) {<br>     body {<br>         background-color: blue;<br>     }<br> }<br> &#x2F;<em>横向放置的手机和竖向放置的平板之间的分辨率</em>&#x2F;<br> @media screen and (max-width:767px) {<br>     body {<br>         background-color: blueviolet;<br>     }<br> }</p><p> &#x2F;<em>竖向放置的手机以及分别率</em>&#x2F;<br> @media screen and (max-width: 480px) {<br>     body {<br>         background-color: black;<br>     }<br> }</p><p>媒体查询，使用方法，不需要所有元素的在同一屏幕的情况写在一起，可以有多个css媒体查询</p>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片上传功能</title>
    <link href="/2020/08/10/java-upload-img/"/>
    <url>/2020/08/10/java-upload-img/</url>
    
    <content type="html"><![CDATA[<h1 id="图片上传功能"><a href="#图片上传功能" class="headerlink" title="图片上传功能"></a>图片上传功能</h1><p>最近在项目开发过程中出现了一个问题，一个表单中途改了需求，要求能进行上传附件（格式是PDF或者图片）</p><p>前台代码如下，</p> <form id="supplierForm" action="">  <div class="row form-div">   <p class="col-lg-12 col-md-12 col-sm-12 col-xs-12 form-title">附件信息</p>   <div class="col-lg-6 col-md-6 col-sm-6 col-xs-12 form-group">   <label for="business-licence">公司简介(营业执照/税务登记证/资质文件等)<span class="require">*</span></label>   <div class="upload" id="upload1">    <input class="file-input" type="file" id="business" onchange="handleBusiness()" >    <input id="businesslicence" type="text"  value="" class="form-control" readonly="readonly">    <a id="businessBtn" href="javascript:void(0);"     class="btn btn-info" onclick="uploadBusiness()">上传</a>   </div>  </div> </form> <!-- 图片的表单   --> <form id="uploadForm" method="post" enctype="multipart/form-data"  target="hiddenIframe" style="display: none; width: 0px; height: 0px;">  <span id="fileContent"></span>  <input type="submit" onclick="uploadFormSubmit()"> </form><p>js代码</p><p> var businessFile &#x3D; $(“#business”);<br> var businesslicence &#x3D; $(“#businesslicence”);<br> function handleBusiness() {<br>  var of &#x3D; $(“#business”);<br>  &#x2F;&#x2F;修改属性<br>  of.attr(“id”, “uploadFile”);<br>  of.attr(“name”, “uploadFile”);<br>  $(“#fileContent”).empty();&#x2F;&#x2F;清空表单<br>  $(“#fileContent”).append(of);&#x2F;&#x2F;选中元素之后放入表单<br>  &#x2F;&#x2F;将文件移动至上传表单<br>  var file &#x3D; $(“#uploadFile”).val();<br>  function uploadFormSubmit(){<br>    var options &#x3D; {<br>      type : ‘POST’,<br>      url : “${base}&#x2F;uploaderSupplier.jspx”,<br>      complete : function(data) {<br>       $(“#businessPath”).val(data.responseJSON.fileName);<br>       of.attr(“id”, “business”);<br>       $(“#upload1”).append(of);<br>       layer.msg(“简介文件上传成功!”);<br>      }<br>     }<br>     $(“#uploadForm”).ajaxSubmit(options);<br>   }<br>   if(document.getElementById(“uploadFile”).files){<br>    var fileData &#x3D; document.getElementById(“uploadFile”).files[0];<br>   }</p><p>   var ext &#x3D; file.substring(file.lastIndexOf(‘.’), file.length).toUpperCase();<br>   if (ext &#x3D;&#x3D; ‘.PNG’ || ext &#x3D;&#x3D; ‘.JPG’ || ext &#x3D;&#x3D; ‘.JPEG’ || ext &#x3D;&#x3D; ‘.GIF’ || ext &#x3D;&#x3D; ‘.PDF’) {<br>    if (fileData.size &lt;&#x3D; 4 <em>1024</em> 1024) {<br>     businesslicence.val(businessFile.val());<br>     uploadFormSubmit();<br>    } else {<br>     layer.msg(“文件最大不能超过4M!”);<br>     $(“#businesslicence”).val(“”);<br>     of.attr(“id”, “business”);<br>     $(“#upload1”).append(of);<br>    }<br>   } else {<br>    layer.msg(“只能上传图片和PDF文件”);<br>    $(“#businesslicence”).val(“”);<br>    of.attr(“id”, “business”);</p><pre><code class="hljs">$(&quot;#upload1&quot;).append(of);return;</code></pre><p>   }<br>  };<br>  &#x2F;&#x2F;  点击上传按钮触发文件选择框<br>  function uploadBusiness() {<br>   businessFile.click();<br>  };</p><p>java后台代码:</p><p> &#x2F;**<br>     * <p>功能简述:图片上传接口</p><br>     * <p>细节描述:返回图片的保存路径，图片名前拼接日期</p><br>     * @param request<br>     * @param response<br>     * @param model [参数说明]<br>     * @author minchao<br>     * @since [2022年6月30日]<br>     *&#x2F;<br>    @RequestMapping(value &#x3D; “&#x2F;uploaderSupplier.jspx”, method &#x3D; RequestMethod.POST)<br>    public void uploaderSupplier(HttpServletRequest request, HttpServletResponse response,ModelMap model) {</p><pre><code class="hljs">    response.setCharacterEncoding(&quot;UTF-8&quot;);      response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);      response.setDateHeader(&quot;Expires&quot;, 0);        String fileName = &quot;&quot;;    String filePath = &quot;&quot;;     // 转型为MultipartHttpRequest：       MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;       // 获得文件：      MultipartFile filedata = multipartRequest.getFile(&quot;uploadFile&quot;);       System.out.print(filedata);    if (filedata != null &amp;&amp; !filedata.isEmpty()) &#123;          // 获取图片的文件名         fileName = filedata.getOriginalFilename();         // 将图片上传到服务器         filePath=saveFile(request, fileName, filedata);           // System.out.println(&quot;上传文件 &quot;+filePath+&quot;成功&quot;);      &#125;      System.out.println(request);    JSONObject json = new JSONObject();    json.put(&quot;success&quot;, true);    json.put(&quot;status&quot;, 1);    json.put(&quot;fileName&quot;, filePath);    ResponseUtils.renderJson(response, json.toString());&#125;/** * &lt;p&gt;功能简述:保存文件方法&lt;/p&gt; * &lt;p&gt;细节描述&lt;/p&gt; * @param request * @param newFileName * @param filedata * @return [参数说明] * @author minchao * @since [2022年6月30日] */@Autowiredprivate KdSupplierMng kdSupplierMng;public String saveFile(HttpServletRequest request, String newFileName,          MultipartFile filedata) &#123;      String path = request.getSession().getServletContext().getRealPath(&quot;/r/cms/www/supAttachment/&quot;);    String saveFilePath = path;         Date d = new Date();     SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);    String dateNowStr = sdf.format(d);     String ext =  newFileName.substring(newFileName.lastIndexOf(&quot;.&quot;));    newFileName = dateNowStr + ext;    //System.out.println(&quot;文件名：&quot; + newFileName);     // 构建文件目录      File tempFile = new File(saveFilePath);      if (!tempFile.exists()) &#123;          tempFile.mkdirs();      &#125;      // 保存文件到服务器      FileOutputStream fos;      try &#123;          fos = new FileOutputStream(saveFilePath + &quot;\\&quot; + newFileName);          fos.write(filedata.getBytes());          fos.close();      &#125;catch (Exception e) &#123;          e.printStackTrace();      &#125;      return &quot;/r/cms/www/supAttachment/&quot;+newFileName;  &#125; </code></pre><p>接口返回的存放图片的名称。</p><p>实现图片上传的方法是，新写一个表单，专门用来上传图片。由上传按钮来触发文件框的弹出选择文件窗口，接着，再由文件框的onchange()方法触发新表单的ajax上传文件功能。</p><p>注意，如果直接粘贴复制代码的话，需要导入jquery.form.js和layer.js文件。</p><h3 id="当然，事情并不会就这样结束"><a href="#当然，事情并不会就这样结束" class="headerlink" title="当然，事情并不会就这样结束"></a>当然，事情并不会就这样结束</h3><p>ie9 有两个坑：</p><p>第一个坑:<br>getElementById(“uploadFile”).files[0]会报错，因为ie9是无法读取浏览器之外的本地文件的。</p><p>解决方法是：在var fileData &#x3D; document.getElementById(“uploadFile”).files[0];&#x2F;&#x2F;获取文件和var ext &#x3D; file.substring(file.lastIndexOf(‘.’), file.length).toUpperCase();&#x2F;&#x2F;判断尾缀z之间加一段判断代码</p><p> if(document.getElementById(“uploadFile”).files){<br>  var fileData &#x3D; document.getElementById(“uploadFile”).files[0];<br> }else{<br>   var fileEle &#x3D; document.getElementById(“uploadFile”);<br>   var fileData &#x3D; null;<br>   &#x2F;*<br>        低版本IE由于JS安全问题，不允许JS访问本地文件,所以无法获取files, 对于低版本的IE可以使用ActiveXObject获取文件对象, 但是默认情况下<br>        ActiveXObject为不可用的, 所以要想使用此对象要先启用设置, 即:  Tools(工具) &#x2F; Internet options(选项) &#x2F; Security(安全) &#x2F; Custom level(自定义级别)<br>        找到”Initialize and script ActiveX controls not marked as safe for scripting”设置为”Enable(not secure)”即可.<br>        初始化和脚本化ActiveX控件，标记为脚本安全<br>        *&#x2F;<br>    var fso &#x3D; new ActiveXObject(“Scripting.FileSystemObject”);</p><pre><code class="hljs">/*    1. 获取文件路径        出于安全性的考虑，低版本IE上传文件时屏蔽了真实的本地文件路径,        以C:\fakepath\**取而代之, 所以默认情况下通过fileEle.value 不能获取到        文件的真实路径.        如果想获取真实路径, 有两种方式:            1. 通过设置IE的安全设置, 即:                Tools(工具) / Internet options(选项) / Security(安全) / Custom level(自定义级别)                找到&quot;Include local directory path when uploading files to a server&quot;                设置为的&quot;Enable&quot;            2. 使用JS获取, 即:                fileEle.select().blur();                var filePath = document.selection.createRange().text;*/fileEle.select();fileEle.blur();var filePath = $(&quot;#uploadFile&quot;).val();    /*        FileExists:  判断 文件是否存在        GetFile: 获取文件对象    */    if(fso.FileExists(filePath))&#123;     fileData = fso.GetFile(filePath);    &#125;</code></pre><p> }<br> console.log(fileData);</p><p>其中还要用户配合打开ie浏览器的安全限制</p><p>第二个坑:由于IE9的安全限制，会导致按钮触发文件选择框的时候会报错。JAVASCRIPT5的错误。</p><p>ie10以下有这个问题，为了安全性能考虑，只允许点击file文本的时候才可以上传，因此，需要设置一个透明的 &lt;  input type&#x3D;”file”&gt;浮动到自定义按钮上，设置透明度为0，即可解决此问题</p><p>这个的解决办法是将input文件框透明置顶，当点击空白处时自动触发文件选择。但这与需求相违背了。JIRA上测试始终给我报了个错，说是用户常用习惯不符，触发文件选择框都是由点击上传按钮开始触发。因此，就只能放大招将IE9屏蔽了。</p><p>综上所述。</p><p>后期如果我找到了好的上传插件，并且兼容IE9的。会后续补充在博客里。<br>如果您有好的上传插件或者更好的解决办法。希望您能在评论里留言告知，方便我学习。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML, CSS基础及编码规范</title>
    <link href="/2020/06/20/HTML-and-CSS-Base/"/>
    <url>/2020/06/20/HTML-and-CSS-Base/</url>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>想要完成一个精美实用的网站，拥有稳定的后台，健壮的数据库设计，同样需要漂亮的设计以及精美的html和css实现，作为一个前端来说，需要突破这些限制因素的局限，能完美的呈现出精美的页面给用户看，并且给用一个完美的用户体验，这是前端要做的事。</p><h2 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h2><h3 id="只有对HTML元素非常熟悉，才能知道何时应该选用何种标签"><a href="#只有对HTML元素非常熟悉，才能知道何时应该选用何种标签" class="headerlink" title="只有对HTML元素非常熟悉，才能知道何时应该选用何种标签"></a>只有对HTML元素非常熟悉，才能知道何时应该选用何种标签</h3><ol><li>创建良好的标记</li></ol><p> 1.1 选择DOCTYPE  </p><p> 在HTML的最开始部分声明DOCTYPE(Document Type(文档类型)的简写)可以让浏览器找到<br>  或者其他用户代理知道你要使用的HTML语言类型。DOCTYPE是一个健壮文档所必须的<br>  <!DOCTYPE html ></p><p> 1.2 指定语言和字符集</p><p> 与声明DOCTYPE同样重要的是将HTML文档指定为某一种人类的语言。<br>  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"><br> &#x2F;&#x2F;设置文档的XML语言，这里设置为英语的ISO代码en<br> <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><br>  &#x2F;&#x2F;设置文档的字符集，这里是UTF-8</p><p> 1.3 指定标题<br> 每个HTML页面都需要一个用来描述网页内容的<title>元素,在游客将访问的页面<br>  保存到收藏夹时，<title>将作为链接名被保存在访客浏览器中</p><p> 1.4 选用恰当的元素</p><p> 根据文档内容的结构而选择HTML元素，而不是根据HTML元素的样式。例如，<br>  用p元素包含文字段落，而不是为了换行；用blockquote包含被引用的文字，<br>  而不是为了得到缩进</p><p> 1.5 避免过渡使用div和span</p><p> 设计HTML时一个常见的错误就是过渡使用div和span。少量、必要的合理使用<br> 可以明显地增强文档的结构性。span不应该代替label的作用，这不意味着div<br> 和span应避免使用。</p><p> 1.6尽可能少地使用标签</p><p> 前面两个提示所隐藏的含义就是，HTML标签使用得越少越好。事实上也是如此,使用的HTML标签越多，则渲染的时候dom结构越复杂，dom渲染的时候会慢。</p><h3 id="HTML编码规范"><a href="#HTML编码规范" class="headerlink" title="HTML编码规范"></a>HTML编码规范</h3> <!DOCTYPE html><p>–HTML5 doctype为每个 HTML 页面的第一行添加标准模式（standard mode）的声明，这样能够确保在每个浏览器中拥有一致的展现。</p> <html lang="zh-CN">-- 强烈建议为 html 根元素指定 lang 属性，从而为文档设置正确的语言。这将有助于语音合成工具确定其所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。 <head> <title></title> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <!-- IE 支持通过特定的 <meta> 标签来确定绘制当前页面所应该采用的 IE 版本。    除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。 --> <meta charset="utf-8"> <!-- 通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。    这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），    从而全部与文档编码一致（一般采用 UTF-8 编码）。 --> <!-- 外部引入 CSS --> <link rel="stylesheet" href="code-guide.css"> <!-- 外部引入 JavaScript --> <script src="code-guide.js"></script> </head><p>标签要闭合，所有的html标签都要有&#x2F;的闭合标签</p> <body> <!--             class        id, name        data-*        src, for, type, href        title, alt        aria-*, role    --> <!-- class 用于标识高度可复用组件，因此应该排在首位。    id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。 --> </body> </html><h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="CSS部分，基础内容详见《CSS夯实基础》"><a href="#CSS部分，基础内容详见《CSS夯实基础》" class="headerlink" title="CSS部分，基础内容详见《CSS夯实基础》"></a>CSS部分，基础内容详见<a href="http://minchao.me/2015/05/18/CSS-Base/">《CSS夯实基础》</a></h3><h3 id="CSS编码规范"><a href="#CSS编码规范" class="headerlink" title="CSS编码规范"></a>CSS编码规范</h3><p>  &#x2F;*<br>     1、用两个空格来代替制表符（tab） – 这是唯一能保证在所有环境下获得一致展现的方法。<br>     2、为选择器分组时，将单独的选择器单独放在一行。<br>     3、为了代码的易读性，在每个声明块的左花括号前添加一个空格。<br>     4、声明块的右花括号应当单独成行。<br>     5、每条声明语句的 : 后应该插入一个空格。<br>     6、为了获得更准确的错误报告，每条声明都应该独占一行。<br>     7、所有声明语句都应当以分号结尾。最后一条声明语句后面的分号是可选的，但是，如果省略这个分号，你的代码可能更易出错。<br>     8、对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，box-shadow）。<br>     9、不要在 rgb()、rgba()、hsl()、hsla() 或 rect() 值的内部的逗号后面插入空格。<br>         这样利于从多个属性值（既加逗号也加空格）中区分多个颜色值（只加逗号，不加空格）。<br>     10、对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，.5 代替 0.5；-.5px 代替 -0.5px）。<br>     11、十六进制值应该全部小写，例如，#fff。在扫描文档时，小写字符易于分辨，因为他们的形式更易于区分。<br>     12、尽量使用简写形式的十六进制值，例如，用 #fff 代替 #ffffff。<br>     13、为选择器中的属性添加双引号，例如，input[type&#x3D;”text”]。只有在某些情况下是可选的，但是，为了代码的一致性，建议都加上双引号。<br>     14、避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;。<br>  *&#x2F;</p><p>以上是CSS的编码规范总结，参照以上标准</p><p> &#x2F;<em>不好的写法 CSS</em>&#x2F;<br> .selector, .selector-secondary, .selector[type&#x3D;text] {<br>   padding:15px;<br>   margin:0px 0px 15px;<br>   background-color:rgba(0, 0, 0, 0.5);<br>   box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF<br> }</p><p> &#x2F;<em>好的写法 CSS</em>&#x2F;<br> .selector,<br> .selector-secondary,<br> .selector[type&#x3D;”text”] {<br>   padding: 15px;<br>   margin-bottom: 15px;<br>   background-color: rgba(0,0,0,.5);<br>   box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;<br> }</p><p>比较这两种写法，你会发现，下面一种更清晰，单独的选择器单独放在一行，左括号前加一个空格，属性：前加一个空格，0值不设单位等</p><p>下面，相关属性的声明，也有相关的顺序</p><p> &#x2F;*声明顺序<br> 相关的属性声明应当归为一组，并按照下面的顺序排列：<br>    Positioning 定位属性声明（布局）<br>    Box model 盒子模型属性声明（大小，间距）<br>    Typographic  字排版属性（font大小）<br>    Visual  视属性（可见的颜色，背景等）<br> 由于定位（positioning）可以从正常的文档流中移除元素，<br> 并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。<br> 其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。<br> *&#x2F;</p><p> .declaration-order {<br>   &#x2F;<em>Positioning</em>&#x2F;<br>   position: absolute;<br>   top: 0;<br>   right: 0;<br>   bottom: 0;<br>   left: 0;<br>   z-index: 100;</p><p>   &#x2F;<em>Box-model</em>&#x2F;<br>   display: block;<br>   float: right;<br>   width: 100px;<br>   height: 100px;</p><p>   &#x2F;<em>Typography</em>&#x2F;<br>   font: normal 13px “Helvetica Neue”, sans-serif;<br>   line-height: 1.5;<br>   color: #333;<br>   text-align: center;</p><p>   &#x2F;<em>Visual</em>&#x2F;<br>   background-color: #f5f5f5;<br>   border: 1px solid #e5e5e5;<br>   border-radius: 3px;</p><p>   &#x2F;<em>Misc</em>&#x2F;<br>   opacity: 1;<br> }</p><p>切记不要轻易使用!important</p><p> &#x2F;*不要使用 @import<br>    与 <link> 标签相比，@import 指令要慢很多，不光增加了额外的请求次数，<br>    还会导致不可预料的问题。替代办法有以下几种：</p><pre><code class="hljs">使用多个 &lt;link&gt; 元素通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能请参考 Steve Souders 的文章了解更多知识。</code></pre><p> *&#x2F;</p><p>导入文件使用link，不使用import</p><p> &#x2F;<em><!-- Use link elements --></em>&#x2F;<br> <link rel="stylesheet" href="core.css"></link></p><p> &#x2F;<em><!-- 避免 @imports --></em>&#x2F;<br> <style><br>   @import url(“more.css”);<br> </style></p><p>媒体查询（Media query）的位置</p><p> &#x2F;*<br>    将媒体查询放在尽可能相关规则的附近。不要将他们打包放在<br>    一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。下面给出一个典型的实例<br> *&#x2F;</p><p>带前缀的属性</p><p> &#x2F;*<br>   当使用特定厂商的带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑<br> *&#x2F;</p><p>单行规则声明</p><p> &#x2F;*</p><pre><code class="hljs">对于只包含一条声明的样式，为了易读性和便于快速编辑，建议将语句放在同一行。对于带有多条声明的样式，还是应当将声明分为多行。这样做的关键因素是为了错误检测 -- 例如，CSS 校验器指出在 183 行有语法错误。如果是单行单条声明，你就不会忽略这个错误；如果是单行多条声明的话，你就要仔细分析避免漏掉错误了</code></pre><p> *&#x2F;</p><p>简写形式的属性声明</p><p> &#x2F;*<br> 在需要显示地设置所有值的情况下，应当尽量限制使用简写形式的属性声明。常见的滥用简写属性声明的情况如下：<br>     padding<br>     margin<br>     font<br>     background<br>     border<br>     border-radius<br>    大部分情况下，我们不需要为简写形式的属性声明指定所有值。例如，<br>    HTML 的 heading 元素只需要设置上、下边距（margin）的值，因此，<br>    在必要的时候，只需覆盖这两个值就可以。过度使用简写形式的属性声明会导致代码混乱，<br>    并且会对属性值带来不必要的覆盖从而引起意外的副作用。</p><pre><code class="hljs">MDN（Mozilla Developer Network）上一片非常好的关于shorthand properties 的文章，对于不太熟悉简写属性声明及其行为的用户很有用。</code></pre><p> *&#x2F;<br>好的写法与不好的写法</p><p> &#x2F;<em>不好的写法</em>&#x2F;<br> .element {<br>   margin: 0 0 10px;<br>   background: red;<br>   background: url(“image.jpg”);<br>   border-radius: 3px 3px 0 0;<br> }</p><p> &#x2F;<em>好的写法</em>&#x2F;<br> .element {<br>   margin-bottom: 10px;<br>   background-color: red;<br>   background-image: url(“image.jpg”);<br>   border-top-left-radius: 3px;<br>   border-top-right-radius: 3px;<br> }</p><p>class 命名</p><p> &#x2F;*<br>    class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。<br>        破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。<br>    避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。<br>    class 名称应当尽可能短，并且意义明确。<br>    使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。<br>    基于最近的父 class 或基本（base） class 作为新 class 的前缀。<br>    使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。</p><pre><code class="hljs">在为 Sass 和 Less 变量命名是也可以参考上面列出的各项规范。</code></pre><p> *&#x2F;</p><p>选择器</p><p> &#x2F;*<br>     对于通用元素使用 class ，这样利于渲染性能的优化。<br>     对于经常出现的组件，避免使用属性选择器（例如，[class^&#x3D;”…”]）。浏览器的性能会受到这些因素的影响。<br>     选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。<br>     只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）<br>     （例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。<br> *&#x2F;</p><p>总结：<br> 这里对于常见的编写规范错误，我一般会犯的是编写css过于随意，不喜欢用缩写，对于class的命名总是用驼峰命名，希望在将来的工作学习中改掉这些坏毛病。</p>]]></content>
    
    
    <categories>
      
      <category>HTML5 CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5 CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS3的过渡和动画比较</title>
    <link href="/2020/06/20/CSS3-stransition-and-animation/"/>
    <url>/2020/06/20/CSS3-stransition-and-animation/</url>
    
    <content type="html"><![CDATA[<h2 id="CSS3的过渡和动画"><a href="#CSS3的过渡和动画" class="headerlink" title="CSS3的过渡和动画"></a>CSS3的过渡和动画</h2><p>CSS3的精彩之处(不，整个前端精彩之处)就在于它的CSS动画效果，当然牛皮吹的有点过了，前端的动画实现方式还有JavaScript动画，和Flash动画，当然这些技术都是可以穿插使用，主要的动画展现方式有CSS动画和js动画两种。而这里，CSS的动画包括Transition和Animation两个部分，话不多说,让我们开始吧。</p><h2 id="CSS3的过渡-transition"><a href="#CSS3的过渡-transition" class="headerlink" title="CSS3的过渡 -transition"></a>CSS3的过渡 -transition</h2><h3 id="什么是CSS过渡"><a href="#什么是CSS过渡" class="headerlink" title="什么是CSS过渡"></a>什么是CSS过渡</h3><p>CSS有一个属性叫transition，它叫做过渡属性。它允许CSS元素的值在一定的时间区间内实现平滑的过渡。<br>意思是说，这个属性可以控制元素的属性从一个样式到另外一个样式。</p><p>正因为如此，我们可以在不使用Flash动画或者JavaScript动画的情况下，实现元素从一个样式到另一个样式的过渡效果。</p><p>这种效果可以在鼠标hover、获取焦点、被点击或者对元素任何改变中触发。并圆滑地以动画效果来改变CSS属性值。下面我们来讨论一下</p><h3 id="CSS过渡的语法"><a href="#CSS过渡的语法" class="headerlink" title="CSS过渡的语法"></a>CSS过渡的语法</h3><p>transition 属性主要包含四个属性值：</p><p>transition-property – 规定应用过渡的 CSS 属性的名称；</p><p>transition-duration – 定义过渡效果花费的时间，默认是 0；</p><p>transition-timing-function – 规定过渡效果的时间曲线。默认是 “ease”；</p><p>transition-delay – 规定过渡效果何时开始，默认是 0。</p><p>transition – 简写属性，用于在一个属性中设置四个过渡属性。</p><p>如需向多个样式添加过渡效果，请添加多个属性，由逗号隔开。</p><h3 id="transition的例子"><a href="#transition的例子" class="headerlink" title="transition的例子"></a>transition的例子</h3><p>CSS部分</p> <style> div {    width: 100px;    height: 100px;    background: red; -webkit-transition: width 2s ease, height 2s ease, -webkit-transform 2s ease;    transition: width 2s ease-in-out, height 2s ease-in-out, transform 2s ease-in-out; } div:hover {    width: 200px;    height: 200px; -webkit-transform: rotate(360deg);    transform: rotate(360deg); } </style><p>HTML部分</p> <div>鼠标移动到 div 元素上，查看过渡效果。</div><h3 id="transition的优点"><a href="#transition的优点" class="headerlink" title="transition的优点"></a>transition的优点</h3><p>transition的优点在于简单易用，但是它有几个很大的局限。</p><p>（1）transition需要事件触发，所以没法在网页加载时自动发生。</p><p>（2）transition是一次性的，不能重复发生，除非一再触发。</p><p>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p><p>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</p><h2 id="CSS3的动画-animation"><a href="#CSS3的动画-animation" class="headerlink" title="CSS3的动画 -animation"></a>CSS3的动画 -animation</h2><p>单纯的代码不会触发任何过渡操作，需要通过用户的行为（如点击，悬浮等）触发，可触发的方式有：<br>:hoever :focus :checked 媒体查询触发 JavaScript触发</p><h3 id="什么是CSS动画-animation"><a href="#什么是CSS动画-animation" class="headerlink" title="什么是CSS动画-animation"></a>什么是CSS动画-animation</h3><p>CSS Animation就是为了解决transition的局限性而提出的。</p><p>CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。ainimation实现动画效果主要由两部分组成：</p><p>1）通过类似Flash动画中的帧来声明一个动画；</p><p>2）在animation属性中调用关键帧声明的动画。</p><h3 id="CSS动画的属性"><a href="#CSS动画的属性" class="headerlink" title="CSS动画的属性"></a>CSS动画的属性</h3><ol><li>属性: animation-name</li></ol><p> 描述：用来指定关键帧动画的名字,name为默认值</p><ol start="2"><li>属性:animation-duration</li></ol><p> 描述:用于指定动画所需要的时间，一般以秒为单位,默认值为0,没有动画</p><ol start="3"><li>属性:animation-timing-function</li></ol><p> 描述:设置动画的播放方式</p><ol start="4"><li>属性:animation-delay</li></ol><p> 描述:在开始执行动画时需要等待的时间</p><ol start="5"><li>属性:animation-iteration-count</li></ol><p> 描述：定义动画的播放次数，默认为1，如果为infinite，则无限次循环播放</p><ol start="6"><li>属性:animation-direction</li></ol><p> 描述：默认为nomal，每次循环都是向前播放，（0-100），另一个值为alternate，动画播放为偶数次则向前播放，如果为基数词就反方向播放</p><ol start="7"><li>属性:animation-state</li></ol><p> 描述：默认为running，播放，paused，暂停</p><ol start="8"><li>属性:animation-fill-mode</li></ol><p> 描述：定义动画开始之前和结束之后发生的操作，默认值为none，动画结束时回到动画没开始时的状态；forwards，动画结束后继续应用最后关键帧的位置，即保存在结束状态；backwards，让动画回到第一帧的状态；both：轮流应用forwards和backwards规则。</p><h3 id="css动画的例子"><a href="#css动画的例子" class="headerlink" title="css动画的例子"></a>css动画的例子</h3><p>css部分</p> <style> /*申明动画帧*/ @-webkit-keyframes cricle {     0%{         top:0;        left:0;         background:red;     }     25%{        left:200px;         top:0;         background: #000;     }     50%{         top:200px; left:200px;         background: blue;     }     75%{         top:200px; left:0;         background: yellow;     }     100%{       left:0px;       top:0px;       background: red;     } } @keyframes cricle {     0%{         top:0;        left:0;         background:red;     }     25%{        left:200px;         top:0;         background: #000;     }     50%{         top:200px; left:200px;         background: blue;     }     75%{         top:200px; left:0;         background: yellow;     }     100%{       left:0px;       top:0px;       background: red;     } } /*直来直回动画帧*/ @webkit-keyframes straight{     0%{         left:0;         background: #000;     }     25%{         left: 400px;         background: yellow;     }     50%{         left: 800px;         background: #000;     }     75%{         left: 400px;         background: red;     }     100%{         left: 0;         background: #000;     } } @keyframes straight{     0%{         left:0;         background: #000;     }     25%{         left: 400px;         background: yellow;     }     50%{         left: 800px;         background: #000;     }     75%{         left: 400px;         background: red;     }     100%{         left: 0;         background: #000;     } } .box{width:100px;height:100px;     background: red;     position:relative;     /*动画*/  /*指定动画的名字 straight  cricle*/     -webkit-animation-name:cricle;             animation-name:cricle;  /*指定动画时长*/     -webkit-animation-duration:5s;             animation-duration:5s;     /*动画播放方式 linear ease ease-in  ease-out ease-in-out  cubic-bezier(n,n,n,n) steps(n,start)*/     -webkit-animation-timing-function:steps(5,start);             animation-timing-function:steps(5,start);  /*指定动画开始时间以秒为单位*/     -webkit-animation-delay:1s;             animation-delay:1s;     /*指定动画播放的循环次数  infinite 无限循环*/     -webkit-animation-iteration-count:infinite;             animation-iteration-count:infinite;     /*控制动画的播放方向 normal 默认正常播放 reverse动画方向播放 alternate奇数正偶反 alternate-reverse 奇反偶正*/     -webkit-animation-direction:reverse;             animation-direction:reverse;     /*设置动画播放的状态，暂停还是播放  paused  running*/     -webkit-animation-palay-state:running;             animation-palay-state:running;     /*设置动画时间外属性 none默认值 动画在执行*/     -webkit-animation-fill-mode:both;             animation-fill-mode:both;        /*设置动画时间外属性 none默认值 动画在执行之前和之后不会有任何样式到目标元素            forwards 在动画结束之后，动画将应用该属性值            backwards 动画将应用子啊animatio-delay定义期间启动动画的第一次迭代的关键帧中定义的属性值            both 动画遵循forward和backwards的规则，也就是说，动画会在两个方向上扩展动画属性        */   -webkit-animation: straight 5s ease-out 2s infinite reverse backwards;             animation: straight 5s ease-out 2s infinite reverse backwards; } </style><p>HTML部分</p>  <div id="box" class="box">    </div>    <input id="btn" type="button" onclick="pasused()" style="position:relative;left:600px;top400px;" value="暂停" ><p>JS部分</p> <script type="text/javascript"> function pasused(){     var box = document.getElementById("box");     var btn = document.getElementById("btn");     if(btn.value=="暂停"){         box.style.animationPlayState="paused";         btn.value="开始";     }else{         box.style.animationPlayState="running";         btn.value="暂停";     } } </script><p>说明,这里我定义了两个动画帧 straight  和 cricle，并且应用了不同的属性进行了测试和观察，最后，顺便写了js来控制动画的播放。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> animation属性类似于transition，他们都是随着时间改变元素的属性值，其主要区别在于：</p><ol><li><p>transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果 。</p></li><li><p>transition是面向结果的，animition是面向过程的。transition一经触发，会过渡到结果，而动画，已经触发，展示了一个过程的动态变化，过程中可以暂停也可以开始。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS基础</title>
    <link href="/2020/05/18/CSS-Base/"/>
    <url>/2020/05/18/CSS-Base/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="打好CSS布局的基础"><a href="#打好CSS布局的基础" class="headerlink" title="打好CSS布局的基础"></a>打好CSS布局的基础</h2><p>基于CSS进行设计的最主要的优势就是，只要HTML文档结构良好，那么很容易通过添加一层CSS作为修饰，让文档样式变得非常漂亮。把HTML结构看做书一样持久不变，就像把html刻在石头上一样。这样，提交代码后，尽量不要修改html结构，因为修改了html结构会使得css样式错乱。</p><h2 id="css层叠与继承"><a href="#css层叠与继承" class="headerlink" title="css层叠与继承"></a>css层叠与继承</h2><h3 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h3><p>一个元素的样式，可以通过多种方式来定义，而多种定义方式之间通过复杂的影响关系决定了元素的最终样式。这种复杂既造就了CSS的强大，也导致CSS显得如此“混乱”而难以调试。</p><p>对于层叠来说，共有三种主要的样式来源：</p><ul><li><p>浏览器对HTML定义的默认样式</p></li><li><p>用户定义的样式</p></li><li><p>开发者定义的样式，可以有三种形式：</p><ul><li>定义在外部文件(外链样式)：通过<link>引入的样式</li><li>在页面的头部定义（内部样式，也叫内联样式）：通过&lt;style&gt;定义的样式，只在本页面内生效</li><li>定义在特定元素上（内嵌样式，也叫行内样式）：这种形式多用于测试，可维护性差</li></ul></li></ul><p>注：（css层叠样式的三种优先级比较）</p><p>外链样式 &lt; 内联样式 &lt; 内嵌样式</p><p>记忆方法：就近原则(谁靠近元素最近，谁的优先级最高)</p><p>特殊情况：<br>就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。<br>如：</p> <head>     <style type="text/css">       /*内部样式*/       h3{color:green;}     </style>  <pre><code class="hljs"> &lt;!-- 外部样式 style.css --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;/&gt; &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;</code></pre> </head> <body>     <h3>测试！</h3> </body><h3 id="优先级附加（IE-中奇怪的应用–CSS的BUG）"><a href="#优先级附加（IE-中奇怪的应用–CSS的BUG）" class="headerlink" title="优先级附加（IE 中奇怪的应用–CSS的BUG）"></a>优先级附加（IE 中奇怪的应用–CSS的BUG）</h3><p>IE浏览器下载或者渲染的顺序可能如下</p><ul><li>IE下载的顺序是从上到下的</li><li>JavaScript函数的执行会阻塞IE的下载</li><li>IE渲染的顺序是同时进行的</li><li>在渲染到页面的某一部分时，其上面的所有部分都已经瞎子完成（但并不是说所有相关联的元素都已经下载完了）</li><li>解析过程中，停止页面所有往下元素的下载，样式文件比较特殊，在其下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前渲染的）重新进行样式渲染。并以此方式一直渲染下去，直到渲染页面完成</li><li>Firefox处理下载和渲染的顺序大体相同，除了iframe的渲染。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当页面一个元素被另一个元素包裹时，我们称被包裹的元素叫子元素，包裹元素叫父元素。如：</p> <p style="color:red">  这是一个<strong>测试</strong>的p标签 </p><p>当给p添加样式color为red时，此时a的颜色样式被stong继承了，当然也不是所有的css属性都会被子类继承，例如border属性。继续利用上面的一段代码。我们为p元素添加border属性</p> <p style="border:1px solid red">  这是一个<strong>测试</strong>的p标签 </p><p>执行之后会发现，只有一个框而不是测试两个字也有边框,同样css的继承也不是所有元素都能主动继承的，有的并不能直接继承父元素的css属性。当子元素不能能直接继承父元素的属性的时候，我们可以在样式中使用inherit来声明子元素的该属性继承父的子元素。</p> <p style="border:1px solid red">  这是一个<strong style="border:inherit">测试</strong>的p标签 </p><p>这时，我们会发现这个strong元素的border属性跟父元素p一样也有红色边框</p><h2 id="CSS的选择器"><a href="#CSS的选择器" class="headerlink" title="CSS的选择器"></a>CSS的选择器</h2><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><ol><li>标签选择器</li></ol><p> *{}     指定通用元素选择器，匹配任何元素</p><p>  *{margin:0 auto;padding:0 auto;}</p><p> element  标签选择器，匹配标签的元素</p><ol start="2"><li>类选择器</li></ol><p> .class   指定元素中包含该class类的元素</p><ol start="3"><li>id选择器</li></ol><p>  #id  指定元素的id值是id的元素</p><p>选择器的优先级</p><p>内嵌样式(行内样式) &gt; id选择器 &gt; Class选择器 &gt; 标签选择器</p><p>权重:1000 &gt; 100 &gt; 10 &gt; 1</p><p>解释：首先同css优先级一样内嵌（行内）是最高级别的，id选择器次之，因为html中id的定义是有且仅有一个同名id，类选择第三因为，多个元素可以拥有相同的class类名，而标签选择器排在最后是因为，元素标签是html的底层的东西，即不能单独指定某一个元素，也不能指定某一类元素。仅仅表示元素总的标签类。</p><h3 id="关系选择器（组合选择器）"><a href="#关系选择器（组合选择器）" class="headerlink" title="关系选择器（组合选择器）"></a>关系选择器（组合选择器）</h3><ol><li>E,F</li></ol><p> 多元素选择器，同时匹配所有E元素和F元素，中间用，分隔<br>2. E F</p><p> 后代选择器，匹配E元素后代元素中的F元素<br>3. E&gt;F</p><p> 子元素选择器，匹配E元素子元素中的F元素<br>4.  E+F</p><p> 组合选择器，元素B的任一下一个兄弟元素E</p><ol start="5"><li>E:first-child，E:nth-child(n)</li></ol><p> 节点选择器，E元素的直系第一个后代元素</p><ol start="6"><li>B~E</li></ol><p> 兄弟选择器，B元素后面的拥有共父元素的E元素</p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ol><li>E[att]</li></ol><p> 匹配所有att属性的E元素，不考虑它的值</p><ol start="2"><li>E[att &#x3D; val]</li></ol><p> 匹配所有att属性值等于”val”的E的元素</p><ol start="3"><li>E[att~&#x3D;val]</li></ol><p> 匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素</p><ol start="4"><li>E[att &#x3D; val]</li></ol><p> 匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以“val”开头的E元素，主要用于lang属性，比如“en”、“en-us”、“en-gb”等等</p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>什么叫伪类选择器，伪就是假装的意思，和一般的DOM中的元素不一样，它并不改变任何DOM内容。只是插入了一些装饰类的元素，这些元素对于用户来说是可见的，但对于DOM来说不可见。伪类的效果可以通过添加一个实际的类来达到。</p><p>伪类的分类有两种：</p><p>一、动态伪类;</p><p>动态伪类，因为这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来</p><p> a:link {color:gray;}&#x2F;<em>链接没有被访问时，颜色为灰色</em>&#x2F;<br> a:visited{color:yellow;}&#x2F;<em>链接被访问过后，颜色为黄色</em>&#x2F;<br> a:hover{color:green;}&#x2F;<em>鼠标悬浮在链接上时，颜色为绿色</em>&#x2F;<br> a:active{color:blue;}&#x2F;<em>鼠标点中激活链接那一下，颜色为蓝色</em>&#x2F;</p><p>对于这四个伪类的设置，有一点需要特别注意，Link–visited–hover–active顺序如果错了，可能会带来意想不到的效果。</p><p>二、状态伪类</p><ul><li>“:enabled”  可点状态</li><li>“:disabled” 不可点状态</li><li>“:checked” 勾中状态</li></ul><p>三、nth伪类选择</p><ul><li><p>:first-child   选择某个元素的第一个子元素；</p></li><li><p>:last-child   选择某个元素的最后一个子元素；</p></li><li><p>:nth-child()   选择某个元素的一个或多个特定的子元素；</p></li><li><p>:nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；</p></li><li><p>:nth-of-type()   选择指定的元素；</p></li><li><p>:nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算；</p></li><li><p>:first-of-type   选择一个上级元素下的第一个同类子元素；</p></li><li><p>:last-of-type   选择一个上级元素的最后一个同类子元素；</p></li><li><p>:only-child   选择的元素是它的父元素的唯一一个了元素；</p></li><li><p>:only-of-type   选择一个元素是它的上级元素的唯一一个相同类型的子元素；</p></li><li><p>:empty    选择的元素里面没有任何内容。（IE 6-8不支持）</p></li><li><p>：not 否定选择器，常用form表单中除去submit的input样式</p><p>input:not([type&#x3D;”submit”]){…}</p></li></ul><p>四、伪元素</p><p>对元素进行一些调整但又不能写在元素里面的</p><ul><li><p>:first-line 选择元素的第一行，用于控制第一行文本</p></li><li><p>:first-letter 选择元素的第一个字母，用于控制首字母下沉或上浮</p></li><li><p>:before 在主要元素之前插入内容，这个content配合使用，见过做多的是清除浮动</p></li><li><p>:after 在主要元素之后插入内容，这个content配合使用，见过做多的是清除浮动</p></li></ul><p>之前写过一个用befor和after给页面添加小点缀的东西</p> <div class="section-header">  <h2>页面小点缀</h2> </div> <style> .section-header h2 {     margin-top: 30px;     margin-bottom: 30px;     font-size: 45px;     font-weight: 600;     color: #313131;     font-family: "Lora", serif;     text-align: center;     text-transform: uppercase;     position: relative;     padding-bottom: 30px; }<p> &#x2F;<em>画两头的线</em>&#x2F;<br> .section-header h2:before {<br>     border-left: 50px solid #DADADA;<br>     border-right: 50px solid #DADADA;<br>     bottom: 5px;<br>     content: “”;<br>     height: 1px;<br>     left: 50%;<br>     margin-left: -70px;<br>     position: absolute;<br>     width: 40px;<br> }<br> &#x2F;<em>画菱形</em>&#x2F;<br> .section-header h2:after {<br>     background: #FF8724 none repeat scroll 0 0 padding-box content-box;<br>     border-bottom: 1px solid #DADADA;<br>     border-left: 1px solid #DADADA;<br>     bottom: -9px;<br>     content: “”;<br>     height: 22px;<br>     left: 50%;<br>     margin-left: -16px;<br>     padding: 0 0 8px 8px;<br>     position: absolute;<br>     -webkit-transform: rotate(-45deg);<br>     -ms-transform: rotate(-45deg);<br>     transform: rotate(-45deg);<br>     width: 22px;<br> }<br> </style></p><p>效果图：</p><p><img src="/!--swig%EF%BF%BC0--"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>选择器都有一个权值，权值越大越优先；</p></li><li><p>当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</p></li><li><p>创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式；</p></li><li><p>继承的CSS 样式不如后来指定的CSS 样式；</p></li><li><p>在同一组属性设置中标有“!important”规则的优先级最大；</p></li><li><p>要灵活运用好CSS的选择器的运用，很少的代码实现完美的页面展示，要勤加练习，这样才能完全掌握CSS的样式</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>CSS3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解浏览器关键渲染路径</title>
    <link href="/2020/05/18/learn-main-path/"/>
    <url>/2020/05/18/learn-main-path/</url>
    
    <content type="html"><![CDATA[<h1 id="理解关键渲染路径"><a href="#理解关键渲染路径" class="headerlink" title="理解关键渲染路径"></a>理解关键渲染路径</h1><p>当浏览器接收到服务器响应的HTML页面时，在屏幕绘制图像之前发生了许多事情，浏览器初次绘制页面的过程叫做“关键选渲染路径”</p><p>了解CRP(关键渲染路径)对于理解如何提高网站性能非常有帮助</p><h2 id="1-构建-DOM-树"><a href="#1-构建-DOM-树" class="headerlink" title="1. 构建 DOM 树"></a>1. 构建 DOM 树</h2><p>DOM（文档对象模型 Document Object Model）树是代表 HTML 页面完全解析的对象。从根元素<html>开始，为页面的每个元素&#x2F;文本创建节点。嵌套在其他元素中的元素表示为子节点，每一个节点都包含了该元素的所有属性。例如，一个&lt;a&gt;元素与它相关的节点都拥有href属性。</p> <html> <head>   <title>Understanding the Critical Rendering Path</title>   <link rel="stylesheet" href="style.css"> </head> <body>   <header>     <h1>Understanding the Critical Rendering Path</h1>   </header>   <main>     <h2>Introduction</h2>     <p>Lorem ipsum dolor sit amet</p>   </main>   <footer>     <small>Copyright 2022</small>   </footer> </body> </html>HTML 的一个好处是，它可以部分执行。在页面中，文档不需要加载完全才开始展示。然而，其它资源，CSS 和 JavaScript，会阻塞页面的渲染。<h2 id="2-构建-CSSOM-树"><a href="#2-构建-CSSOM-树" class="headerlink" title="2. 构建 CSSOM 树"></a>2. 构建 CSSOM 树</h2><p>CSSOM（CSS对象模型CSS Object Model）是代表DOM样式的对象。它的表现类似于DOM，但表示的是每个节点的关联样式，不管是显性声明还是隐性继承的，都包含其中。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Getting_started/How_CSS_works">CSSr是如何工作的</a>,浏览器在展现一个文档的时候，必须要把文档内容和响应的样式结合起来展示，这个处理过程一般分为两个阶段：</p><p>第一，浏览器先将标记语言（html标签，也有的说法叫html元素）和css转换成DOM（文档对象模型）结构。<br>第二，浏览器再把DOM内容展现出来.</p><p>DOM是一种树形结构。 每个元素和非空文本都可以看做是树形结构上的一个结点。DOM结点不再是容器，但是，它可以作为子结点的父类结点而存在。</p><p>CSS 被认为是 “渲染阻塞资源”,CSS 同时也是“脚本阻塞”。这是因为 JavaScript 文件必须等待 CSSOM 构建完才能运行</p><h2 id="3-运行-JavaScript"><a href="#3-运行-JavaScript" class="headerlink" title="3. 运行 JavaScript"></a>3. 运行 JavaScript</h2><p>JavaScript 被认为是“解析阻塞资源”。这意味着 JavaScript 会阻塞 HTML 文档的解析。</p><p>不管是内联的还是外联的，它会停止获取（如果是外联的），立即运行。这就是为什么，如果文档包含一个 JavaScript 文件时，它必须放在文档之后。</p><p>为了避免 JavaScript 阻塞解析，可以应用async属性使它异步加载。</p><h2 id="4-创建渲染树"><a href="#4-创建渲染树" class="headerlink" title="4. 创建渲染树"></a>4. 创建渲染树</h2><p>渲染树是 DOM 和 CSSOM 的结合。是代表最终渲染在页面上的内容的树。这意味着它只捕获可见内容，不包含如使用了display: none的不可见元素。</p><p>使用上文中的 DOM 和 CSSOM，创建以下的渲染树</p><h2 id="5-布局"><a href="#5-布局" class="headerlink" title="5. 布局"></a>5. 布局</h2><p>布局决定了视窗的大小，CSS 样式取决于它提供的上下文，如百分比或者视窗单位。视窗尺寸由文档头部的 meta 视窗标签决定，如果没有提供该标签，那么默认宽度为 980px;<br>最常用的是meta视窗值是设备的尺寸</p> <meta name="viewport" content="width=devi；ce-width,initial-scale=1"><h2 id="6-绘制"><a href="#6-绘制" class="headerlink" title="6. 绘制"></a>6. 绘制</h2><p>最后，在绘制步骤中，页面的可见内容可以转换为在屏幕上显示的像素。</p><p>绘制所消耗的时间取决于 DOM 的大小和所应用的样式。有的样式会比其它样式需要更多的执行工作。例如，一个复杂的渐变背景图比一个简单的纯色背景图需要更多的时间</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们可以在开发者工具中查看进程中的关键渲染路径。对于 Chrome，在 Timeline 标签中（对于 Canary，很快成为 Chrome 的稳定版，重命名为 Performance）。</p>]]></content>
    
    
    <categories>
      
      <category>web浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
