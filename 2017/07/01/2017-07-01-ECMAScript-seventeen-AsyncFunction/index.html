

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="朱羽飞">
  <meta name="keywords" content="">
  
    <meta name="description" content="异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 第十七章 异步操作和Async函数">
<meta property="og:url" content="http://example.com/2017/07/01/2017-07-01-ECMAScript-seventeen-AsyncFunction/index.html">
<meta property="og:site_name" content="micky 朱羽飞的博客">
<meta property="og:description" content="异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-07-01T15:22:54.000Z">
<meta property="article:modified_time" content="2023-05-13T16:43:03.101Z">
<meta property="article:author" content="micky">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>ES6 第十七章 异步操作和Async函数 - micky 朱羽飞的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Micky-朱羽飞</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ES6 第十七章 异步操作和Async函数"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-07-01 23:22" pubdate>
          2017年7月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          173 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ES6 第十七章 异步操作和Async函数</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="第十七章-异步操作和Async函数"><a href="#第十七章-异步操作和Async函数" class="headerlink" title="第十七章 异步操作和Async函数"></a>第十七章 异步操作和Async函数</h1><p>异步编程对JavaScript语言太重要。Javascript语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。</p>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ol>
<li><p>回调函数</p>
</li>
<li><p>事件监听</p>
</li>
<li><p>发布&#x2F;订阅</p>
</li>
<li><p>Promise 对象</p>
</li>
</ol>
<p>ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>所谓”异步”，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。<br>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是”重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<p> fs.readFile(‘&#x2F;etc&#x2F;passwd’, function (err, data) {<br>  if (err) throw err;<br>  console.log(data);<br> });</p>
<p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了&#x2F;etc&#x2F;passwd这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<p> fs.readFile(fileA, function (err, data) {<br>  fs.readFile(fileB, function (err, data) {<br>   &#x2F;&#x2F; …<br>  });<br> });</p>
<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调函数噩梦”（callback hell）。</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用Promise，连续读取多个文件，写法如下。</p>
<p> var readFile &#x3D; require(‘fs-readfile-promise’);<br> readFile(fileA)<br> .then(function(data){<br>  console.log(data.toString());<br> })<br> .then(function(){<br>  return readFile(fileB);<br> })<br> .then(function(data){<br>  console.log(data.toString());<br> })<br> .catch(function(err) {<br>  console.log(err);<br> });</p>
<p>上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<p>那么，有没有更好的写法呢？</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一做”协”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p>
<p>第一步，协程A开始执行。</p>
<p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p>
<p>第三步，（一段时间后）协程B交还执行权。</p>
<p>第四步，协程A恢复执行。</p>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<p> function *asyncJob() {<br>  &#x2F;&#x2F; …其他代码<br> var f &#x3D; yield readFile(fileA);<br>  &#x2F;&#x2F; …其他代码<br> }</p>
<p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p>
<p>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="Generator函数的概念"><a href="#Generator函数的概念" class="headerlink" title="Generator函数的概念"></a>Generator函数的概念</h3><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p>
<p> function* gen(x){<br>  var y &#x3D; yield x + 2;<br>  return y;<br> }<br> var g &#x3D; gen(1);<br> g.next() &#x2F;&#x2F; { value: 3, done: false }<br> g.next() &#x2F;&#x2F; { value: undefined, done: true }</p>
<p>上面代码中，调用Generator函数，会返回一个内部指针（即遍历器）g 。</p>
<p>这是Generator函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。</p>
<p>换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示Generator函数是否执行完毕，即是否还有下一个阶段。</p>
<h3 id="Generator函数的数据交换和错误处理"><a href="#Generator函数的数据交换和错误处理" class="headerlink" title="Generator函数的数据交换和错误处理"></a>Generator函数的数据交换和错误处理</h3><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：</p>
<p>函数体内外的数据交换和错误处理机制。</p>
<p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<p> function* gen(x){<br>  var y &#x3D; yield x + 2;<br>  return y;<br> }<br> var g &#x3D; gen(1);<br> g.next() &#x2F;&#x2F; { value: 3, done: false }<br> g.next(2) &#x2F;&#x2F; { value: 2, done: true }</p>
<p>上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<p> function* gen(x){<br>  try {<br>   var y &#x3D; yield x + 2;<br>  } catch (e){<br>   console.log(e);<br>  }<br>  return y;<br> }<br> var g &#x3D; gen(1);<br> g.next();<br> g.throw(‘出错了’);<br> &#x2F;&#x2F; 出错了</p>
<p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<p> var fetch &#x3D; require(‘node-fetch’);<br> function* gen(){<br>  var url &#x3D; ‘<a target="_blank" rel="noopener" href="https://api.github.com/users/github">https://api.github.com/users/github</a>‘;<br>  var result &#x3D; yield fetch(url);<br>  console.log(result.bio);<br> }</p>
<p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>执行这段代码的方法如下。</p>
<p> var g &#x3D; gen();<br> var result &#x3D; g.next();<br> result.value.then(function(data){<br>  return data.json();<br> }).then(function(data){<br>  g.next(data);<br> });</p>
<p>上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h2 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h2><h3 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h3><p>Thunk函数早在上个世纪60年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p>
<p> var x &#x3D; 1;<br> function f(m){<br>  return m * 2;<br> }<br> f(x + 5)</p>
<p>上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？</p>
<p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
<p> f(x + 5)<br> &#x2F;&#x2F; 传值调用时，等同于<br> f(6)<br>另一种意见是”传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。</p>
<p> f(x + 5)<br> &#x2F;&#x2F; 传名调用时，等同于<br> (x + 5) * 2</p>
<p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<p> function f(a, b){<br>  return b;<br> }<br> f(3 <em>x</em> x - 2 * x - 1, x);</p>
<p>上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。</p>
<h3 id="Thunk函数的含义"><a href="#Thunk函数的含义" class="headerlink" title="Thunk函数的含义"></a>Thunk函数的含义</h3><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<p> function f(m){<br>  return m <em>2;<br> }<br> f(x + 5);<br> &#x2F;&#x2F; 等同于<br> var thunk &#x3D; function () {<br>  return x + 5;<br> };<br> function f(thunk){<br>return thunk()</em> 2;<br> }<br>上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。<br>这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p>
<h3 id="JavaScript语言的Thunk函数"><a href="#JavaScript语言的Thunk函数" class="headerlink" title="JavaScript语言的Thunk函数"></a>JavaScript语言的Thunk函数</h3><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<p> &#x2F;&#x2F; 正常版本的readFile（多参数版本）<br> fs.readFile(fileName, callback);<br> &#x2F;&#x2F; Thunk版本的readFile（单参数版本）<br> var readFileThunk &#x3D; Thunk(fileName);<br> readFileThunk(callback);<br> var Thunk &#x3D; function (fileName){<br>  return function (callback){<br>   return fs.readFile(fileName, callback);<br>  };<br> };</p>
<p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p>
<p> &#x2F;&#x2F; ES5版本<br> var Thunk &#x3D; function(fn){<br> return function (){<br>  var args &#x3D; Array.prototype.slice.call(arguments);<br>  return function (callback){<br>   args.push(callback);<br>   return fn.apply(this, args);<br>   }<br>  };<br> };<br> &#x2F;&#x2F; ES6版本<br> var Thunk &#x3D; function(fn) {<br>  return function (…args) {<br>   return function (callback) {<br>    return fn.call(this, …args, callback);<br>   }<br>  };<br> };</p>
<p>使用上面的转换器，生成fs.readFile的Thunk函数。</p>
<p> var readFileThunk &#x3D; Thunk(fs.readFile);<br> readFileThunk(fileA)(callback);</p>
<p>下面是另一个完整的例子。</p>
<p> function f(a, cb) {<br>  cb(a);<br> }<br> let ft &#x3D; Thunk(f);<br> let log &#x3D; console.log.bind(console);<br> ft(1)(log) &#x2F;&#x2F; 1</p>
<h3 id="Thunkify模块"><a href="#Thunkify模块" class="headerlink" title="Thunkify模块"></a>Thunkify模块</h3><p>生产环境的转换器，建议使用Thunkify模块。<br>首先是安装。</p>
<p> $ npm install thunkify<br> 使用方式如下。<br> var thunkify &#x3D; require(‘thunkify’);<br> var fs &#x3D; require(‘fs’);<br> var read &#x3D; thunkify(fs.readFile);<br> read(‘package.json’)(function(err, str){<br>  &#x2F;&#x2F; …<br> });<br> Thunkify的源码与上一节那个简单的转换器非常像。<br> function thunkify(fn){<br>  return function(){<br>  var args &#x3D; new Array(arguments.length);<br>  var ctx &#x3D; this;<br>  for(var i &#x3D; 0; i &lt; args.length; ++i) {<br>   args[i] &#x3D; arguments[i];<br>  }<br>  return function(done){<br>   var called;<br>   args.push(function(){<br>    if (called) return;<br>    called &#x3D; true;<br>    done.apply(null, arguments);<br>   });<br>   try {<br>    fn.apply(ctx, args);<br>    } catch (err) {<br>     done(err);<br>    }<br>   }<br>  }<br> };</p>
<p>它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<p> function f(a, b, callback){<br>  var sum &#x3D; a + b;<br>  callback(sum);<br>  callback(sum);<br> }<br> var ft &#x3D; thunkify(f);<br> var print &#x3D; console.log.bind(console);<br> ft(1, 2)(print);<br> &#x2F;&#x2F; 3<br>上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。</p>
<h3 id="Generator-函数的流程管理"><a href="#Generator-函数的流程管理" class="headerlink" title="Generator 函数的流程管理"></a>Generator 函数的流程管理</h3><p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p>
<p> Generator函数可以自动执行。<br> function* gen() {<br>  &#x2F;&#x2F; …<br> }<br> var g &#x3D; gen();<br> var res &#x3D; g.next();<br> while(!res.done){<br>  console.log(res.value);<br>  res &#x3D; g.next();<br> }<br>上面代码中，Generator函数gen会自动执行完所有步骤。</p>
<p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk函数就能派上用处。以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<p> var fs &#x3D; require(‘fs’);<br> var thunkify &#x3D; require(‘thunkify’);<br> var readFile &#x3D; thunkify(fs.readFile);<br> var gen &#x3D; function* (){<br>  var r1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  console.log(r1.toString());<br>  var r2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(r2.toString());<br>  };</p>
<p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p>
<p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p>
<p> var g &#x3D; gen();<br> var r1 &#x3D; g.next();<br> r1.value(function(err, data){<br>  if (err) throw err;<br>  var r2 &#x3D; g.next(data);<br>  r2.value(function(err, data){<br>   if (err) throw err;<br>  g.next(data);<br> });<br> });</p>
<p>上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。</p>
<p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p>
<h3 id="Thunk函数的自动流程管理"><a href="#Thunk函数的自动流程管理" class="headerlink" title="Thunk函数的自动流程管理"></a>Thunk函数的自动流程管理</h3><p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<p> function run(fn) {<br>  var gen &#x3D; fn();<br>  function next(err, data) {<br>   var result &#x3D; gen.next(data);<br>   if (result.done) return;<br>   result.value(next);<br>  }<br>  next();<br> }<br> function* g() {<br>  &#x2F;&#x2F; …<br> }<br> run(g);</p>
<p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。</p>
<p>有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。</p>
<p> var g &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘fileA’);<br>  var f2 &#x3D; yield readFile(‘fileB’);<br>  &#x2F;&#x2F; …<br>  var fn &#x3D; yield readFile(‘fileN’);<br> };<br> run(g);</p>
<p>上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。</p>
<p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h2 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。<br>比如，有一个Generator函数，用于依次读取两个文件。</p>
<p> var gen &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };<br>co模块可以让你不用编写Generator函数的执行器。</p>
<p> var co &#x3D; require(‘co’);<br> co(gen);<br>上面代码中，Generator函数只要传入co函数，就会自动执行。</p>
<p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<p> co(gen).then(function (){<br>  console.log(‘Generator 函数执行完成’);<br> });<br>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<h3 id="co模块的原理"><a href="#co模块的原理" class="headerlink" title="co模块的原理"></a>co模块的原理</h3><p>为什么co可以自动执行Generator函数？</p>
<p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<ul>
<li><p>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</p>
</li>
<li><p>Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</p>
</li>
<li></li>
</ul>
<p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>上一节已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h3 id="基于Promise对象的自动执行"><a href="#基于Promise对象的自动执行" class="headerlink" title="基于Promise对象的自动执行"></a>基于Promise对象的自动执行</h3><p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<p> var fs &#x3D; require(‘fs’);<br> var readFile &#x3D; function (fileName){<br>  return new Promise(function (resolve, reject){<br>   fs.readFile(fileName, function(error, data){<br>    if (error) return reject(error);<br>    resolve(data);<br>   });<br>  });<br> };<br> var gen &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };<br> 然后，手动执行上面的Generator函数。<br> var g &#x3D; gen();<br> g.next().value.then(function(data){<br>  g.next(data).value.then(function(data){<br>   g.next(data);<br>  });<br> });</p>
<p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<p> function run(gen){<br>  var g &#x3D; gen();<br>  function next(data){<br>   var result &#x3D; g.next(data);<br>   if (result.done)<br>    return result.value;<br>   result.value.then(function(data){<br>    next(data);<br>   });<br>  }<br> next();<br> }<br> run(gen);</p>
<p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<h3 id="co模块的源码"><a href="#co模块的源码" class="headerlink" title="co模块的源码"></a>co模块的源码</h3><p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。</p>
<p>首先，co函数接受Generator函数作为参数，返回一个 Promise 对象。</p>
<p> function co(gen) {<br>  var ctx &#x3D; this;<br>  return new Promise(function(resolve, reject) {<br>  });<br> }<br>在返回的Promise对象里面，co先检查参数gen是否为Generator函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将Promise对象的状态改为resolved。</p>
<p> function co(gen) {<br>  var ctx &#x3D; this;<br>  return new Promise(function(resolve, reject) {<br>   if (typeof gen &#x3D;&#x3D;&#x3D; ‘function’) gen &#x3D; gen.call(ctx);<br>   if (!gen || typeof gen.next !&#x3D;&#x3D; ‘function’) return resolve(gen);<br>  });<br> }</p>
<p>接着，co将Generator函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</p>
<p> function co(gen) {<br>  var ctx &#x3D; this;<br>  return new Promise(function(resolve, reject) {<br>   if (typeof gen &#x3D;&#x3D;&#x3D; ‘function’) gen &#x3D; gen.call(ctx);<br>   if (!gen || typeof gen.next !&#x3D;&#x3D; ‘function’) return resolve(gen);<br>   onFulfilled();<br>   function onFulfilled(res) {<br>    var ret;<br>    try {<br>     ret &#x3D; gen.next(res);<br>    } catch (e) {<br>     return reject(e);<br>    }<br>    next(ret);<br>   }<br>  });<br> }</p>
<p>最后，就是关键的next函数，它会反复调用自身。</p>
<p> function next(ret) {<br> if (ret.done)<br>  return resolve(ret.value);<br> var value &#x3D; toPromise.call(ctx, ret.value);<br> if (value &amp;&amp; isPromise(value))<br>  return value.then(onFulfilled, onRejected);<br> return onRejected(new TypeError(‘You may only yield a function, promise, generator, array, or object, ‘+ ‘but the following object was passed: “‘ + String(ret.value) + ‘“‘));<br> }</p>
<p>上面代码中，next 函数的内部代码，一共只有四行命令。</p>
<p>第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。</p>
<p>第二行，确保每一步的返回值，是 Promise 对象。</p>
<p>第三行，使用 then 方法，为返回值加上回调函数，然后通过 onFulfilled 函数再次调用 next 函数。</p>
<p>第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为 rejected，从而终止执行。</p>
<h3 id="处理并发的异步操作"><a href="#处理并发的异步操作" class="headerlink" title="处理并发的异步操作"></a>处理并发的异步操作</h3><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<p> &#x2F;&#x2F; 数组的写法<br> co(function* () {<br>  var res &#x3D; yield [<br>   Promise.resolve(1),<br>   Promise.resolve(2)<br>  ];<br> console.log(res);<br> }).catch(onerror);</p>
<p> &#x2F;&#x2F; 对象的写法<br> co(function*() {<br>  var res &#x3D; yield {<br>   1: Promise.resolve(1),<br>   2: Promise.resolve(2),<br> };<br> console.log(res);<br> }).catch(onerror);<br> 下面是另一个例子。<br> co(function* () {<br>  var values &#x3D; [n1, n2, n3];<br>  yield values.map(somethingAsync);<br> });<br> function* somethingAsync(x) {<br>  &#x2F;&#x2F; do something async<br>  return y<br> }<br>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p>
<h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>ES7提供了async函数，使得异步操作变得更加方便。async函数是什么？一句话，async函数就是Generator函数的语法糖。</p>
<p>前文有一个Generator函数，依次读取两个文件。</p>
<p> var fs &#x3D; require(‘fs’);<br> var readFile &#x3D; function (fileName) {<br>  return new Promise(function (resolve, reject) {<br>   fs.readFile(fileName, function(error, data) {<br>    if (error) reject(error);<br>    resolve(data);<br>   });<br>  });<br> };<br> var gen &#x3D; function* (){<br>  var f1 &#x3D; yield readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; yield readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };<br> 写成async函数，就是下面这样。<br> var asyncReadFile &#x3D; async function (){<br>  var f1 &#x3D; await readFile(‘&#x2F;etc&#x2F;fstab’);<br>  var f2 &#x3D; await readFile(‘&#x2F;etc&#x2F;shells’);<br>  console.log(f1.toString());<br>  console.log(f2.toString());<br> };</p>
<p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async函数对 Generator 函数的改进，体现在以下四点。</p>
<ol>
<li>内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>
</ol>
<p>  var result &#x3D; asyncReadFile();</p>
<p> 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像Generator函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。</p>
<ol start="2">
<li><p>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
</li>
<li><p>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p>
</li>
<li><p>返回值是Promise。async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便多了。你可以用then方法指定下一步的操作。</p>
</li>
<li></li>
</ol>
<p>进一步说，async函数完全可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>async函数的语法规则总体上比较简单，难点是错误处理机制。</p>
<ol>
<li>async函数返回一个Promise对象。</li>
</ol>
<p> async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<p>  async function f() {<br>   return ‘hello world’;<br>  }<br>  f().then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; “hello world”</p>
<p> 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。<br> async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p>
<p>  async function f() {<br>   throw new Error(‘出错了’);<br>  }<br>  f().then(<br>   v &#x3D;&gt; console.log(v),<br>   e &#x3D;&gt; console.log(e)<br>  )<br>  &#x2F;&#x2F; Error: 出错了</p>
<ol start="2">
<li>async函数返回的Promise对象，必须等到内部所有await命令的Promise对象执行完，才会发生状态改变。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>
</ol>
<p> 下面是一个例子。</p>
<p>  async function getTitle(url) {<br>   let response &#x3D; await fetch(url);<br>   let html &#x3D; await response.text();<br>   return html.match(&#x2F;<title>([\s\S]+)&lt;/title&gt;&#x2F;i)[1];<br>  }<br>  getTitle(‘<a target="_blank" rel="noopener" href="https://tc39.github.io/ecma262/&#39;).then(console.log)">https://tc39.github.io/ecma262/&#39;).then(console.log)</a><br>  &#x2F;&#x2F; “ECMAScript 2017 Language Specification”<br>3. 正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。<br>  async function f() {<br>   return await 123;<br>  }<br>  f().then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; 123</p>
<p> 上面代码中，await命令的参数是数值123，它被转成Promise对象，并立即resolve。</p>
<p> await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</p>
<p>  async function f() {<br>   await Promise.reject(‘出错了’);<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  .catch(e &#x3D;&gt; console.log(e))<br>  &#x2F;&#x2F; 出错了</p>
<p> 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。</p>
<p> 只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。</p>
<p>  async function f() {<br>   await Promise.reject(‘出错了’);<br>   await Promise.resolve(‘hello world’); &#x2F;&#x2F; 不会执行<br>  }<br> 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。</p>
<p> 为了避免这个问题，可以将第一个await放在try…catch结构里面，这样第二个await就会执行。</p>
<p>  async function f() {<br>   try {<br>    await Promise.reject(‘出错了’);<br>   } catch(e) {<br>   }<br>   return await Promise.resolve(‘hello world’);<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; hello world</p>
<p> 另一种方法是await后面的Promise对象再跟一个catch方面，处理前面可能出现的错误。</p>
<p>  async function f() {<br>   await Promise.reject(‘出错了’)<br>   .catch(e &#x3D;&gt; console.log(e));<br>   return await Promise.resolve(‘hello world’);<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  &#x2F;&#x2F; 出错了<br>  &#x2F;&#x2F; hello world</p>
<p> 如果有多个await命令，可以统一放在try…catch结构中。</p>
<p>  async function main() {<br>   try {<br>    var val1 &#x3D; await firstStep();<br>    var val2 &#x3D; await secondStep(val1);<br>    var val3 &#x3D; await thirdStep(val1, val2);<br>    console.log(‘Final: ‘, val3);<br>   }<br>   catch (err) {<br>    console.error(err);<br>   }<br>  }</p>
<ol start="4">
<li>如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。</li>
</ol>
<p>  async function f() {<br>   await new Promise(function (resolve, reject) {<br>    throw new Error(‘出错了’);<br>   });<br>  }<br>  f()<br>  .then(v &#x3D;&gt; console.log(v))<br>  .catch(e &#x3D;&gt; console.log(e))<br>  &#x2F;&#x2F; Error：出错了</p>
<p> 上面代码中，async函数f执行后，await后面的Promise对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现”。</p>
<p> 防止出错的方法，也是将其放在try…catch代码块之中。</p>
<p>  async function f() {<br>  try {<br>   await new Promise(function (resolve, reject) {<br>    throw new Error(‘出错了’);<br>   });<br>   } catch(e) {<br>  }<br>   return await(‘hello world’);<br>  }</p>
<h3 id="async函数的实现"><a href="#async函数的实现" class="headerlink" title="async函数的实现"></a>async函数的实现</h3><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<p> async function fn(args){<br>  &#x2F;&#x2F; …<br> }<br> &#x2F;&#x2F; 等同于<br> function fn(args){<br>  return spawn(function*() {<br>  &#x2F;&#x2F; …<br>  });<br> }</p>
<p>所有的async函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<p>下面给出spawn函数的实现，基本就是前文自动执行器的翻版。</p>
<p> function spawn(genF) {<br>  return new Promise(function(resolve, reject) {<br>  var gen &#x3D; genF();<br> function step(nextF) {<br>  try {<br>   var next &#x3D; nextF();<br>  } catch(e) {<br>   return reject(e);<br>  }<br> if(next.done) {<br>  return resolve(next.value);<br> }<br> Promise.resolve(next.value).then(function(v) {<br>  step(function() { return gen.next(v); });<br> }, function(e) {<br>   step(function() { return gen.throw(e); });<br>  });<br>  }<br>  step(function() { return gen.next(undefined); });<br>  });<br> }<br>async函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器Babel和regenerator都已经支持，转码后就能使用。</p>
<h3 id="async-函数的用法"><a href="#async-函数的用法" class="headerlink" title="async 函数的用法"></a>async 函数的用法</h3><p>async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<p> async function getStockPriceByName(name) {<br>  var symbol &#x3D; await getStockSymbol(name);<br>  var stockPrice &#x3D; await getStockPrice(symbol);<br>  return stockPrice;<br> }<br> getStockPriceByName(‘goog’).then(function (result) {<br>  console.log(result);<br> });</p>
<p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p>
<p>下面的例子，指定多少毫秒后输出一个值。</p>
<p> function timeout(ms) {<br>  return new Promise((resolve) &#x3D;&gt; {<br>   setTimeout(resolve, ms);<br>  });<br> }<br> async function asyncPrint(value, ms) {<br>  await timeout(ms);<br>  console.log(value)<br> }<br> asyncPrint(‘hello world’, 50);</p>
<p>上面代码指定50毫秒以后，输出”hello world”。</p>
<p>Async函数有多种使用形式。</p>
<p> &#x2F;&#x2F; 函数声明</p>
<p> async function foo() {}</p>
<p> &#x2F;&#x2F; 函数表达式<br> const foo &#x3D; async function () {};</p>
<p> &#x2F;&#x2F; 对象的方法<br> let obj &#x3D; { async foo() {} };</p>
<p> &#x2F;&#x2F; 箭头函数<br> const foo &#x3D; async () &#x3D;&gt; {};</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>第一点，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p>
<p> async function myFunction() {<br>  try {<br>   await somethingThatReturnsAPromise();<br>  } catch (err) {<br>   console.log(err);<br>  }<br> }</p>
<p> &#x2F;&#x2F; 另一种写法<br> async function myFunction() {<br>  await somethingThatReturnsAPromise()<br>  .catch(function (err) {<br>   console.log(err);<br>  };<br> }</p>
<p>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<p> let foo &#x3D; await getFoo();<br> let bar &#x3D; await getBar();</p>
<p>上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</p>
<p> &#x2F;&#x2F; 写法一<br> let [foo, bar] &#x3D; await Promise.all([getFoo(), getBar()]);<br> &#x2F;&#x2F; 写法二<br> let fooPromise &#x3D; getFoo();<br> let barPromise &#x3D; getBar();<br> let foo &#x3D; await fooPromise;<br> let bar &#x3D; await barPromise;</p>
<p>上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</p>
<p>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>
<p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  &#x2F;&#x2F; 报错<br>  docs.forEach(function (doc) {<br>   await db.post(doc);<br>  });<br> }<br>上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。</p>
<p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  &#x2F;&#x2F; 可能得到错误结果<br>  docs.forEach(async function (doc) {<br>   await db.post(doc);<br>  });<br> }<br>上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p>
<p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  for (let doc of docs) {<br>   await db.post(doc);<br>  }<br> }</p>
<p>如果确实希望多个请求并发执行，可以使用Promise.all方法。</p>
<p> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  let promises &#x3D; docs.map((doc) &#x3D;&gt; db.post(doc));<br>  let results &#x3D; await Promise.all(promises);<br>  console.log(results);<br> }<br> &#x2F;&#x2F; 或者使用下面的写法<br> async function dbFuc(db) {<br>  let docs &#x3D; [{}, {}, {}];<br>  let promises &#x3D; docs.map((doc) &#x3D;&gt; db.post(doc));<br>  let results &#x3D; [];<br>  for (let promise of promises) {<br>   results.push(await promise);<br>  }<br>  console.log(results);<br> }</p>
<p>ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p>
<h3 id="与Promise、Generator的比较"><a href="#与Promise、Generator的比较" class="headerlink" title="与Promise、Generator的比较"></a>与Promise、Generator的比较</h3><p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p>
<p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是Promise的写法。</p>
<p> function chainAnimationsPromise(elem, animations) {<br>  &#x2F;&#x2F; 变量ret用来保存上一个动画的返回值<br>  var ret &#x3D; null;<br>  &#x2F;&#x2F; 新建一个空的Promise<br>  var p &#x3D; Promise.resolve();<br>  &#x2F;&#x2F; 使用then方法，添加所有动画<br>  for(var anim of animations) {<br>   p &#x3D; p.then(function(val) {<br>   ret &#x3D; val;<br>   return anim(elem);<br>  });<br>  }<br>  &#x2F;&#x2F; 返回一个部署了错误捕捉机制的Promise<br>  return p.catch(function(e) {<br>   &#x2F;<em>忽略错误，继续执行</em>&#x2F;<br>  }).then(function() {<br>   return ret;<br>  });<br> }</p>
<p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p>接着是Generator函数的写法。</p>
<p> function chainAnimationsGenerator(elem, animations) {<br>  return spawn(function*() {<br>   var ret &#x3D; null;<br>   try {<br>    for(var anim of animations) {<br>     ret &#x3D; yield anim(elem);<br>    }<br>   } catch(e) {<br>    &#x2F;* 忽略错误，继续执行 *&#x2F;<br>   }<br>   return ret;<br>  });<br> }<br>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p>
<p>最后是Async函数的写法。</p>
<p> async function chainAnimationsAsync(elem, animations) {<br> var ret &#x3D; null;<br> try {<br>  for(var anim of animations) {<br>  ret &#x3D; await anim(elem);<br>  }<br> } catch(e) {<br>  &#x2F;<em>忽略错误，继续执行</em>&#x2F;<br> }<br>  return ret;<br> }<br>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/ES6/" class="category-chain-item">ES6</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ES6/">#ES6</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ES6 第十七章 异步操作和Async函数</div>
      <div>http://example.com/2017/07/01/2017-07-01-ECMAScript-seventeen-AsyncFunction/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>朱羽飞</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年7月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/07/03/2017-07-03-ECAMScript-eighteen-Class/" title="ES6 第十八章	Class">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ES6 第十八章	Class</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/06/30/2017-06-30-ECAMScript-sixteen-Promise-object/" title="ES6 第十六章 Promise对象">
                        <span class="hidden-mobile">ES6 第十六章 Promise对象</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
